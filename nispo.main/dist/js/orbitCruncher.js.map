{"version":3,"file":"orbitCruncher.js","sources":["webpack://nispo-track/./src/engine/ootk/src/body/Celestial.ts","webpack://nispo-track/./src/engine/ootk/src/body/Earth.ts","webpack://nispo-track/./src/engine/ootk/src/body/Moon.ts","webpack://nispo-track/./src/engine/ootk/src/body/Sun.ts","webpack://nispo-track/./src/engine/ootk/src/body/index.ts","webpack://nispo-track/./src/engine/ootk/src/coordinate/ClassicalElements.ts","webpack://nispo-track/./src/engine/ootk/src/coordinate/EquinoctialElements.ts","webpack://nispo-track/./src/engine/ootk/src/coordinate/FormatTle.ts","webpack://nispo-track/./src/engine/ootk/src/coordinate/Geodetic.ts","webpack://nispo-track/./src/engine/ootk/src/coordinate/Hill.ts","webpack://nispo-track/./src/engine/ootk/src/coordinate/ITRF.ts","webpack://nispo-track/./src/engine/ootk/src/coordinate/J2000.ts","webpack://nispo-track/./src/engine/ootk/src/coordinate/RIC.ts","webpack://nispo-track/./src/engine/ootk/src/coordinate/RelativeState.ts","webpack://nispo-track/./src/engine/ootk/src/coordinate/StateVector.ts","webpack://nispo-track/./src/engine/ootk/src/coordinate/TEME.ts","webpack://nispo-track/./src/engine/ootk/src/coordinate/Tle.ts","webpack://nispo-track/./src/engine/ootk/src/coordinate/index.ts","webpack://nispo-track/./src/engine/ootk/src/coordinate/tle-format-data.ts","webpack://nispo-track/./src/engine/ootk/src/covariance/CovarianceSample.ts","webpack://nispo-track/./src/engine/ootk/src/covariance/StateCovariance.ts","webpack://nispo-track/./src/engine/ootk/src/covariance/index.ts","webpack://nispo-track/./src/engine/ootk/src/data/DataHandler.ts","webpack://nispo-track/./src/engine/ootk/src/data/values/Egm96Data.ts","webpack://nispo-track/./src/engine/ootk/src/data/values/HpAtmosphereData.ts","webpack://nispo-track/./src/engine/ootk/src/data/values/HpAtmosphereResult.ts","webpack://nispo-track/./src/engine/ootk/src/data/values/Iau1980Data.ts","webpack://nispo-track/./src/engine/ootk/src/data/values/LeapSecond.ts","webpack://nispo-track/./src/engine/ootk/src/data/values/LeapSecondData.ts","webpack://nispo-track/./src/engine/ootk/src/data/values/egm96.ts","webpack://nispo-track/./src/engine/ootk/src/data/values/hpAtmosphere.ts","webpack://nispo-track/./src/engine/ootk/src/data/values/iau1980.ts","webpack://nispo-track/./src/engine/ootk/src/enums/AngularDiameterMethod.ts","webpack://nispo-track/./src/engine/ootk/src/enums/AngularDistanceMethod.ts","webpack://nispo-track/./src/engine/ootk/src/enums/CatalogSource.ts","webpack://nispo-track/./src/engine/ootk/src/enums/CommLink.ts","webpack://nispo-track/./src/engine/ootk/src/enums/OrbitRegime.ts","webpack://nispo-track/./src/engine/ootk/src/enums/PassType.ts","webpack://nispo-track/./src/engine/ootk/src/enums/Sgp4OpsMode.ts","webpack://nispo-track/./src/engine/ootk/src/enums/index.ts","webpack://nispo-track/./src/engine/ootk/src/force/AtmosphericDrag.ts","webpack://nispo-track/./src/engine/ootk/src/force/EarthGravity.ts","webpack://nispo-track/./src/engine/ootk/src/force/Force.ts","webpack://nispo-track/./src/engine/ootk/src/force/ForceModel.ts","webpack://nispo-track/./src/engine/ootk/src/force/Gravity.ts","webpack://nispo-track/./src/engine/ootk/src/force/SolarRadiationPressure.ts","webpack://nispo-track/./src/engine/ootk/src/force/ThirdBodyGravity.ts","webpack://nispo-track/./src/engine/ootk/src/force/Thrust.ts","webpack://nispo-track/./src/engine/ootk/src/force/index.ts","webpack://nispo-track/./src/engine/ootk/src/interfaces/index.ts","webpack://nispo-track/./src/engine/ootk/src/interpolator/CubicSpline.ts","webpack://nispo-track/./src/engine/ootk/src/interpolator/CubicSplineInterpolator.ts","webpack://nispo-track/./src/engine/ootk/src/interpolator/Interpolator.ts","webpack://nispo-track/./src/engine/ootk/src/interpolator/LagrangeInterpolator.ts","webpack://nispo-track/./src/engine/ootk/src/interpolator/StateInterpolator.ts","webpack://nispo-track/./src/engine/ootk/src/interpolator/VerletBlendInterpolator.ts","webpack://nispo-track/./src/engine/ootk/src/main.ts","webpack://nispo-track/./src/engine/ootk/src/objects/BaseObject.ts","webpack://nispo-track/./src/engine/ootk/src/objects/DetailedSatellite.ts","webpack://nispo-track/./src/engine/ootk/src/objects/DetailedSensor.ts","webpack://nispo-track/./src/engine/ootk/src/objects/GroundObject.ts","webpack://nispo-track/./src/engine/ootk/src/objects/LandObject.ts","webpack://nispo-track/./src/engine/ootk/src/objects/Marker.ts","webpack://nispo-track/./src/engine/ootk/src/objects/RfSensor.ts","webpack://nispo-track/./src/engine/ootk/src/objects/Satellite.ts","webpack://nispo-track/./src/engine/ootk/src/objects/Sensor.ts","webpack://nispo-track/./src/engine/ootk/src/objects/Star.ts","webpack://nispo-track/./src/engine/ootk/src/objects/index.ts","webpack://nispo-track/./src/engine/ootk/src/observation/ObservationUtils.ts","webpack://nispo-track/./src/engine/ootk/src/observation/PropagatorPairs.ts","webpack://nispo-track/./src/engine/ootk/src/observation/RAE.ts","webpack://nispo-track/./src/engine/ootk/src/observation/RadecGeocentric.ts","webpack://nispo-track/./src/engine/ootk/src/observation/RadecTopocentric.ts","webpack://nispo-track/./src/engine/ootk/src/observation/index.ts","webpack://nispo-track/./src/engine/ootk/src/operations/BoxMuller.ts","webpack://nispo-track/./src/engine/ootk/src/operations/EulerAngles.ts","webpack://nispo-track/./src/engine/ootk/src/operations/Matrix.ts","webpack://nispo-track/./src/engine/ootk/src/operations/Quaternion.ts","webpack://nispo-track/./src/engine/ootk/src/operations/Random.ts","webpack://nispo-track/./src/engine/ootk/src/operations/RandomGaussianSource.ts","webpack://nispo-track/./src/engine/ootk/src/operations/Vector.ts","webpack://nispo-track/./src/engine/ootk/src/operations/Vector3D.ts","webpack://nispo-track/./src/engine/ootk/src/operations/index.ts","webpack://nispo-track/./src/engine/ootk/src/operations/operations.ts","webpack://nispo-track/./src/engine/ootk/src/optimize/DownhillSimplex.ts","webpack://nispo-track/./src/engine/ootk/src/optimize/GoldenSection.ts","webpack://nispo-track/./src/engine/ootk/src/optimize/SimplexEntry.ts","webpack://nispo-track/./src/engine/ootk/src/orbit_determination/BatchLeastSquaresOD.ts","webpack://nispo-track/./src/engine/ootk/src/orbit_determination/BatchLeastSquaresResult.ts","webpack://nispo-track/./src/engine/ootk/src/orbit_determination/GibbsIOD.ts","webpack://nispo-track/./src/engine/ootk/src/orbit_determination/GoodingIOD.ts","webpack://nispo-track/./src/engine/ootk/src/orbit_determination/HerrickGibbsIOD.ts","webpack://nispo-track/./src/engine/ootk/src/orbit_determination/LambertIOD.ts","webpack://nispo-track/./src/engine/ootk/src/orbit_determination/ModifiedGoodingIOD.ts","webpack://nispo-track/./src/engine/ootk/src/orbit_determination/index.ts","webpack://nispo-track/./src/engine/ootk/src/propagator/KeplerPropagator.ts","webpack://nispo-track/./src/engine/ootk/src/propagator/Propagator.ts","webpack://nispo-track/./src/engine/ootk/src/propagator/RkCheckpoint.ts","webpack://nispo-track/./src/engine/ootk/src/propagator/RkResult.ts","webpack://nispo-track/./src/engine/ootk/src/propagator/RungeKutta4Propagator.ts","webpack://nispo-track/./src/engine/ootk/src/propagator/RungeKutta89Propagator.ts","webpack://nispo-track/./src/engine/ootk/src/propagator/RungeKuttaAdaptive.ts","webpack://nispo-track/./src/engine/ootk/src/propagator/Sgp4Propagator.ts","webpack://nispo-track/./src/engine/ootk/src/propagator/index.ts","webpack://nispo-track/./src/engine/ootk/src/sgp4/index.ts","webpack://nispo-track/./src/engine/ootk/src/sgp4/sgp4-error.ts","webpack://nispo-track/./src/engine/ootk/src/sgp4/sgp4.ts","webpack://nispo-track/./src/engine/ootk/src/time/Epoch.ts","webpack://nispo-track/./src/engine/ootk/src/time/EpochGPS.ts","webpack://nispo-track/./src/engine/ootk/src/time/EpochTAI.ts","webpack://nispo-track/./src/engine/ootk/src/time/EpochTDB.ts","webpack://nispo-track/./src/engine/ootk/src/time/EpochTT.ts","webpack://nispo-track/./src/engine/ootk/src/time/EpochUTC.ts","webpack://nispo-track/./src/engine/ootk/src/time/EpochWindow.ts","webpack://nispo-track/./src/engine/ootk/src/time/TimeStamped.ts","webpack://nispo-track/./src/engine/ootk/src/time/index.ts","webpack://nispo-track/./src/engine/ootk/src/transforms/conversions.ts","webpack://nispo-track/./src/engine/ootk/src/transforms/index.ts","webpack://nispo-track/./src/engine/ootk/src/transforms/transforms.ts","webpack://nispo-track/./src/engine/ootk/src/types/types.ts","webpack://nispo-track/./src/engine/ootk/src/utils/constants.ts","webpack://nispo-track/./src/engine/ootk/src/utils/create-covariance-from-tle.ts","webpack://nispo-track/./src/engine/ootk/src/utils/functions.ts","webpack://nispo-track/./src/engine/ootk/src/utils/index.ts","webpack://nispo-track/./src/engine/ootk/src/utils/jacobian.ts","webpack://nispo-track/./src/engine/ootk/src/utils/linearDistance.ts","webpack://nispo-track/./src/engine/utils/constants.ts","webpack://nispo-track/./src/engine/utils/external/meuusjs.ts","webpack://nispo-track/./src/engine/utils/transforms.ts","webpack://nispo-track/./src/webworker/orbit-cruncher-interfaces.ts","webpack://nispo-track/./src/webworker/positionCruncher/calculations.ts","webpack://nispo-track/webpack/runtime/define_property_getters","webpack://nispo-track/webpack/runtime/has_own_property","webpack://nispo-track/webpack/runtime/make_namespace_object","webpack://nispo-track/webpack/runtime/rspack_version","webpack://nispo-track/webpack/runtime/rspack_unique_id","webpack://nispo-track/./src/webworker/orbitCruncher.ts"],"sourcesContent":["/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { RAD2DEG, Sun } from '../main.js';\n/**\n * Celestial is a static class that provides methods for calculating the position of celestial objects such as the Sun,\n * Moon, and planets in the sky. To create an instance of a Celestial object, use the Star class.\n */\nexport class Celestial {\n    constructor() {\n        // disable constructor\n    }\n    /**\n     * Calculates the azimuth and elevation of a celestial object at a given date, latitude,\n     * longitude, right ascension, and declination.\n     * @param date - The date for which to calculate the azimuth and elevation.\n     * @param lat - The latitude of the observer.\n     * @param lon - The longitude of the observer.\n     * @param ra - The right ascension of the celestial object.\n     * @param dec - The declination of the celestial object.\n     * @returns An object containing the azimuth and elevation in degrees.\n     */\n    static azEl(date, lat, lon, ra, dec) {\n        const c = {\n            ra,\n            dec,\n            dist: 0,\n        };\n        const azEl = Sun.azEl(date, lat, lon, c);\n        const el = (azEl.el + Celestial.atmosphericRefraction(azEl.el)); // elevation correction for refraction\n        return {\n            az: (azEl.az * RAD2DEG),\n            el: (el * RAD2DEG),\n        };\n    }\n    /**\n     * Atmospheric refraction in astronomy, refers to the bending of light as it passes through the Earth's\n     * atmosphere. This effect is most noticeable for celestial objects like stars and planets when they are\n     * close to the horizon. Here's a breakdown of how it works:\n     *\n     * Actual Position: Due to this bending of light, the apparent position of a celestial object is slightly\n     * different from its true position in the sky. When a star or planet is near the horizon, the effect is more\n     * pronounced because the light path passes through more of the Earth's atmosphere, which increases the amount of\n     * bending.\n     *\n     * A familiar example of atmospheric refraction is observed during sunrise and sunset. The Sun appears to\n     * be above the horizon when it is actually just below it. This is because the light from the Sun is bent\n     * upwards as it passes through the atmosphere.\n     * @param h - elevation\n     * @returns refraction\n     */\n    static atmosphericRefraction(h) {\n        if (h < 0) {\n            h = 0;\n        }\n        return (0.0002967 / Math.tan(h + 0.00312536 / (h + 0.08901179)));\n    }\n    /**\n     * Calculate the declination. Similar to latitude on Earth, declination is another celestial coordinate.\n     * It measures how far north or south an object is from the celestial equator\n     * @param l - ecliptic longitude\n     * @param b - ecliptic latitude\n     * @returns declination\n     */\n    static declination(l, b) {\n        return Math.asin(Math.sin(b) * Math.cos(Sun.e) + Math.cos(b) * Math.sin(Sun.e) * Math.sin(l));\n    }\n    /**\n     * Calculate the right ascension. This is a celestial coordinate used to determine the position of objects\n     * in the sky. It's analogous to longitude on Earth. Right Ascension indicates how far east an object is\n     * from the vernal equinox along the celestial equator.\n     * @param l - ecliptic longitude\n     * @param b - ecliptic latitude\n     * @returns right ascension\n     */\n    static rightAscension(l, b) {\n        return Math.atan2(Math.sin(l) * Math.cos(Sun.e) - Math.tan(b) * Math.sin(Sun.e), Math.cos(l));\n    }\n    /**\n     * Calculate the elevation. Elevation, or altitude, is the angle between an object in the sky and the\n     * observer's local horizon. It's commonly expressed in degrees, where 0 degrees is right at the horizon\n     * and 90 degrees is directly overhead (the zenith), but we are using radians to support trigonometric\n     * functions like Math.sin() and Math.cos().\n     * @param H - siderealTime\n     * @param phi - latitude\n     * @param dec - The declination of the sun\n     * @returns elevation\n     */\n    static elevation(H, phi, dec) {\n        return Math.asin(Math.sin(phi) * Math.sin(dec) + Math.cos(phi) * Math.cos(dec) * Math.cos(H));\n    }\n    /**\n     * Calculate the azimuth. This is a compass direction measurement. Azimuth measures the angle along\n     * the horizon from a specific reference direction (usually true north) to the point where a vertical\n     * line from the object intersects the horizon.\n     * @param H - siderealTime\n     * @param phi - latitude\n     * @param dec - The declination of the sun\n     * @returns azimuth in rad\n     */\n    static azimuth(H, phi, dec) {\n        return (Math.PI + Math.atan2(Math.sin(H), Math.cos(H) * Math.sin(phi) - Math.tan(dec) * Math.cos(phi)));\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { angularDiameter, AngularDiameterMethod, asec2rad, DataHandler, DEG2RAD, earthGravityParam, evalPoly, RAD2DEG, secondsPerDay, secondsPerSiderealDay, TAU, ttasec2rad, Vector3D, } from '../main.js';\n// / Earth metrics and operations.\nexport class Earth {\n    constructor() {\n        // disable constructor\n    }\n    // / Earth gravitational parameter _(kmÂ²/sÂ³)_.\n    static mu = earthGravityParam;\n    // / Earth equatorial radius.\n    static radiusEquator = 6378.1363;\n    // / Earth coefficient of flattening _(unitless)_.\n    static flattening = 1.0 / 298.257223563;\n    // / Earth polar radius.\n    static radiusPolar = (Earth.radiusEquator * (1.0 - Earth.flattening));\n    // / Earth mean radius.\n    static radiusMean = ((2.0 * Earth.radiusEquator + Earth.radiusPolar) / 3.0);\n    // / Earth eccentricity squared _(unitless)_.\n    static eccentricitySquared = Earth.flattening * (2.0 - Earth.flattening);\n    // / Earth J2 effect coefficient _(unitless)_.\n    static j2 = 1.08262668355315e-3;\n    // / Earth J3 effect coefficient _(unitless)_.\n    static j3 = -2.53265648533224e-6;\n    // / Earth J4 effect coefficient _(unitless)_.\n    static j4 = -1.619621591367e-6;\n    // / Earth J5 effect coefficient _(unitless)_.\n    static j5 = -2.27296082868698e-7;\n    // / Earth J6 effect coefficient _(unitless)_.\n    static j6 = 5.40681239107085e-7;\n    // / Earth rotation vector _(rad/s)_.\n    static rotation = new Vector3D(0, 0, 7.292115146706979e-5);\n    // / Calculate mean motion _(rad/s)_ from a given [semimajorAxis] _(km)_.\n    static smaToMeanMotion(semimajorAxis) {\n        return Math.sqrt(Earth.mu / (semimajorAxis * semimajorAxis * semimajorAxis));\n    }\n    /**\n     * Converts revolutions per day to semi-major axis.\n     * @param rpd - The number of revolutions per day.\n     * @returns The semi-major axis value.\n     */\n    static revsPerDayToSma(rpd) {\n        return Earth.mu ** (1 / 3) / ((TAU * rpd) / secondsPerDay) ** (2 / 3);\n    }\n    // / Calculate Earth [PrecessionAngles] at a given UTC [epoch].\n    static precession(epoch) {\n        const t = epoch.toTT().toJulianCenturies();\n        const zeta = evalPoly(t, Earth.zetaPoly_);\n        const theta = evalPoly(t, Earth.thetaPoly_);\n        const zed = evalPoly(t, Earth.zedPoly_);\n        return { zeta: zeta, theta: theta, zed: zed };\n    }\n    // / Calculate Earth [NutationAngles] for a given UTC [epoch].\n    static nutation(epoch) {\n        const t = epoch.toTT().toJulianCenturies();\n        const moonAnom = evalPoly(t, Earth.moonAnomPoly_);\n        const sunAnom = evalPoly(t, Earth.sunAnomPoly_);\n        const moonLat = evalPoly(t, Earth.moonLatPoly_);\n        const sunElong = evalPoly(t, Earth.sunElongPoly_);\n        const moonRaan = evalPoly(t, Earth.moonRaanPoly_);\n        let deltaPsi = 0.0;\n        let deltaEpsilon = 0.0;\n        const dh = DataHandler.getInstance();\n        for (let i = 0; i < 4; i++) {\n            const [a1, a2, a3, a4, a5, ai, bi, ci, di] = dh.getIau1980Coeffs(i);\n            const arg = a1 * moonAnom + a2 * sunAnom + a3 * moonLat + a4 * sunElong + a5 * moonRaan;\n            const sinC = ai + bi * t;\n            const cosC = ci + di * t;\n            deltaPsi += sinC * Math.sin(arg);\n            deltaEpsilon += cosC * Math.cos(arg);\n        }\n        deltaPsi *= ttasec2rad;\n        deltaEpsilon *= ttasec2rad;\n        const meanEpsilon = evalPoly(t, Earth.meanEpsilonPoly_);\n        const epsilon = meanEpsilon + deltaEpsilon;\n        const eqEq = deltaPsi * Math.cos(meanEpsilon) +\n            0.00264 * asec2rad * Math.sin(moonRaan) +\n            0.000063 * asec2rad * Math.sin(2.0 * moonRaan);\n        const gast = epoch.gmstAngle() + eqEq;\n        return {\n            dPsi: deltaPsi,\n            dEps: deltaEpsilon,\n            mEps: meanEpsilon,\n            eps: epsilon,\n            eqEq: eqEq,\n            gast: gast,\n        };\n    }\n    // / Convert a [semimajorAxis] _(km)_ to an eastward drift rate _(rad/day)_.\n    static smaToDrift(semimajorAxis) {\n        const t = (TAU * Math.sqrt(semimajorAxis ** 3 / Earth.mu)) / secondsPerSiderealDay;\n        return (1.0 - t) * TAU;\n    }\n    // / Convert a [semimajorAxis] _(km)_ to an eastward drift rate _(Â°/day)_.\n    static smaToDriftDegrees(semimajorAxis) {\n        return Earth.smaToDrift(semimajorAxis) * RAD2DEG;\n    }\n    // / Convert an eastward [driftRate] _(rad/day)_ to a semimajor-axis _(km)_.\n    static driftToSemimajorAxis(driftRate) {\n        const t = (-driftRate / TAU + 1) * secondsPerSiderealDay;\n        return ((Earth.mu * t * t) / (4 * Math.PI * Math.PI)) ** (1 / 3);\n    }\n    // / Convert an eastward [driftRate] _(Â°/day)_ to a semimajor-axis _(km)_.\n    static driftDegreesToSma(driftRate) {\n        return Earth.driftToSemimajorAxis(DEG2RAD * driftRate);\n    }\n    /**\n     * Calculates the diameter of the Earth based on the satellite position.\n     * @param satPos The position of the satellite.\n     * @returns The diameter of the Earth.\n     */\n    static diameter(satPos) {\n        return angularDiameter(Earth.radiusEquator * 2, satPos.magnitude(), AngularDiameterMethod.Sphere);\n    }\n    // / Earth precession `zeta` polynomial coefficients.\n    static zetaPoly_ = Float64Array.from([\n        0.017998 * asec2rad,\n        0.30188 * asec2rad,\n        2306.2181 * asec2rad,\n        0.0,\n    ]);\n    // / Earth precession `theta` polynomial coefficients.\n    static thetaPoly_ = Float64Array.from([\n        -0.041833 * asec2rad,\n        -0.42665 * asec2rad,\n        2004.3109 * asec2rad,\n        0.0,\n    ]);\n    // / Earth precession `zed` polynomial coefficients.\n    static zedPoly_ = Float64Array.from([\n        0.018203 * asec2rad,\n        1.09468 * asec2rad,\n        2306.2181 * asec2rad,\n        0,\n    ]);\n    static moonAnomPoly_ = Float64Array.from([\n        1.4343e-5 * DEG2RAD,\n        0.0088553 * DEG2RAD,\n        (1325.0 * 360.0 + 198.8675605) * DEG2RAD,\n        134.96340251 * DEG2RAD,\n    ]);\n    // / Earth nutation Sun anomaly polynomial coefficients.\n    static sunAnomPoly_ = Float64Array.from([\n        3.8e-8 * DEG2RAD,\n        -0.0001537 * DEG2RAD,\n        (99.0 * 360.0 + 359.0502911) * DEG2RAD,\n        357.52910918 * DEG2RAD,\n    ]);\n    // / Earth nutation Moon latitude polynomial coefficients.\n    static moonLatPoly_ = Float64Array.from([\n        -2.88e-7 * DEG2RAD,\n        -0.003542 * DEG2RAD,\n        (1342.0 * 360.0 + 82.0174577) * DEG2RAD,\n        93.27209062 * DEG2RAD,\n    ]);\n    // / Earth nutation Sun elongation polynomial coefficients.\n    static sunElongPoly_ = Float64Array.from([\n        1.831e-6 * DEG2RAD,\n        -0.0017696 * DEG2RAD,\n        (1236.0 * 360.0 + 307.1114469) * DEG2RAD,\n        297.85019547 * DEG2RAD,\n    ]);\n    // / Earth nutation Moon right-ascension polynomial coefficients.\n    static moonRaanPoly_ = Float64Array.from([\n        2.139e-6 * DEG2RAD,\n        0.0020756 * DEG2RAD,\n        -(5.0 * 360.0 + 134.1361851) * DEG2RAD,\n        125.04455501 * DEG2RAD,\n    ]);\n    // / Earth nutation mean epsilon polynomial coefficients.\n    static meanEpsilonPoly_ = Float64Array.from([\n        0.001813 * asec2rad,\n        -0.00059 * asec2rad,\n        -46.815 * asec2rad,\n        84381.448 * asec2rad,\n    ]);\n}\n","/**\n * @author Theodore Kruczek.\n * @license MIT\n * @copyright (c) 2022-2025 Theodore Kruczek Permission is\n * hereby granted, free of charge, to any person obtaining a copy of this\n * software and associated documentation files (the \"Software\"), to deal in the\n * Software without restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do\n * so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n * @copyright (c) 2011-2015, Vladimir Agafonkin\n * @copyright (c) 2022 Robert Gester https://github.com/hypnos3/suncalc3\n * @see suncalc.LICENSE.md\n * Some of the math in this file was originally created by Vladimir Agafonkin.\n * Robert Gester's update was referenced for documentation. There were a couple\n * of bugs in both versions so there will be some differences if you are\n * migrating from either to this library.\n *\n * suncalc is a JavaScript library for calculating sun/moon position and light\n * phases. https://github.com/mourner/suncalc\n * It was reworked and enhanced by Robert Gester.\n *\n * The original suncalc is released under the terms of the BSD 2-Clause License.\n * @see http://aa.quae.nl/en/reken/hemelpositie.html\n * moon calculations are based on formulas from this website\n */\nimport { AngularDiameterMethod, Celestial } from '../main.js';\nimport { Vector3D } from '../operations/Vector3D.js';\nimport { EpochUTC } from '../time/EpochUTC.js';\nimport { DEG2RAD, MS_PER_DAY } from '../utils/constants.js';\nimport { angularDiameter } from '../utils/functions.js';\nimport { Earth } from './Earth.js';\nimport { Sun } from './Sun.js';\n// / Moon metrics and operations.\nexport class Moon {\n    constructor() {\n        // disable constructor\n    }\n    // / Moon gravitational parameter _(kmÂ³/sÂ²)_.\n    static mu = 4902.799;\n    // / Moon equatorial radius _(km)_.\n    static radiusEquator = 1738.0;\n    // / Calculate the Moon's ECI position _(km)_ for a given UTC [epoch].\n    static eci(epoch = EpochUTC.fromDateTime(new Date())) {\n        const jc = epoch.toJulianCenturies();\n        const dtr = DEG2RAD;\n        const lamEcl = 218.32 +\n            481267.8813 * jc +\n            6.29 * Math.sin((134.9 + 477198.85 * jc) * dtr) -\n            1.27 * Math.sin((259.2 - 413335.38 * jc) * dtr) +\n            0.66 * Math.sin((235.7 + 890534.23 * jc) * dtr) +\n            0.21 * Math.sin((269.9 + 954397.7 * jc) * dtr) -\n            0.19 * Math.sin((357.5 + 35999.05 * jc) * dtr) -\n            0.11 * Math.sin((186.6 + 966404.05 * jc) * dtr);\n        const phiEcl = 5.13 * Math.sin((93.3 + 483202.03 * jc) * dtr) +\n            0.28 * Math.sin((228.2 + 960400.87 * jc) * dtr) -\n            0.28 * Math.sin((318.3 + 6003.18 * jc) * dtr) -\n            0.17 * Math.sin((217.6 - 407332.2 * jc) * dtr);\n        const pllx = 0.9508 +\n            0.0518 * Math.cos((134.9 + 477198.85 * jc) * dtr) +\n            0.0095 * Math.cos((259.2 - 413335.38 * jc) * dtr) +\n            0.0078 * Math.cos((235.7 + 890534.23 * jc) * dtr) +\n            0.0028 * Math.cos((269.9 + 954397.7 * jc) * dtr);\n        const obq = 23.439291 - 0.0130042 * jc;\n        const rMag = 1 / Math.sin(pllx * dtr);\n        const r = new Vector3D(rMag * Math.cos(phiEcl * dtr) * Math.cos(lamEcl * dtr), rMag *\n            (Math.cos(obq * dtr) * Math.cos(phiEcl * dtr) * Math.sin(lamEcl * dtr) -\n                Math.sin(obq * dtr) * Math.sin(phiEcl * dtr)), rMag *\n            (Math.sin(obq * dtr) * Math.cos(phiEcl * dtr) * Math.sin(lamEcl * dtr) +\n                Math.cos(obq * dtr) * Math.sin(phiEcl * dtr)));\n        const rMOD = r.scale(Earth.radiusEquator);\n        const p = Earth.precession(epoch);\n        return rMOD\n            .rotZ(p.zed)\n            .rotY(-p.theta)\n            .rotZ(p.zeta);\n    }\n    /**\n     * Calculates the illumination of the Moon at a given epoch.\n     * @param epoch - The epoch in UTC.\n     * @param origin - The origin vector. Defaults to the origin vector if not provided.\n     * @returns The illumination of the Moon, ranging from 0 to 1.\n     */\n    static illumination(epoch, origin) {\n        const orig = origin ?? Vector3D.origin;\n        const sunPos = Sun.position(epoch).subtract(orig);\n        const moonPos = this.eci(epoch).subtract(orig);\n        const phaseAngle = sunPos.angle(moonPos);\n        return 0.5 * (1 - Math.cos(phaseAngle));\n    }\n    /**\n     * Calculates the diameter of the Moon.\n     * @param obsPos - The position of the observer.\n     * @param moonPos - The position of the Moon.\n     * @returns The diameter of the Moon.\n     */\n    static diameter(obsPos, moonPos) {\n        return angularDiameter(this.radiusEquator * 2, obsPos.subtract(moonPos).magnitude(), AngularDiameterMethod.Sphere);\n    }\n    /**\n     * calculations for illumination parameters of the moon, based on\n     * http://idlastro.gsfc.nasa.gov/ftp/pro/astro/mphase.pro formulas and Chapter 48 of \"Astronomical Algorithms\" 2nd\n     * edition by Jean Meeus (Willmann-Bell, Richmond) 1998.\n     * @param date Date object or timestamp for calculating moon-illumination\n     * @returns result object of moon-illumination\n     */\n    // eslint-disable-next-line max-statements\n    static getMoonIllumination(date) {\n        const dateValue = date instanceof Date ? date.getTime() : date;\n        const lunarDaysMs = 2551442778; // The duration in days of a lunar cycle is 29.53058770576 days.\n        const firstNewMoon2000 = 947178840000; // first newMoon in the year 2000 2000-01-06 18:14\n        const dateObj = new Date(dateValue);\n        const d = Sun.date2jSince2000(dateObj);\n        const s = Sun.raDec(dateObj);\n        const m = Moon.moonCoords(d);\n        const sdist = 149598000; // distance from Earth to Sun in km\n        const phi = Math.acos(Math.sin(s.dec) * Math.sin(m.dec) + Math.cos(s.dec) * Math.cos(m.dec) * Math.cos(s.ra - m.ra));\n        const inc = Math.atan2(sdist * Math.sin(phi), m.dist - sdist * Math.cos(phi));\n        const angle = Math.atan2(Math.cos(s.dec) * Math.sin(s.ra - m.ra), Math.sin(s.dec) * Math.cos(m.dec) - Math.cos(s.dec) * Math.sin(m.dec) * Math.cos(s.ra - m.ra));\n        const phaseValue = 0.5 + (0.5 * inc * (angle < 0 ? -1 : 1)) / Math.PI;\n        /*\n         * calculates the difference in ms between the sirst fullMoon 2000 and given\n         * Date\n         */\n        const diffBase = dateValue - firstNewMoon2000;\n        // Calculate modulus to drop completed cycles\n        let cycleModMs = diffBase % lunarDaysMs;\n        // If negative number (date before new moon 2000) add lunarDaysMs\n        if (cycleModMs < 0) {\n            cycleModMs += lunarDaysMs;\n        }\n        const nextNewMoon = lunarDaysMs - cycleModMs + dateValue;\n        let nextFullMoon = lunarDaysMs / 2 - cycleModMs + dateValue;\n        if (nextFullMoon < dateValue) {\n            nextFullMoon += lunarDaysMs;\n        }\n        const quater = lunarDaysMs / 4;\n        let nextFirstQuarter = quater - cycleModMs + dateValue;\n        if (nextFirstQuarter < dateValue) {\n            nextFirstQuarter += lunarDaysMs;\n        }\n        let nextThirdQuarter = lunarDaysMs - quater - cycleModMs + dateValue;\n        if (nextThirdQuarter < dateValue) {\n            nextThirdQuarter += lunarDaysMs;\n        }\n        /*\n         * Calculate the fraction of the moon cycle const currentfrac = cycleModMs /\n         * lunarDaysMs;\n         */\n        const next = Math.min(nextNewMoon, nextFirstQuarter, nextFullMoon, nextThirdQuarter);\n        // eslint-disable-next-line init-declarations\n        let phase = null;\n        for (const moonCycle of Moon.moonCycles_) {\n            if (phaseValue >= moonCycle.from && phaseValue <= moonCycle.to) {\n                phase = moonCycle;\n                break;\n            }\n        }\n        if (!phase) {\n            throw new Error('Moon phase not found');\n        }\n        let type = '';\n        if (next === nextNewMoon) {\n            type = 'newMoon';\n        }\n        else if (next === nextFirstQuarter) {\n            type = 'firstQuarter';\n        }\n        else if (next === nextFullMoon) {\n            type = 'fullMoon';\n        }\n        else {\n            type = 'thirdQuarter';\n        }\n        return {\n            fraction: (1 + Math.cos(inc)) / 2,\n            phase,\n            phaseValue,\n            angle,\n            next: {\n                value: next,\n                date: new Date(next).toISOString(),\n                type,\n                newMoon: {\n                    value: nextNewMoon,\n                    date: new Date(nextNewMoon).toISOString(),\n                },\n                fullMoon: {\n                    value: nextFullMoon,\n                    date: new Date(nextFullMoon).toISOString(),\n                },\n                firstQuarter: {\n                    value: nextFirstQuarter,\n                    date: new Date(nextFirstQuarter).toISOString(),\n                },\n                thirdQuarter: {\n                    value: nextThirdQuarter,\n                    date: new Date(nextThirdQuarter).toISOString(),\n                },\n            },\n        };\n    }\n    static rae(date, lat, lon) {\n        const lw = (DEG2RAD * -lon);\n        const phi = (DEG2RAD * lat);\n        const d = Sun.date2jSince2000(date);\n        const c = Moon.moonCoords(d);\n        const H = Sun.siderealTime(d, lw) - c.ra;\n        let h = Celestial.elevation(H, phi, c.dec);\n        /*\n         * formula 14.1 of \"Astronomical Algorithms\" 2nd edition by Jean Meeus\n         * (Willmann-Bell, Richmond) 1998.\n         */\n        const pa = Math.atan2(Math.sin(H), Math.tan(phi) * Math.cos(c.dec) - Math.sin(c.dec) * Math.cos(H));\n        h = (h + Celestial.atmosphericRefraction(h)); // altitude correction for refraction\n        return {\n            az: Celestial.azimuth(H, phi, c.dec),\n            el: h,\n            rng: c.dist,\n            parallacticAngle: pa,\n        };\n    }\n    /**\n     * calculations for moon rise/set times are based on http://www.stargazing.net/kepler/moonrise.html article\n     * @param date Date object or timestamp for calculating moon rise/set\n     * @param lat Latitude of observer in degrees\n     * @param lon Longitude of observer in degrees\n     * @param isUtc If true, date will be interpreted as UTC\n     * @returns result object of moon rise/set\n     */\n    static getMoonTimes(date, lat, lon, isUtc = false) {\n        // Clone the date so we don't change the original\n        const date_ = new Date(date);\n        if (isUtc) {\n            date_.setUTCHours(0, 0, 0, 0);\n        }\n        else {\n            date_.setHours(0, 0, 0, 0);\n        }\n        const { rise, set, ye } = Moon.calculateRiseSetTimes_(date_, lat, lon);\n        const result = {\n            rise: null,\n            set: null,\n            ye: null,\n            alwaysUp: null,\n            alwaysDown: null,\n            highest: null,\n        };\n        if (rise) {\n            result.rise = new Date(Moon.hoursLater_(date_, rise));\n        }\n        if (set) {\n            result.set = new Date(Moon.hoursLater_(date_, set));\n        }\n        if (!rise && !set) {\n            if (ye > 0) {\n                result.alwaysUp = true;\n                result.alwaysDown = false;\n            }\n            else {\n                result.alwaysUp = false;\n                result.alwaysDown = true;\n            }\n        }\n        else if (rise && set) {\n            result.alwaysUp = false;\n            result.alwaysDown = false;\n            result.highest = new Date(Moon.hoursLater_(date_, Math.min(rise, set) + Math.abs(set - rise) / 2));\n        }\n        else {\n            result.alwaysUp = false;\n            result.alwaysDown = false;\n        }\n        return result;\n    }\n    static hoursLater_(date, h) {\n        return new Date(date.getTime() + (h * MS_PER_DAY) / 24);\n    }\n    /**\n     * Calculates the geocentric ecliptic coordinates of the moon.\n     * @param d - The number of days since year 2000.\n     * @returns An object containing the right ascension, declination, and\n     * distance to the moon.\n     */\n    static moonCoords(d) {\n        const L = DEG2RAD * (218.316 + 13.176396 * d); // ecliptic longitude\n        const M = DEG2RAD * (134.963 + 13.064993 * d); // mean anomaly\n        const F = DEG2RAD * (93.272 + 13.22935 * d); // mean distance\n        const l = L + DEG2RAD * 6.289 * Math.sin(M); // longitude\n        const b = DEG2RAD * 5.128 * Math.sin(F); // latitude\n        const dt = 385001 - 20905 * Math.cos(M); // distance to the moon in km\n        return {\n            ra: Celestial.rightAscension(l, b),\n            dec: Celestial.declination(l, b),\n            dist: dt,\n        };\n    }\n    static calculateRiseSetTimes_(t, lat, lon) {\n        const hc = 0.133 * DEG2RAD;\n        let h0 = Moon.rae(t, lat, lon).el - hc;\n        let h1 = 0;\n        let h2 = 0;\n        let rise = 0;\n        let set = 0;\n        let a = 0;\n        let b = 0;\n        let xe = 0;\n        let ye = 0;\n        let d = 0;\n        let roots = 0;\n        let x1 = 0;\n        let x2 = 0;\n        let dx = 0;\n        /*\n         * go in 2-hour chunks, each time seeing if a 3-point quadratic curve\n         * crosses zero (which means rise or set)\n         */\n        for (let i = 1; i <= 24; i += 2) {\n            h1 = Moon.rae(Moon.hoursLater_(t, i), lat, lon).el - hc;\n            h2 = Moon.rae(Moon.hoursLater_(t, i + 1), lat, lon).el - hc;\n            a = (h0 + h2) / 2 - h1;\n            b = (h2 - h0) / 2;\n            xe = -b / (2 * a);\n            ye = (a * xe + b) * xe + h1;\n            d = b * b - 4 * a * h1;\n            roots = 0;\n            if (d >= 0) {\n                dx = Math.sqrt(d) / (Math.abs(a) * 2);\n                x1 = xe - dx;\n                x2 = xe + dx;\n                if (Math.abs(x1) <= 1) {\n                    roots++;\n                }\n                if (Math.abs(x2) <= 1) {\n                    roots++;\n                }\n                if (x1 < -1) {\n                    x1 = x2;\n                }\n            }\n            if (roots === 1) {\n                if (h0 < 0) {\n                    rise = i + x1;\n                }\n                else {\n                    set = i + x1;\n                }\n            }\n            else if (roots === 2) {\n                rise = i + (ye < 0 ? x2 : x1);\n                set = i + (ye < 0 ? x1 : x2);\n            }\n            if (rise && set) {\n                break;\n            }\n            h0 = h2;\n        }\n        return { rise, set, ye };\n    }\n    static moonCycles_ = [\n        {\n            from: 0,\n            to: 0.033863193308711,\n            id: 'newMoon',\n            emoji: 'ðŸŒš',\n            code: ':new_moon_with_face:',\n            name: 'New Moon',\n            weight: 1,\n            css: 'wi-moon-new',\n        },\n        {\n            from: 0.033863193308711,\n            to: 0.216136806691289,\n            id: 'waxingCrescentMoon',\n            emoji: 'ðŸŒ’',\n            code: ':waxing_crescent_moon:',\n            name: 'Waxing Crescent',\n            weight: 6.3825,\n            css: 'wi-moon-wax-cres',\n        },\n        {\n            from: 0.216136806691289,\n            to: 0.283863193308711,\n            id: 'firstQuarterMoon',\n            emoji: 'ðŸŒ“',\n            code: ':first_quarter_moon:',\n            name: 'First Quarter',\n            weight: 1,\n            css: 'wi-moon-first-quart',\n        },\n        {\n            from: 0.283863193308711,\n            to: 0.466136806691289,\n            id: 'waxingGibbousMoon',\n            emoji: 'ðŸŒ”',\n            code: ':waxing_gibbous_moon:',\n            name: 'Waxing Gibbous',\n            weight: 6.3825,\n            css: 'wi-moon-wax-gibb',\n        },\n        {\n            from: 0.466136806691289,\n            to: 0.533863193308711,\n            id: 'fullMoon',\n            emoji: 'ðŸŒ',\n            code: ':full_moon_with_face:',\n            name: 'Full Moon',\n            weight: 1,\n            css: 'wi-moon-full',\n        },\n        {\n            from: 0.533863193308711,\n            to: 0.716136806691289,\n            id: 'waningGibbousMoon',\n            emoji: 'ðŸŒ–',\n            code: ':waning_gibbous_moon:',\n            name: 'Waning Gibbous',\n            weight: 6.3825,\n            css: 'wi-moon-wan-gibb',\n        },\n        {\n            from: 0.716136806691289,\n            to: 0.783863193308711,\n            id: 'thirdQuarterMoon',\n            emoji: 'ðŸŒ—',\n            code: ':last_quarter_moon:',\n            name: 'third Quarter',\n            weight: 1,\n            css: 'wi-moon-third-quart',\n        },\n        {\n            from: 0.783863193308711,\n            to: 0.966136806691289,\n            id: 'waningCrescentMoon',\n            emoji: 'ðŸŒ˜',\n            code: ':waning_crescent_moon:',\n            name: 'Waning Crescent',\n            weight: 6.3825,\n            css: 'wi-moon-wan-cres',\n        },\n        {\n            from: 0.966136806691289,\n            to: 1,\n            id: 'newMoon',\n            emoji: 'ðŸŒš',\n            code: ':new_moon_with_face:',\n            name: 'New Moon',\n            weight: 1,\n            css: 'wi-moon-new',\n        },\n    ];\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n * @copyright (c) 2011-2015, Vladimir Agafonkin\n * @copyright (c) 2022 Robert Gester https://github.com/hypnos3/suncalc3\n * @see suncalc.LICENSE.md\n * Some of the math in this file was originally created by Vladimir Agafonkin.\n * Robert Gester's update was referenced for documentation. There were a couple\n * of bugs in both versions so there will be some differences if you are\n * migrating from either to this library.\n *\n * suncalc is a JavaScript library for calculating sun/moon position and light\n * phases. https://github.com/mourner/suncalc\n * It was reworked and enhanced by Robert Gester.\n *\n * The original suncalc is released under the terms of the BSD 2-Clause License.\n */\nimport { angularDiameter, AngularDiameterMethod, astronomicalUnit, Celestial, cKmPerSec, DEG2RAD, Earth, MS_PER_DAY, RAD2DEG, TAU, Vector3D, } from '../main.js';\n/**\n * Sun metrics and operations.\n */\nexport class Sun {\n    static J0_ = 0.0009;\n    static J1970_ = 2440587.5;\n    static J2000_ = 2451545;\n    static e = DEG2RAD * 23.4397;\n    /**\n     * Array representing the times for different phases of the sun. Each element\n     * in the array contains:\n     * - The angle in degrees representing the time offset from solar noon.\n     * - The name of the start time for the phase.\n     * - The name of the end time for the phase.\n     */\n    static times_ = [\n        [6, 'goldenHourDawnEnd', 'goldenHourDuskStart'], // GOLDEN_HOUR_2\n        [-0.3, 'sunriseEnd', 'sunsetStart'], // SUNRISE_END\n        [-0.833, 'sunriseStart', 'sunsetEnd'], // SUNRISE\n        [-1, 'goldenHourDawnStart', 'goldenHourDuskEnd'], // GOLDEN_HOUR_1\n        [-4, 'blueHourDawnEnd', 'blueHourDuskStart'], // BLUE_HOUR\n        [-6, 'civilDawn', 'civilDusk'], // DAWN\n        [-8, 'blueHourDawnStart', 'blueHourDuskEnd'], // BLUE_HOUR\n        [-12, 'nauticalDawn', 'nauticalDusk'], // NAUTIC_DAWN\n        [-15, 'amateurDawn', 'amateurDusk'],\n        [-18, 'astronomicalDawn', 'astronomicalDusk'], // ASTRO_DAWN\n    ];\n    /**\n     * Gravitational parameter of the Sun. (kmÂ³/sÂ²)\n     */\n    static mu = 1.32712428e11;\n    /**\n     * The angle of the penumbra of the Sun, in radians.\n     */\n    static penumbraAngle = (0.26900424 * DEG2RAD);\n    /**\n     * The radius of the Sun in kilometers.\n     */\n    static radius = 695500.0;\n    /**\n     * The mean solar flux of the Sun. (W/mÂ²)\n     */\n    static solarFlux = 1367.0;\n    /**\n     * The solar pressure exerted by the Sun. (N/mÂ²) It is calculated as the solar\n     * flux divided by the speed of light.\n     */\n    static solarPressure = Sun.solarFlux / (cKmPerSec * 1000);\n    /**\n     * The angle of the umbra, in radians.\n     */\n    static umbraAngle = (0.26411888 * DEG2RAD);\n    constructor() {\n        // disable constructor\n    }\n    /**\n     * Calculates the azimuth and elevation of the Sun for a given date, latitude,\n     * and longitude.\n     * @param date - The date for which to calculate the azimuth and elevation.\n     * @param lat - The latitude in degrees.\n     * @param lon - The longitude in degrees.\n     * @param c - The right ascension and declination of the target. Defaults to\n     * the Sun's right ascension and declination\n     * @returns An object containing the azimuth and elevation of the Sun in\n     * radians.\n     */\n    static azEl(date, lat, lon, c) {\n        const lw = (-lon * DEG2RAD);\n        const phi = (lat * DEG2RAD);\n        const d = Sun.date2jSince2000(date);\n        c ??= Sun.raDec(date);\n        const H = Sun.siderealTime(d, lw) - c.ra;\n        return {\n            az: Celestial.azimuth(H, phi, c.dec),\n            el: Celestial.elevation(H, phi, c.dec),\n        };\n    }\n    /**\n     * get number of days for a dateValue since 2000\n     * See: https://en.wikipedia.org/wiki/Epoch_(astronomy)\n     * @param date date as timestamp to get days\n     * @returns count of days\n     */\n    static date2jSince2000(date) {\n        return date.getTime() / MS_PER_DAY + Sun.J1970_ - Sun.J2000_;\n    }\n    /**\n     * Calculates the angular diameter of the Sun given the observer's position\n     * and the Sun's position.\n     * @param obsPos The observer's position in kilometers.\n     * @param sunPos The Sun's position in kilometers.\n     * @returns The angular diameter of the Sun in radians.\n     */\n    static diameter(obsPos, sunPos) {\n        return angularDiameter(this.radius * 2, obsPos.subtract(sunPos).magnitude(), AngularDiameterMethod.Sphere);\n    }\n    /**\n     * Calculate eclipse angles given a satellite ECI position and Sun ECI\n     * position.\n     * @param satPos the satellite position\n     * @param sunPos the sun position\n     * @returns [central body angle, central body apparent radius, sun apparent]\n     */\n    static eclipseAngles(satPos, sunPos) {\n        const satSun = sunPos.subtract(satPos);\n        const r = satPos.magnitude();\n        return [\n            // central body angle\n            satSun.angle(satPos.negate()),\n            // central body apparent radius\n            Math.asin(Earth.radiusEquator / r),\n            // sun apparent radius\n            Math.asin(this.radius / satSun.magnitude()),\n        ];\n    }\n    /**\n     * Ecliptic latitude measures the distance north or south of the ecliptic,\n     * attaining +90Â° at the north ecliptic pole (NEP) and -90Â° at the south\n     * ecliptic pole (SEP). The ecliptic itself is 0Â° latitude.\n     * @param B - ?\n     * @returns ecliptic latitude\n     */\n    static eclipticLatitude(B) {\n        const C = TAU / 360;\n        const L = B - 0.00569 - 0.00478 * Math.sin(C * B);\n        return TAU * (L + 0.0003 * Math.sin(C * 2 * L));\n    }\n    /**\n     * Ecliptic longitude, also known as celestial longitude, measures the angular\n     * distance of an object along the ecliptic from the primary direction. It is\n     * measured positive eastwards in the fundamental plane (the ecliptic) from 0Â°\n     * to 360Â°. The primary direction (0Â° ecliptic longitude) points from the\n     * Earth towards the Sun at the vernal equinox of the Northern Hemisphere. Due\n     * to axial precession, the ecliptic longitude of most \"fixed stars\" increases\n     * by about 50.3 arcseconds per year, or 83.8 arcminutes per century.\n     * @param M - solar mean anomaly\n     * @returns ecliptic longitude\n     */\n    static eclipticLongitude(M) {\n        const C = DEG2RAD * (1.9148 * Math.sin(M) + 0.02 * Math.sin(2 * M) + 0.0003 * Math.sin(3 * M));\n        const P = DEG2RAD * 102.9372; // perihelion of Earth\n        return (M + C + P + Math.PI); // Sun's mean longitude\n    }\n    /**\n     * returns set time for the given sun altitude\n     * @param h - height at 0\n     * @param lw - rad * -lng\n     * @param phi -  rad * lat;\n     * @param dec - declination\n     * @param n - Julian cycle\n     * @param M - solar mean anomal\n     * @param L - ecliptic longitude\n     * @returns set time\n     */\n    static getSetJulian(h, lw, phi, dec, n, M, L) {\n        const w = Sun.hourAngle(h, phi, dec);\n        const a = Sun.approxTransit_(w, lw, n);\n        return Sun.solarTransitJulian(a, M, L);\n    }\n    /**\n     * Calculates the time of the sun based on the given azimuth.\n     * @param dateValue - The date value or Date object.\n     * @param lat - The latitude in degrees.\n     * @param lon - The longitude in degrees.\n     * @param az - The azimuth in radians or degrees.\n     * @param isDegrees - Indicates if the azimuth is in degrees. Default is false.\n     * @returns The calculated time of the sun.\n     * @throws Error if the azimuth, latitude, or longitude is missing.\n     */\n    static getSunTimeByAz(dateValue, lat, lon, az, isDegrees = false) {\n        if (isNaN(az)) {\n            throw new Error('azimuth missing');\n        }\n        if (isNaN(lat)) {\n            throw new Error('latitude missing');\n        }\n        if (isNaN(lon)) {\n            throw new Error('longitude missing');\n        }\n        if (isDegrees) {\n            az = (az * DEG2RAD);\n        }\n        const date = dateValue instanceof Date ? dateValue : new Date(dateValue);\n        const lw = (DEG2RAD * -lon);\n        const phi = (DEG2RAD * lat);\n        let dateVal = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0).getTime();\n        let addval = MS_PER_DAY; // / 2);\n        dateVal += addval;\n        while (addval > 200) {\n            const newDate = new Date(dateVal);\n            const d = Sun.date2jSince2000(newDate);\n            const c = Sun.raDec(newDate);\n            const H = Sun.siderealTime(d, lw) - c.ra;\n            const newAz = Celestial.azimuth(H, phi, c.dec);\n            addval /= 2;\n            if (newAz < az) {\n                dateVal += addval;\n            }\n            else {\n                dateVal -= addval;\n            }\n        }\n        return new Date(Math.floor(dateVal));\n    }\n    /**\n     * Calculates sun times for a given date and latitude/longitude\n     *\n     * Default altitude is 0 meters. If `isUtc` is `true`, the times are returned\n     * as UTC, otherwise in local time.\n     * @param dateVal - The date value or Date object.\n     * @param lat - The latitude in degrees.\n     * @param lon - The longitude in degrees.\n     * @param alt - The altitude in meters. Default is 0.\n     * @param isUtc - Indicates if the times should be returned as UTC. Default is\n     * false.\n     * @returns An object containing the times of the sun.\n     */\n    static getTimes(dateVal, lat, lon, alt = 0, isUtc = false) {\n        if (isNaN(lat)) {\n            throw new Error('latitude missing');\n        }\n        if (isNaN(lon)) {\n            throw new Error('longitude missing');\n        }\n        // Ensure date is a Date object\n        const date = dateVal instanceof Date ? dateVal : new Date(dateVal);\n        if (isUtc) {\n            date.setUTCHours(12, 0, 0, 0);\n        }\n        else {\n            date.setHours(12, 0, 0, 0);\n        }\n        let time;\n        let h0 = 0;\n        let Jset = 0;\n        let Jrise = 0;\n        const { Jnoon, dh, lw, phi, dec, n, M, L } = Sun.calculateJnoon_(lon, lat, alt, date);\n        // Determine when the sun is at its highest and lowest (darkest) points.\n        const result = {\n            solarNoon: Sun.julian2date(Jnoon),\n            nadir: Sun.julian2date(Jnoon + 0.5), // https://github.com/mourner/suncalc/pull/125\n        };\n        // Add all other unique times using Jnoon as a reference\n        for (let i = 0, len = Sun.times_.length; i < len; i += 1) {\n            time = Sun.times_[i];\n            const angle = time[0];\n            h0 = ((angle + dh) * DEG2RAD);\n            Jset = Sun.getSetJ_(h0, lw, phi, dec, n, M, L);\n            Jrise = Jnoon - (Jset - Jnoon);\n            result[time[1]] = Sun.julian2date(Jrise);\n            result[time[2]] = Sun.julian2date(Jset);\n        }\n        return result;\n    }\n    /**\n     * hour angle\n     * @param h - heigh at 0\n     * @param phi -  rad * lat;\n     * @param dec - declination\n     * @returns hour angle\n     */\n    static hourAngle(h, phi, dec) {\n        return Math.acos((Math.sin(h) - Math.sin(phi) * Math.sin(dec)) / (Math.cos(phi) * Math.cos(dec)));\n    }\n    /**\n     * convert Julian calendar to date object\n     * @param julian day number in Julian calendar to convert\n     * @returns result date as timestamp\n     */\n    static julian2date(julian) {\n        return new Date((julian - Sun.J1970_) * MS_PER_DAY);\n    }\n    /**\n     * Julian cycle\n     *\n     * The Julian cycle is a period of 7980 years after which the positions of the\n     * Sun, Moon, and planets repeat. It is used in astronomical calculations to\n     * determine the position of celestial bodies.\n     *\n     * The Julian Period starts at noon on January 1, 4713 B.C.E. (Julian\n     * calendar) and lasts for 7980 years. This was determined because it is a\n     * time period long enough to include all of recorded history and includes\n     * some time in the future that would incorporate the three important\n     * calendrical cycles, the Golden Number Cycle, the Solar Cycle, and the Roman\n     * Indiction.\n     *\n     * The Golden Number Cycle is a cycle of 19 years, while the Solar Cycle is a\n     * cycle of 28 years and the Roman Indiction repeats every 15 years. Thus the\n     * Julian Period is calculated to be 7980 years long or 2,914,695 days because\n     * 19*28*15 = 7980.\n     * @param date - Date object for calculating julian cycle\n     * @param lon - Degrees longitude\n     * @returns julian cycle\n     */\n    static julianCycle(date, lon) {\n        const lw = (-lon * DEG2RAD);\n        const d = Sun.date2jSince2000(date);\n        return Math.round(d - Sun.J0_ - lw / ((2 * TAU) / 2));\n    }\n    /**\n     * Calculate the lighting ratio given a satellite ECI position [satPos] _(km)_\n     * and Sun ECI position [sunPos] _(km)_.\n     *\n     * Returns `1.0` if the satellite is fully illuminated and `0.0` when fully\n     * eclipsed.\n     * @param satPos - The position of the satellite.\n     * @param sunPos - The position of the sun.\n     * @returns The lighting ratio.\n     */\n    static lightingRatio(satPos, sunPos) {\n        const [sunSatAngle, aCent, aSun] = Sun.eclipseAngles(satPos, sunPos);\n        if (sunSatAngle - aCent + aSun <= 1e-10) {\n            return 0.0;\n        }\n        else if (sunSatAngle - aCent - aSun < -1e-10) {\n            const ssa2 = sunSatAngle * sunSatAngle;\n            const ssaInv = 1.0 / (2.0 * sunSatAngle);\n            const ac2 = aCent * aCent;\n            const as2 = aSun * aSun;\n            const acAsDiff = ac2 - as2;\n            const a1 = (ssa2 - acAsDiff) * ssaInv;\n            const a2 = (ssa2 + acAsDiff) * ssaInv;\n            const asr1 = a1 / aSun;\n            const asr2 = as2 - a1 * a1;\n            const acr1 = a2 / aCent;\n            const acr2 = ac2 - a2 * a2;\n            const p1 = as2 * Math.acos(asr1) - a1 * Math.sqrt(asr2);\n            const p2 = ac2 * Math.acos(acr1) - a2 * Math.sqrt(acr2);\n            return 1.0 - (p1 + p2) / (Math.PI * as2);\n        }\n        return 1.0;\n    }\n    /**\n     * Calculates the lighting factor based on the position of the satellite and the sun.\n     * @deprecated This method was previously used. It is now deprecated and will be removed\n     * in a future release.\n     * @param satPos The position of the satellite.\n     * @param sunPos The position of the sun.\n     * @returns The lighting factor.\n     */\n    static sunlightLegacy(satPos, sunPos) {\n        let lighting = 1.0;\n        const semiDiamEarth = Math.asin(Earth.radiusMean / Math.sqrt((-satPos.x) ** 2 + (-satPos.y) ** 2 + (-satPos.z) ** 2)) * RAD2DEG;\n        const semiDiamSun = Math.asin(Sun.radius / Math.sqrt((-satPos.x + sunPos.x) ** 2 + (-satPos.y + sunPos.y) ** 2 + (-satPos.z + sunPos.z) ** 2)) * RAD2DEG;\n        // Angle between earth and sun\n        const theta = Math.acos(satPos.negate().dot(sunPos.negate()) /\n            (Math.sqrt((-satPos.x) ** 2 + (-satPos.y) ** 2 + (-satPos.z) ** 2) *\n                Math.sqrt((-satPos.x + sunPos.x) ** 2 + (-satPos.y + sunPos.y) ** 2 + (-satPos.z + sunPos.z) ** 2))) * RAD2DEG;\n        if (semiDiamEarth > semiDiamSun && theta < semiDiamEarth - semiDiamSun) {\n            lighting = 0;\n        }\n        if (Math.abs(semiDiamEarth - semiDiamSun) < theta && theta < semiDiamEarth + semiDiamSun) {\n            lighting = 0.5;\n        }\n        if (semiDiamSun > semiDiamEarth) {\n            lighting = 0.5;\n        }\n        if (theta < semiDiamSun - semiDiamEarth) {\n            lighting = 0.5;\n        }\n        return lighting;\n    }\n    /**\n     * Calculates the position vector of the Sun at a given epoch in the\n     * Earth-centered inertial (ECI) coordinate system.\n     * @param epoch - The epoch in UTC.\n     * @returns The position vector of the Sun in Kilometers.\n     */\n    static position(epoch) {\n        const jc = epoch.toJulianCenturies();\n        const dtr = DEG2RAD;\n        const lamSun = 280.46 + 36000.77 * jc;\n        const mSun = 357.5291092 + 35999.05034 * jc;\n        const lamEc = lamSun + 1.914666471 * Math.sin(mSun * dtr) + 0.019994643 * Math.sin(2.0 * mSun * dtr);\n        const obliq = 23.439291 - 0.0130042 * jc;\n        const rMag = 1.000140612 - 0.016708617 * Math.cos(mSun * dtr) - 0.000139589 * Math.cos(2.0 * mSun * dtr);\n        const r = new Vector3D(rMag * Math.cos(lamEc * dtr), rMag * Math.cos(obliq * dtr) * Math.sin(lamEc * dtr), rMag * Math.sin(obliq * dtr) * Math.sin(lamEc * dtr));\n        const rMOD = r.scale(astronomicalUnit);\n        const p = Earth.precession(epoch);\n        return rMOD\n            .rotZ(p.zed)\n            .rotY(-p.theta)\n            .rotZ(p.zeta);\n    }\n    /**\n     * Calculate the Sun's apparent ECI position _(km)_ from Earth for a given UTC\n     * [epoch].\n     * @param epoch - The epoch in UTC.\n     * @returns The Sun's apparent ECI position in kilometers.\n     */\n    static positionApparent(epoch) {\n        const distance = Sun.position(epoch).magnitude();\n        const dSec = distance / cKmPerSec;\n        return Sun.position(epoch.roll(-dSec));\n    }\n    /**\n     * Calculates the right ascension and declination of the Sun for a given date.\n     * @param date - The date for which to calculate the right ascension and declination.\n     * @returns An object containing the declination and right ascension of the Sun.\n     */\n    static raDec(date) {\n        const d = Sun.date2jSince2000(date);\n        const M = Sun.solarMeanAnomaly_(d);\n        const L = Sun.eclipticLongitude(M);\n        return {\n            dec: Celestial.declination(L, 0),\n            ra: Celestial.rightAscension(L, 0),\n            dist: 0,\n        };\n    }\n    /**\n     * Return `true` if the ECI satellite position [posSat] is in eclipse at the\n     * given UTC [epoch].\n     * @param epoch - The epoch in UTC.\n     * @param posSat - The ECI position of the satellite in kilometers.\n     * @returns `true` if the satellite is in eclipse.\n     */\n    static shadow(epoch, posSat) {\n        const posSun = Sun.positionApparent(epoch);\n        let shadow = false;\n        if (posSun.dot(posSat) < 0) {\n            const angle = posSun.angle(posSat);\n            const r = posSat.magnitude();\n            const satHoriz = r * Math.cos(angle);\n            const satVert = r * Math.sin(angle);\n            const penVert = Earth.radiusEquator + Math.tan(this.penumbraAngle) * satHoriz;\n            if (satVert <= penVert) {\n                shadow = true;\n            }\n        }\n        return shadow;\n    }\n    /**\n     * side real time\n     * @param d - julian day\n     * @param lw - longitude of the observer\n     * @returns sidereal time\n     */\n    static siderealTime(d, lw) {\n        return DEG2RAD * (280.16 + 360.9856235 * d) - lw;\n    }\n    /**\n     * solar transit in Julian\n     * @param ds approxTransit\n     * @param M solar mean anomal\n     * @param L ecliptic longitude\n     * @returns solar transit in Julian\n     */\n    static solarTransitJulian(ds, M, L) {\n        return Sun.J2000_ + ds + 0.0053 * Math.sin(M) - 0.0069 * Math.sin(2 * L);\n    }\n    /**\n     * The approximate transit time\n     * @param Ht hourAngle\n     * @param lw rad * -lng\n     * @param n Julian cycle\n     * @returns approx transit\n     */\n    static approxTransit_(Ht, lw, n) {\n        return Sun.J0_ + (Ht + lw) / TAU + n;\n    }\n    static calculateJnoon_(lon, lat, alt, date) {\n        const lw = (DEG2RAD * -lon);\n        const phi = (DEG2RAD * lat);\n        const dh = Sun.observerAngle_(alt);\n        const d = Sun.date2jSince2000(date);\n        const n = Sun.julianCycle_(d, lw);\n        const ds = Sun.approxTransit_(0, lw, n);\n        const M = Sun.solarMeanAnomaly_(ds);\n        const L = Sun.eclipticLongitude(M);\n        const dec = Celestial.declination(L, 0);\n        const Jnoon = Sun.solarTransitJulian(ds, M, L);\n        return { Jnoon, dh, lw, phi, dec, n, M, L };\n    }\n    /**\n     * returns set time for the given sun altitude\n     * @param alt altitude at 0\n     * @param lw lng\n     * @param phi lat\n     * @param dec declination\n     * @param n Julian cycle\n     * @param M solar mean anomal\n     * @param L ecliptic longitude\n     * @returns sunset time in days since 2000\n     */\n    static getSetJ_(alt, lw, phi, dec, n, M, L) {\n        const w = Sun.hourAngle(alt, phi, dec);\n        const a = Sun.approxTransit_(w, lw, n);\n        return Sun.solarTransitJulian(a, M, L);\n    }\n    static julianCycle_(d, lw) {\n        const lonOffset = lw / TAU;\n        return Math.round(d - Sun.J0_ - lonOffset);\n    }\n    /**\n     * calculates the obderver angle\n     * @param alt the observer altitude (in meters) relative to the horizon\n     * @returns height for further calculations\n     */\n    static observerAngle_(alt) {\n        return ((-2.076 * Math.sqrt(alt)) / 60);\n    }\n    /**\n     * get solar mean anomaly\n     * @param d julian day\n     * @returns solar mean anomaly\n     */\n    static solarMeanAnomaly_(d) {\n        return DEG2RAD * (357.5291 + 0.98560028 * d);\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nexport { Celestial } from './Celestial.js';\nexport { Earth } from './Earth.js';\nexport { Moon } from './Moon.js';\nexport { Sun } from './Sun.js';\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { OrbitRegime } from '../enums/OrbitRegime.js';\nimport { Earth, } from '../main.js';\nimport { Vector3D } from '../operations/Vector3D.js';\nimport { earthGravityParam, MINUTES_PER_DAY, RAD2DEG, sec2min, TAU } from '../utils/constants.js';\nimport { clamp, matchHalfPlane, newtonNu } from '../utils/functions.js';\nimport { EquinoctialElements } from './EquinoctialElements.js';\n/**\n * The ClassicalElements class represents the classical orbital elements of an object.\n * @example\n * ```ts\n * const epoch = EpochUTC.fromDateTime(new Date('2024-01-14T14:39:39.914Z'));\n * const elements = new ClassicalElements({\n *  epoch,\n *  semimajorAxis: 6943.547853722985 as Kilometers,\n *  eccentricity: 0.0011235968124658146,\n *  inclination: 0.7509087232045765 as Radians,\n *  rightAscension: 0.028239555738616327 as Radians,\n *  argPerigee: 2.5386411901807353 as Radians,\n *  trueAnomaly: 0.5931399364974058 as Radians,\n * });\n * ```\n */\nexport class ClassicalElements {\n    epoch;\n    semimajorAxis;\n    eccentricity;\n    inclination;\n    rightAscension;\n    argPerigee;\n    trueAnomaly;\n    /** Gravitational parameter in kmÂ³/sÂ².  */\n    mu;\n    constructor({ epoch, semimajorAxis, eccentricity, inclination, rightAscension, argPerigee, trueAnomaly, mu = earthGravityParam, }) {\n        this.epoch = epoch;\n        this.semimajorAxis = semimajorAxis;\n        this.eccentricity = eccentricity;\n        this.inclination = inclination;\n        this.rightAscension = rightAscension;\n        this.argPerigee = argPerigee;\n        this.trueAnomaly = trueAnomaly;\n        this.mu = mu;\n    }\n    /**\n     * Creates a new instance of ClassicalElements from a StateVector.\n     * @param state The StateVector to convert.\n     * @param mu The gravitational parameter of the central body. Default value is Earth's gravitational parameter.\n     * @returns A new instance of ClassicalElements.\n     * @throws Error if the StateVector is not in an inertial frame.\n     */\n    static fromStateVector(state, mu = earthGravityParam) {\n        if (!state.inertial) {\n            throw new Error('State vector must be in inertial frame (like J2000).');\n        }\n        const pos = state.position;\n        const vel = state.velocity;\n        const a = state.semimajorAxis;\n        const eVecA = pos.scale(vel.magnitude() ** 2 - mu / pos.magnitude());\n        const eVecB = vel.scale(pos.dot(vel));\n        const eVec = eVecA.subtract(eVecB).scale(1 / mu);\n        const e = eVec.magnitude();\n        const h = pos.cross(vel);\n        const i = Math.acos(clamp(h.z / h.magnitude(), -1.0, 1.0));\n        const n = Vector3D.zAxis.cross(h);\n        let o = Math.acos(clamp(n.x / n.magnitude(), -1.0, 1.0));\n        if (n.y < 0) {\n            o = TAU - o;\n        }\n        let w = n.angle(eVec);\n        if (eVec.z < 0) {\n            w = TAU - w;\n        }\n        let v = eVec.angle(pos);\n        if (pos.dot(vel) < 0) {\n            v = TAU - v;\n        }\n        return new ClassicalElements({\n            epoch: state.epoch,\n            semimajorAxis: a,\n            eccentricity: e,\n            inclination: i,\n            rightAscension: o,\n            argPerigee: w,\n            trueAnomaly: v,\n            mu,\n        });\n    }\n    /**\n     * Gets the inclination in degrees.\n     * @returns The inclination in degrees.\n     */\n    get inclinationDegrees() {\n        return (this.inclination * RAD2DEG);\n    }\n    /**\n     * Gets the right ascension in degrees.\n     * @returns The right ascension in degrees.\n     */\n    get rightAscensionDegrees() {\n        return (this.rightAscension * RAD2DEG);\n    }\n    /**\n     * Gets the argument of perigee in degrees.\n     * @returns The argument of perigee in degrees.\n     */\n    get argPerigeeDegrees() {\n        return (this.argPerigee * RAD2DEG);\n    }\n    /**\n     * Gets the true anomaly in degrees.\n     * @returns The true anomaly in degrees.\n     */\n    get trueAnomalyDegrees() {\n        return (this.trueAnomaly * RAD2DEG);\n    }\n    /**\n     * Gets the apogee of the classical elements. It is measured from the surface of the earth.\n     * @returns The apogee in kilometers.\n     */\n    get apogee() {\n        return (this.semimajorAxis * (1.0 + this.eccentricity) - Earth.radiusMean);\n    }\n    /**\n     * Gets the perigee of the classical elements. The perigee is the point in an\n     * orbit that is closest to the surface of the earth.\n     * @returns The perigee distance in kilometers.\n     */\n    get perigee() {\n        return (this.semimajorAxis * (1.0 - this.eccentricity) - Earth.radiusMean);\n    }\n    toString() {\n        return [\n            '[ClassicalElements]',\n            `  Epoch: ${this.epoch}`,\n            `  Semimajor Axis (a):       ${this.semimajorAxis.toFixed(4)} km`,\n            `  Eccentricity (e):         ${this.eccentricity.toFixed(7)}`,\n            `  Inclination (i):          ${this.inclinationDegrees.toFixed(4)}Â°`,\n            `  Right Ascension (Î©):      ${this.rightAscensionDegrees.toFixed(4)}Â°`,\n            `  Argument of Perigee (Ï‰):  ${this.argPerigeeDegrees.toFixed(4)}Â°`,\n            `  True Anomaly (Î½):         ${this.trueAnomalyDegrees.toFixed(4)}Â°`,\n        ].join('\\n');\n    }\n    /**\n     * Calculates the mean motion of the celestial object.\n     * @returns The mean motion in radians.\n     */\n    get meanMotion() {\n        return Math.sqrt(this.mu / this.semimajorAxis ** 3);\n    }\n    /**\n     * Calculates the period of the orbit.\n     * @returns The period in seconds.\n     */\n    get period() {\n        const periodSec = (TAU * Math.sqrt(this.semimajorAxis ** 3 / this.mu));\n        return (periodSec / 60);\n    }\n    /**\n     * Compute the number of revolutions completed per day for this orbit.\n     * @returns The number of revolutions per day.\n     */\n    get revsPerDay() {\n        return MINUTES_PER_DAY / this.period;\n    }\n    /**\n     * Returns the orbit regime based on the classical elements.\n     * @returns The orbit regime.\n     */\n    getOrbitRegime() {\n        const n = this.revsPerDay;\n        const p = this.period * sec2min;\n        if (n >= 0.99 && n <= 1.01 && this.eccentricity < 0.01) {\n            return OrbitRegime.GEO;\n        }\n        if (p >= 600 && p <= 800 && this.eccentricity <= 0.25) {\n            return OrbitRegime.MEO;\n        }\n        if (n >= 11.25 && this.eccentricity <= 0.25) {\n            return OrbitRegime.LEO;\n        }\n        if (this.eccentricity > 0.25) {\n            return OrbitRegime.HEO;\n        }\n        return OrbitRegime.OTHER;\n    }\n    /**\n     * Converts the classical orbital elements to position and velocity vectors.\n     * @returns An object containing the position and velocity vectors.\n     */\n    toPositionVelocity() {\n        const rVec = new Vector3D(Math.cos(this.trueAnomaly), Math.sin(this.trueAnomaly), 0.0);\n        const rPQW = rVec.scale((this.semimajorAxis * (1.0 - this.eccentricity ** 2)) / (1.0 + this.eccentricity * Math.cos(this.trueAnomaly)));\n        const vVec = new Vector3D(-Math.sin(this.trueAnomaly), this.eccentricity + Math.cos(this.trueAnomaly), 0.0);\n        const vPQW = vVec.scale(Math.sqrt(this.mu / (this.semimajorAxis * (1 - this.eccentricity ** 2))));\n        const position = rPQW\n            .rotZ(-this.argPerigee)\n            .rotX(-this.inclination)\n            .rotZ(-this.rightAscension);\n        const velocity = vPQW\n            .rotZ(-this.argPerigee)\n            .rotX(-this.inclination)\n            .rotZ(-this.rightAscension);\n        return { position, velocity };\n    }\n    /**\n     * Converts the classical elements to equinoctial elements.\n     * @returns The equinoctial elements.\n     */\n    toEquinoctialElements() {\n        const I = this.inclination > Math.PI / 2 ? -1 : 1;\n        const h = this.eccentricity * Math.sin(this.argPerigee + I * this.rightAscension);\n        const k = this.eccentricity * Math.cos(this.argPerigee + I * this.rightAscension);\n        const meanAnomaly = newtonNu(this.eccentricity, this.trueAnomaly).m;\n        const lambda = (meanAnomaly + this.argPerigee + I * this.rightAscension);\n        const a = this.semimajorAxis;\n        const p = Math.tan(0.5 * this.inclination) ** I * Math.sin(this.rightAscension);\n        const q = Math.tan(0.5 * this.inclination) ** I * Math.cos(this.rightAscension);\n        return new EquinoctialElements({ epoch: this.epoch, k, h, lambda, a, p, q, mu: this.mu, I });\n    }\n    /**\n     * Propagates the classical elements to a given epoch.\n     * @param propEpoch - The epoch to propagate the classical elements to.\n     * @returns The classical elements at the propagated epoch.\n     */\n    propagate(propEpoch) {\n        const t = this.epoch;\n        const n = this.meanMotion;\n        const delta = propEpoch.difference(t);\n        const cosV = Math.cos(this.trueAnomaly);\n        let eaInit = Math.acos(clamp((this.eccentricity + cosV) / (1 + this.eccentricity * cosV), -1, 1));\n        eaInit = matchHalfPlane(eaInit, this.trueAnomaly);\n        let maInit = eaInit - this.eccentricity * Math.sin(eaInit);\n        maInit = matchHalfPlane(maInit, eaInit);\n        const maFinal = (maInit + n * delta) % TAU;\n        let eaFinal = maFinal;\n        for (let iter = 0; iter < 32; iter++) {\n            const eaTemp = maFinal + this.eccentricity * Math.sin(eaFinal);\n            if (Math.abs(eaTemp - eaFinal) < 1e-12) {\n                break;\n            }\n            eaFinal = eaTemp;\n        }\n        const cosEaFinal = Math.cos(eaFinal);\n        let vFinal = clamp(Math.acos((cosEaFinal - this.eccentricity) / (1 - this.eccentricity * cosEaFinal)), -1, 1);\n        vFinal = matchHalfPlane(vFinal, eaFinal);\n        return new ClassicalElements({\n            epoch: propEpoch,\n            semimajorAxis: this.semimajorAxis,\n            eccentricity: this.eccentricity,\n            inclination: this.inclination,\n            rightAscension: this.rightAscension,\n            argPerigee: this.argPerigee,\n            trueAnomaly: vFinal,\n            mu: this.mu,\n        });\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { earthGravityParam, MINUTES_PER_DAY, TAU } from '../utils/constants.js';\nimport { newtonM } from '../utils/functions.js';\nimport { ClassicalElements } from './ClassicalElements.js';\n/**\n * Equinoctial elements are a set of orbital elements used to describe the\n * orbits of celestial bodies, such as satellites around a planet. They provide\n * an alternative to the traditional Keplerian elements and are especially\n * useful for avoiding singularities and numerical issues in certain types of\n * orbits.\n *\n * Unlike Keplerian elements, equinoctial elements don't suffer from\n * singularities at zero eccentricity (circular orbits) or zero inclination\n * (equatorial orbits). This makes them more reliable for numerical simulations\n * and analytical studies, especially in these edge cases.\n * @see https://faculty.nps.edu/dad/orbital/th0.pdf\n */\nexport class EquinoctialElements {\n    epoch;\n    /** The semi-major axis of the orbit in kilometers. */\n    a;\n    /** The h component of the eccentricity vector. */\n    h;\n    /** The k component of the eccentricity vector. */\n    k;\n    /** The p component of the ascending node vector. */\n    p;\n    /** The q component of the ascending node vector. */\n    q;\n    /** The mean longitude of the orbit in radians. */\n    lambda;\n    /** The gravitational parameter of the central body in kmÂ³/sÂ². */\n    mu;\n    /** The retrograde factor. 1 for prograde orbits, -1 for retrograde orbits. */\n    I;\n    constructor({ epoch, h, k, lambda, a, p, q, mu, I }) {\n        this.epoch = epoch;\n        this.h = h;\n        this.k = k;\n        this.lambda = lambda;\n        this.a = a;\n        this.p = p;\n        this.q = q;\n        this.mu = mu ?? earthGravityParam;\n        this.I = I ?? 1;\n    }\n    /**\n     * Returns a string representation of the EquinoctialElements object.\n     * @returns A string representation of the EquinoctialElements object.\n     */\n    toString() {\n        return [\n            '[EquinoctialElements]',\n            `  Epoch: ${this.epoch}`,\n            `  a: ${this.a} km`,\n            `  h: ${this.h}`,\n            `  k: ${this.k}`,\n            `  p: ${this.p}`,\n            `  q: ${this.q}`,\n            `  lambda: ${this.lambda} rad`,\n        ].join('\\n');\n    }\n    /**\n     * Gets the semimajor axis.\n     * @returns The semimajor axis in kilometers.\n     */\n    get semimajorAxis() {\n        return this.a;\n    }\n    /**\n     * Gets the mean longitude.\n     * @returns The mean longitude in radians.\n     */\n    get meanLongitude() {\n        return this.lambda;\n    }\n    /**\n     * Calculates the mean motion of the celestial object.\n     * @returns The mean motion in units of radians per second.\n     */\n    get meanMotion() {\n        return Math.sqrt(this.mu / this.a ** 3);\n    }\n    /**\n     * Gets the retrograde factor.\n     * @returns The retrograde factor.\n     */\n    get retrogradeFactor() {\n        return this.I;\n    }\n    /**\n     * Checks if the orbit is prograde.\n     * @returns True if the orbit is prograde, false otherwise.\n     */\n    isPrograde() {\n        return this.I === 1;\n    }\n    /**\n     * Checks if the orbit is retrograde.\n     * @returns True if the orbit is retrograde, false otherwise.\n     */\n    isRetrograde() {\n        return this.I === -1;\n    }\n    /**\n     * Gets the period of the orbit.\n     * @returns The period in minutes.\n     */\n    get period() {\n        const periodSec = (TAU * Math.sqrt(this.semimajorAxis ** 3 / this.mu));\n        return (periodSec / 60);\n    }\n    /**\n     * Gets the number of revolutions per day.\n     * @returns The number of revolutions per day.\n     */\n    get revsPerDay() {\n        return MINUTES_PER_DAY / this.period;\n    }\n    /**\n     * Converts the equinoctial elements to classical elements.\n     * @returns The classical elements.\n     */\n    toClassicalElements() {\n        const a = this.semimajorAxis;\n        const e = Math.sqrt(this.k * this.k + this.h * this.h);\n        const i = Math.PI * ((1.0 - this.I) * 0.5) + 2.0 * this.I * Math.atan(Math.sqrt(this.p * this.p + this.q * this.q));\n        const o = Math.atan2(this.p, this.q);\n        const w = Math.atan2(this.h, this.k) - this.I * Math.atan2(this.p, this.q);\n        const m = this.lambda - this.I * o - w;\n        const v = newtonM(e, m).nu;\n        return new ClassicalElements({\n            epoch: this.epoch,\n            semimajorAxis: a,\n            eccentricity: e,\n            inclination: i,\n            rightAscension: o,\n            argPerigee: w,\n            trueAnomaly: v,\n            mu: this.mu,\n        });\n    }\n    /**\n     * Converts the equinoctial elements to position and velocity.\n     * @returns The position and velocity in classical elements.\n     */\n    toPositionVelocity() {\n        return this.toClassicalElements().toPositionVelocity();\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { Tle } from '../main.js';\n/**\n * A class containing static methods for formatting TLEs (Two-Line Elements).\n */\nexport class FormatTle {\n    constructor() {\n        // Static class\n    }\n    /**\n     * Creates a TLE (Two-Line Element) string based on the provided TleParams.\n     * @param tleParams - The parameters used to generate the TLE.\n     * @returns An object containing the TLE strings tle1 and tle2.\n     */\n    static createTle(tleParams) {\n        const { inc, meanmo, rasc, argPe, meana, ecen, epochyr, epochday, intl } = tleParams;\n        const scc = Tle.convert6DigitToA5(tleParams.scc);\n        const epochYrStr = epochyr.padStart(2, '0');\n        const epochdayStr = parseFloat(epochday).toFixed(8).padStart(12, '0');\n        const incStr = FormatTle.inclination(inc);\n        const meanmoStr = FormatTle.meanMotion(meanmo);\n        const rascStr = FormatTle.rightAscension(rasc);\n        const argPeStr = FormatTle.argumentOfPerigee(argPe);\n        const meanaStr = FormatTle.meanAnomaly(meana);\n        const ecenStr = FormatTle.eccentricity(ecen);\n        const intlStr = intl.padEnd(8, ' ');\n        // M' and M'' are both set to 0 to put the object in a perfect stable orbit\n        let TLE1Ending = tleParams.sat ? tleParams.sat.tle1.substring(32, 71) : ' +.00000000 +00000+0 +00000-0 0  9990';\n        // Add explicit positive/negative signs\n        TLE1Ending = TLE1Ending[1] === ' ' ? FormatTle.setCharAt(TLE1Ending, 1, '+') : TLE1Ending;\n        TLE1Ending = TLE1Ending[12] === ' ' ? FormatTle.setCharAt(TLE1Ending, 12, '+') : TLE1Ending;\n        TLE1Ending = TLE1Ending[21] === ' ' ? FormatTle.setCharAt(TLE1Ending, 21, '+') : TLE1Ending;\n        TLE1Ending = TLE1Ending[32] === ' ' ? FormatTle.setCharAt(TLE1Ending, 32, '0') : TLE1Ending;\n        const tle1 = `1 ${scc}U ${intlStr} ${epochYrStr}${epochdayStr}${TLE1Ending}`;\n        const tle2 = `2 ${scc} ${incStr} ${rascStr} ${ecenStr} ${argPeStr} ${meanaStr} ${meanmoStr} 00010`;\n        return { tle1: tle1, tle2: tle2 };\n    }\n    /**\n     * Converts the argument of perigee to a stringified number.\n     * @param argPe - The argument of perigee to be converted. Can be either a number or a string.\n     * @returns The argument of perigee as a stringified number.\n     * @throws Error if the length of the argument of perigee is not 8.\n     */\n    static argumentOfPerigee(argPe) {\n        if (typeof argPe === 'number') {\n            argPe = argPe.toString();\n        }\n        const argPeNum = parseFloat(argPe).toFixed(4);\n        const argPe0 = argPeNum.padStart(8, '0');\n        if (argPe0.length !== 8) {\n            throw new Error('argPe length is not 8');\n        }\n        return argPe0;\n    }\n    /**\n     * Returns the eccentricity value of a given string.\n     * @param ecen - The string representing the eccentricity.\n     * @returns The eccentricity value.\n     * @throws Error if the length of the eccentricity string is not 7.\n     */\n    static eccentricity(ecen) {\n        let ecen0 = ecen.padEnd(9, '0');\n        if (ecen0[1] === '.') {\n            ecen0 = ecen0.substring(2);\n        }\n        else {\n            ecen0 = ecen0.substring(0, 7);\n        }\n        if (ecen0.length !== 7) {\n            throw new Error('ecen length is not 7');\n        }\n        return ecen0;\n    }\n    /**\n     * Converts the inclination value to a string representation.\n     * @param inc - The inclination value to be converted.\n     * @returns The string representation of the inclination value.\n     * @throws Error if the length of the converted value is not 8.\n     */\n    static inclination(inc) {\n        if (typeof inc === 'number') {\n            inc = inc.toString();\n        }\n        const incNum = parseFloat(inc).toFixed(4);\n        const inc0 = incNum.padStart(8, '0');\n        if (inc0.length !== 8) {\n            throw new Error('inc length is not 8');\n        }\n        return inc0;\n    }\n    /**\n     * Converts the mean anomaly to a string representation with 8 digits, padded with leading zeros.\n     * @param meana - The mean anomaly to be converted. Can be either a number or a string.\n     * @returns The mean anomaly as a string with 8 digits, padded with leading zeros.\n     * @throws Error if the length of the mean anomaly is not 8.\n     */\n    static meanAnomaly(meana) {\n        if (typeof meana === 'number') {\n            meana = meana.toString();\n        }\n        const meanaNum = parseFloat(meana).toFixed(4);\n        const meana0 = meanaNum.padStart(8, '0');\n        if (meana0.length !== 8) {\n            throw new Error('meana length is not 8');\n        }\n        return meana0;\n    }\n    /**\n     * Converts the mean motion value to a string representation with 8 decimal\n     * places. If the input is a number, it is converted to a string. If the input\n     * is already a string, it is parsed as a float and then converted to a string\n     * with 8 decimal places. The resulting string is padded with leading zeros to\n     * ensure a length of 11 characters. Throws an error if the resulting string\n     * does not have a length of 11 characters.\n     * @param meanmo - The mean motion value to be converted.\n     * @returns The string representation of the mean motion value with 8 decimal\n     * places and padded with leading zeros.\n     * @throws Error if the resulting string does not have a length of 11\n     * characters.\n     */\n    static meanMotion(meanmo) {\n        if (typeof meanmo === 'number') {\n            meanmo = meanmo.toString();\n        }\n        const meanmoNum = parseFloat(meanmo).toFixed(8);\n        const meanmo0 = meanmoNum.padStart(11, '0');\n        if (meanmo0.length !== 11) {\n            throw new Error('meanmo length is not 11');\n        }\n        return meanmo0;\n    }\n    /**\n     * Converts the right ascension value to a stringified number.\n     * @param rasc - The right ascension value to convert.\n     * @returns The stringified number representation of the right ascension.\n     * @throws Error if the length of the converted right ascension is not 8.\n     */\n    static rightAscension(rasc) {\n        if (typeof rasc === 'number') {\n            rasc = rasc.toString();\n        }\n        const rascNum = parseFloat(rasc).toFixed(4);\n        const rasc0 = rascNum.padStart(8, '0');\n        if (rasc0.length !== 8) {\n            throw new Error('rasc length is not 8');\n        }\n        return rasc0;\n    }\n    /**\n     * Sets a character at a specific index in a string. If the index is out of range, the original string is returned.\n     * @param str - The input string.\n     * @param index - The index at which to set the character.\n     * @param chr - The character to set at the specified index.\n     * @returns The modified string with the character set at the specified index.\n     */\n    static setCharAt(str, index, chr) {\n        if (index > str.length - 1) {\n            return str;\n        }\n        return `${str.substring(0, index)}${chr}${str.substring(index + 1)}`;\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { Earth } from '../body/Earth.js';\nimport { AngularDistanceMethod, GroundObject } from '../main.js';\nimport { Vector3D } from '../operations/Vector3D.js';\nimport { DEG2RAD, RAD2DEG } from '../utils/constants.js';\nimport { angularDistance } from '../utils/functions.js';\nimport { ITRF } from './ITRF.js';\n/**\n * This Geodetic class represents a geodetic coordinate in three-dimensional\n * space, consisting of latitude, longitude, and altitude. It provides various\n * methods to perform calculations and operations related to geodetic\n * coordinates.\n *\n * This is a class for geodetic coordinates. This is related to the GroundObject\n * class, which is used to represent an object on the surface of the Earth.\n */\nexport class Geodetic {\n    lat;\n    lon;\n    alt;\n    constructor(latitude, longitude, altitude) {\n        if (Math.abs(latitude) > Math.PI / 2) {\n            throw new RangeError('Latitude must be between -90Â° and 90Â° in Radians.');\n        }\n        if (Math.abs(longitude) > Math.PI) {\n            throw new RangeError('Longitude must be between -180Â° and 180Â° in Radians.');\n        }\n        if (altitude < -Earth.radiusMean) {\n            throw new RangeError(`Altitude must be greater than ${-Earth.radiusMean} km. Got ${altitude} km.`);\n        }\n        this.lat = latitude;\n        this.lon = longitude;\n        this.alt = altitude;\n    }\n    /**\n     * Creates a Geodetic object from latitude, longitude, and altitude values in\n     * degrees.\n     * @param latitude The latitude value in degrees.\n     * @param longitude The longitude value in degrees.\n     * @param altitude The altitude value in kilometers.\n     * @returns A Geodetic object representing the specified latitude, longitude,\n     * and altitude.\n     */\n    static fromDegrees(latitude, longitude, altitude) {\n        return new Geodetic((latitude * DEG2RAD), (longitude * DEG2RAD), altitude);\n    }\n    /**\n     * Returns a string representation of the Geodetic object.\n     * @returns A string containing the latitude, longitude, and altitude of the Geodetic object.\n     */\n    toString() {\n        return [\n            'Geodetic',\n            `  Latitude:  ${this.latDeg.toFixed(4)}Â°`,\n            `  Longitude: ${this.lonDeg.toFixed(4)}Â°`,\n            `  Altitude:  ${this.alt.toFixed(3)} km`,\n        ].join('\\n');\n    }\n    /**\n     * Gets the latitude in degrees.\n     * @returns The latitude in degrees.\n     */\n    get latDeg() {\n        return this.lat * RAD2DEG;\n    }\n    /**\n     * Gets the longitude in degrees.\n     * @returns The longitude in degrees.\n     */\n    get lonDeg() {\n        return this.lon * RAD2DEG;\n    }\n    /**\n     * Converts the geodetic coordinates to a ground position.\n     * @returns The ground position object.\n     */\n    toGroundObject() {\n        return new GroundObject({\n            lat: this.latDeg,\n            lon: this.lonDeg,\n            alt: this.alt,\n        });\n    }\n    /**\n     * Converts the geodetic coordinates to the International Terrestrial\n     * Reference Frame (ITRF) coordinates.\n     * @param epoch The epoch in UTC.\n     * @returns The ITRF coordinates.\n     */\n    toITRF(epoch) {\n        const sLat = Math.sin(this.lat);\n        const cLat = Math.cos(this.lat);\n        const nVal = Earth.radiusEquator / Math.sqrt(1 - Earth.eccentricitySquared * sLat * sLat);\n        const r = new Vector3D(((nVal + this.alt) * cLat * Math.cos(this.lon)), ((nVal + this.alt) * cLat * Math.sin(this.lon)), ((nVal * (1 - Earth.eccentricitySquared) + this.alt) * sLat));\n        return new ITRF(epoch, r, Vector3D.origin);\n    }\n    /**\n     * Calculates the angle between two geodetic coordinates.\n     * @param g The geodetic coordinate to calculate the angle to.\n     * @param method The method to use for calculating the angular distance (optional, default is Haversine).\n     * @returns The angle between the two geodetic coordinates in radians.\n     */\n    angle(g, method = AngularDistanceMethod.Haversine) {\n        return angularDistance(this.lon, this.lat, g.lon, g.lat, method);\n    }\n    /**\n     * Calculates the angle in degrees between two Geodetic coordinates.\n     * @param g The Geodetic coordinate to calculate the angle with.\n     * @param method The method to use for calculating the angular distance (optional, default is Haversine).\n     * @returns The angle in degrees.\n     */\n    angleDeg(g, method = AngularDistanceMethod.Haversine) {\n        return (this.angle(g, method) * RAD2DEG);\n    }\n    /**\n     * Calculates the distance between two geodetic coordinates.\n     * @param g The geodetic coordinates to calculate the distance to.\n     * @param method The method to use for calculating the angular distance. Default is Haversine.\n     * @returns The distance between the two geodetic coordinates in kilometers.\n     */\n    distance(g, method = AngularDistanceMethod.Haversine) {\n        return (this.angle(g, method) * Earth.radiusMean);\n    }\n    /**\n     * Calculates the field of view based on the altitude of the Geodetic object.\n     * @returns The field of view in radians.\n     */\n    fieldOfView() {\n        return Math.acos(Earth.radiusMean / (Earth.radiusMean + this.alt));\n    }\n    /**\n     * Determines if the current geodetic coordinate can see another geodetic coordinate.\n     * @param g The geodetic coordinate to check for visibility.\n     * @param method The method to use for calculating the angular distance (optional, default is Haversine).\n     * @returns A boolean indicating if the current coordinate can see the other coordinate.\n     */\n    isInView(g, method = AngularDistanceMethod.Haversine) {\n        const fov = Math.max(this.fieldOfView(), g.fieldOfView());\n        return this.angle(g, method) <= fov;\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { Earth, J2000, Matrix, RelativeState, Vector3D, } from '../main.js';\nimport { Thrust } from './../force/Thrust.js';\n// / Hill Modified Equidistant Cyllindrical _(EQCM)_ coordinates.\nexport class Hill {\n    epoch;\n    position;\n    velocity;\n    semimajorAxis_;\n    meanMotion_;\n    constructor(epoch, position, velocity, semimajorAxis) {\n        this.epoch = epoch;\n        this.position = position;\n        this.velocity = velocity;\n        this.semimajorAxis_ = semimajorAxis;\n        this.meanMotion_ = Earth.smaToMeanMotion(this.semimajorAxis_);\n    }\n    static fromState(origin, radialPosition, intrackPosition, nodeVelocity, nodeOffsetTime) {\n        const a = origin.semimajorAxis;\n        const n = Earth.smaToMeanMotion(a);\n        const yDot = -3.0 * radialPosition * n * 0.5;\n        const z = (nodeVelocity / n) * Math.sin(n * -nodeOffsetTime);\n        const zDot = nodeVelocity * Math.cos(n * -nodeOffsetTime);\n        const r = new Vector3D(radialPosition, intrackPosition, z);\n        const v = new Vector3D(0.0, yDot, zDot);\n        return new Hill(origin.epoch, r, v, a);\n    }\n    static fromNmc(origin, majorAxisRange, nodeVelocity, nodeOffsetTime, translation = 0.0) {\n        const a = origin.semimajorAxis;\n        const n = Earth.smaToMeanMotion(a);\n        const xDot = majorAxisRange * n * 0.5;\n        const z = (nodeVelocity / n) * Math.sin(n * -nodeOffsetTime);\n        const zDot = nodeVelocity * Math.cos(n * -nodeOffsetTime);\n        const r = new Vector3D(0.0, majorAxisRange + translation, z);\n        const v = new Vector3D(xDot, 0.0, zDot);\n        return new Hill(origin.epoch, r, v, a);\n    }\n    static fromPerch(origin, perchRange, nodeVelocity, nodeOffsetTime) {\n        const a = origin.semimajorAxis;\n        const n = Earth.smaToMeanMotion(a);\n        const z = (nodeVelocity / n) * Math.sin(n * -nodeOffsetTime);\n        const zDot = nodeVelocity * Math.cos(n * -nodeOffsetTime);\n        const r = new Vector3D(0.0, perchRange, z);\n        const v = new Vector3D(0.0, 0.0, zDot);\n        return new Hill(origin.epoch, r, v, a);\n    }\n    get semimajorAxis() {\n        return this.semimajorAxis_;\n    }\n    set semimajorAxis(sma) {\n        this.semimajorAxis_ = sma;\n        this.meanMotion_ = Earth.smaToMeanMotion(this.semimajorAxis_);\n    }\n    get meanMotion() {\n        return this.meanMotion_;\n    }\n    toJ2000Matrix(origin, transform) {\n        const magrtgt = origin.position.magnitude();\n        const magrint = magrtgt + this.position.x;\n        const vtgtrsw = transform.multiplyVector3D(origin.velocity);\n        const lambdadottgt = vtgtrsw.y / magrtgt;\n        const lambdaint = this.position.y / magrtgt;\n        const phiint = this.position.z / magrtgt;\n        const sinphiint = Math.sin(phiint);\n        const cosphiint = Math.cos(phiint);\n        const sinlambdaint = Math.sin(lambdaint);\n        const coslambdaint = Math.cos(lambdaint);\n        const rotRswSez = new Matrix([\n            [sinphiint * coslambdaint, sinphiint * sinlambdaint, -cosphiint],\n            [-sinlambdaint, coslambdaint, 0],\n            [cosphiint * coslambdaint, cosphiint * sinlambdaint, sinphiint],\n        ]);\n        const rdotint = this.velocity.x + vtgtrsw.x;\n        const lambdadotint = this.velocity.y / magrtgt + lambdadottgt;\n        const phidotint = this.velocity.z / magrtgt;\n        const vintsez = new Vector3D(-magrint * phidotint, magrint * lambdadotint * cosphiint, rdotint);\n        const vintrsw = rotRswSez.transpose().multiplyVector3D(vintsez);\n        const vinteci = transform.transpose().multiplyVector3D(vintrsw);\n        const rintrsw = new Vector3D(cosphiint * magrint * coslambdaint, cosphiint * magrint * sinlambdaint, sinphiint * magrint);\n        const rinteci = transform.transpose().multiplyVector3D(rintrsw);\n        return new J2000(origin.epoch, rinteci, vinteci);\n    }\n    toJ2000(origin) {\n        return this.toJ2000Matrix(origin, RelativeState.createMatrix(origin.position, origin.velocity));\n    }\n    static transitionMatrix(t, meanMotion) {\n        const n = meanMotion;\n        const sn = Math.sin(n * t);\n        const cs = Math.cos(n * t);\n        return new Matrix([\n            [4.0 - 3.0 * cs, 0.0, 0.0, sn / n, (2.0 * (1.0 - cs)) / n, 0.0],\n            [6.0 * (sn - n * t), 1.0, 0.0, (-2.0 * (1.0 - cs)) / n, (4.0 * sn - 3.0 * n * t) / n, 0.0],\n            [0.0, 0.0, cs, 0.0, 0.0, sn / n],\n            [3.0 * n * sn, 0.0, 0.0, cs, 2.0 * sn, 0.0],\n            [-6.0 * n * (1.0 - cs), 0.0, 0.0, -2.0 * sn, 4.0 * cs - 3.0, 0.0],\n            [0.0, 0.0, -n * sn, 0.0, 0.0, cs],\n        ]);\n    }\n    transition(t) {\n        const sysMat = Hill.transitionMatrix(t, this.meanMotion_);\n        const res = sysMat.multiplyVector(this.position.join(this.velocity)).elements;\n        return new Hill(this.epoch.roll(t), new Vector3D(res[0], res[1], res[2]), new Vector3D(res[3], res[4], res[5]), this.semimajorAxis_);\n    }\n    transitionWithMatrix(stm, t) {\n        const res = stm.multiplyVector(this.position.join(this.velocity)).elements;\n        return new Hill(this.epoch.roll(t), new Vector3D(res[0], res[1], res[2]), new Vector3D(res[3], res[4], res[5]), this.semimajorAxis_);\n    }\n    propagate(newEpoch) {\n        return this.transition(newEpoch.difference(this.epoch));\n    }\n    propagateWithMatrix(stm, newEpoch) {\n        return this.transitionWithMatrix(stm, newEpoch.difference(this.epoch));\n    }\n    maneuver(maneuver) {\n        const state = this.propagate(maneuver.center);\n        return new Hill(state.epoch, state.position, state.velocity.add(maneuver.deltaV), state.semimajorAxis_);\n    }\n    ephemeris(start, stop, step = 60.0) {\n        const output = [];\n        let current = start;\n        while (stop >= current) {\n            output.push(this.propagate(current));\n            current = current.roll(step);\n        }\n        return output;\n    }\n    get period() {\n        return (2 * Math.PI) / this.meanMotion_;\n    }\n    nextRadialTangent() {\n        const x = this.position.x;\n        const xDot = this.velocity.x;\n        const yDot = this.velocity.y;\n        let t = Math.atan(-xDot / (3.0 * this.meanMotion_ * x + 2.0 * yDot)) / this.meanMotion_;\n        if (t <= 0) {\n            t = t + 0.5 * this.period;\n        }\n        else if (isNaN(t)) {\n            t = 0.5 * this.period;\n        }\n        return this.propagate(this.epoch.roll(t));\n    }\n    solveManeuver(waypoint, ignoreCrosstrack = false) {\n        const t = waypoint.epoch.difference(this.epoch);\n        const w = waypoint.relativePosition;\n        const sysMat = Hill.transitionMatrix(t, this.meanMotion_);\n        const posEquationMat = new Matrix([\n            [sysMat.elements[0][0], sysMat.elements[0][1], sysMat.elements[0][2]],\n            [sysMat.elements[1][0], sysMat.elements[1][1], sysMat.elements[1][2]],\n            [sysMat.elements[2][0], sysMat.elements[2][1], sysMat.elements[2][2]],\n        ]);\n        const solnVector = w\n            .subtract(posEquationMat.multiplyVector3D(this.position));\n        const velEquationMat = new Matrix([\n            [sysMat.elements[0][3], sysMat.elements[0][4], sysMat.elements[0][5]],\n            [sysMat.elements[1][3], sysMat.elements[1][4], sysMat.elements[1][5]],\n            [sysMat.elements[2][3], sysMat.elements[2][4], sysMat.elements[2][5]],\n        ]);\n        let result = velEquationMat\n            .inverse()\n            .multiplyVector3D(solnVector)\n            .subtract(this.velocity);\n        if (ignoreCrosstrack) {\n            result = new Vector3D(result.x, result.y, 0);\n        }\n        return new Thrust(this.epoch, result.x * 1000, result.y * 1000, result.z * 1000);\n    }\n    maneuverSequence(pivot, waypoints, preManeuvers = [], postManeuvers = []) {\n        let state = new Hill(this.epoch, this.position, this.velocity, this.semimajorAxis_);\n        preManeuvers = preManeuvers.slice();\n        postManeuvers = postManeuvers.slice();\n        let output = preManeuvers;\n        // Note difference was once compareTo\n        output.sort((a, b) => a.center.difference(b.center));\n        output = output.filter((mvr) => mvr.center >= this.epoch && mvr.center >= pivot);\n        for (const mvr of output) {\n            state = state.maneuver(mvr);\n        }\n        state = state.propagate(pivot);\n        for (const wpt of waypoints) {\n            const mvr = state.solveManeuver(wpt);\n            state = state.maneuver(mvr);\n            output.push(mvr);\n        }\n        output.push(...postManeuvers);\n        return output;\n    }\n    maneuverOrigin(maneuver) {\n        const state = this.propagate(maneuver.center);\n        const vInit = Math.sqrt(Earth.mu / this.semimajorAxis_);\n        const vFinal = vInit - maneuver.intrack * 1e-3;\n        const aFinal = Earth.mu / (vFinal * vFinal);\n        return new Hill(state.epoch, state.position, state.velocity.subtract(maneuver.deltaV), aFinal);\n    }\n    get name() {\n        return 'Hill';\n    }\n    toString() {\n        return [\n            `[${this.name}]`,\n            `  Epoch: ${this.epoch}`,\n            `  Position: ${this.position.toString(6)} km`,\n            `  Velocity: ${this.velocity.toString(9)} km/s`,\n        ].join('\\n');\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\n/* eslint-disable class-methods-use-this */\nimport { Earth } from '../body/Earth.js';\nimport { Geodetic } from './Geodetic.js';\nimport { J2000 } from './J2000.js';\nimport { StateVector } from './StateVector.js';\n/**\n * The International Terrestrial Reference Frame (ITRF) is a geocentric reference frame for the Earth. It is the\n * successor to the International Terrestrial Reference System (ITRS). The ITRF definition is maintained by the\n * International Earth Rotation and Reference Systems Service (IERS). Several versions of ITRF exist, each with a\n * different epoch, to address the issue of crustal motion. The latest version is ITRF2014, based on data collected from\n * 1980 to 2014.\n * @see https://en.wikipedia.org/wiki/International_Terrestrial_Reference_Frame\n *\n * This is a geocentric coordinate system, also referenced as ECF/ECEF (Earth Centered Earth Fixed). It is a Cartesian\n * coordinate system with the origin at the center of the Earth. The x-axis intersects the sphere of the Earth at 0Â°\n * latitude (the equator) and 0Â° longitude (the Prime Meridian). The z-axis goes through the North Pole. The y-axis goes\n * through 90Â° East longitude.\n * @see https://en.wikipedia.org/wiki/Earth-centered,_Earth-fixed_coordinate_system\n */\nexport class ITRF extends StateVector {\n    /**\n     * Gets the name of the ITRF coordinate system.\n     * @returns The name of the coordinate system.\n     */\n    get name() {\n        return 'ITRF';\n    }\n    /**\n     * Gets a value indicating whether the coordinate system is inertial.\n     * @returns A boolean value indicating whether the coordinate system is inertial.\n     */\n    get inertial() {\n        return false;\n    }\n    /**\n     * Gets the height of the ITRF coordinate above the surface of the Earth in kilometers.\n     * @returns The height in kilometers.\n     */\n    get height() {\n        const a = Earth.radiusEquator;\n        const e2 = Earth.eccentricitySquared;\n        const r = this.position.magnitude();\n        const sl = this.position.z / r;\n        const cl2 = 1 - sl * sl;\n        const coeff = Math.sqrt((1 - e2) / (1 - e2 * cl2));\n        return (r - a * coeff);\n    }\n    /**\n     * Gets the altitude in kilometers.\n     * @returns The altitude in kilometers.\n     */\n    get alt() {\n        return this.height;\n    }\n    /**\n     * Converts the current coordinate to the J2000 coordinate system. This is an Earth-Centered Inertial (ECI) coordinate\n     * system with the origin at the center of the Earth.\n     * @see https://en.wikipedia.org/wiki/Epoch_(astronomy)#Julian_years_and_J2000\n     * @returns The coordinate in the J2000 coordinate system.\n     */\n    toJ2000() {\n        const p = Earth.precession(this.epoch);\n        const n = Earth.nutation(this.epoch);\n        const ast = this.epoch.gmstAngle() + n.eqEq;\n        const rTOD = this.position.rotZ(-ast);\n        const vTOD = this.velocity\n            .add(Earth.rotation.cross(this.position))\n            .rotZ(-ast);\n        const rMOD = rTOD.rotX(n.eps).rotZ(n.dPsi).rotX(-n.mEps);\n        const vMOD = vTOD.rotX(n.eps).rotZ(n.dPsi).rotX(-n.mEps);\n        const rJ2000 = rMOD\n            .rotZ(p.zed)\n            .rotY(-p.theta)\n            .rotZ(p.zeta);\n        const vJ2000 = vMOD\n            .rotZ(p.zed)\n            .rotY(-p.theta)\n            .rotZ(p.zeta);\n        return new J2000(this.epoch, rJ2000, vJ2000);\n    }\n    /**\n     * Converts the current ITRF coordinate to Geodetic coordinate. This is a coordinate system for latitude, longitude,\n     * and altitude.\n     * @returns The converted Geodetic coordinate.\n     */\n    toGeodetic() {\n        const sma = Earth.radiusEquator;\n        const esq = Earth.eccentricitySquared;\n        const x = this.position.x;\n        const y = this.position.y;\n        const z = this.position.z;\n        const lon = Math.atan2(y, x);\n        const r = Math.sqrt(x * x + y * y);\n        const phi = Math.atan(z / r);\n        let lat = phi;\n        let alt;\n        let c = 0.0;\n        if (x === 0 && y === 0) {\n            lat = phi;\n            alt = z > 0 ? (z - Earth.radiusPolar) : (z + Earth.radiusPolar);\n        }\n        else {\n            for (let i = 0; i < 20; i++) {\n                const slat = Math.sin(lat);\n                c = 1 / Math.sqrt(1 - esq * slat * slat);\n                lat = Math.atan((z + sma * c * esq * slat) / r);\n            }\n            alt = (r / Math.cos(lat) - sma * c);\n        }\n        return new Geodetic(lat, lon, alt);\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { Earth } from '../body/Earth.js';\nimport { ITRF } from './ITRF.js';\nimport { StateVector } from './StateVector.js';\nimport { TEME } from './TEME.js';\n/**\n * Represents a position and velocity in the J2000 coordinate system. This is an Earth-centered inertial (ECI)\n * coordinate system.\n *\n * Commonly used ECI frame is defined with the Earth's Mean Equator and Mean Equinox (MEME) at 12:00 Terrestrial Time on\n * 1 January 2000. It can be referred to as J2K, J2000 or EME2000. The x-axis is aligned with the mean vernal equinox.\n * The z-axis is aligned with the Earth's rotation axis (or equivalently, the celestial North Pole) as it was at that\n * time. The y-axis is rotated by 90Â° East about the celestial equator.\n * @see https://en.wikipedia.org/wiki/Earth-centered_inertial\n */\nexport class J2000 extends StateVector {\n    /**\n     * Creates a J2000 coordinate from classical elements.\n     * @param elements The classical elements.\n     * @returns The J2000 coordinate.\n     */\n    static fromClassicalElements(elements) {\n        const rv = elements.toPositionVelocity();\n        return new J2000(elements.epoch, rv.position, rv.velocity);\n    }\n    /**\n     * Gets the name of the coordinate system.\n     * @returns The name of the coordinate system.\n     */\n    get name() {\n        return 'J2000';\n    }\n    /**\n     * Gets a value indicating whether the coordinate system is inertial.\n     * @returns A boolean value indicating whether the coordinate system is inertial.\n     */\n    get inertial() {\n        return true;\n    }\n    /**\n     * Converts the coordinates from J2000 to the International Terrestrial Reference Frame (ITRF).\n     * This is an ECI to ECF transformation.\n     * @returns The ITRF coordinates.\n     */\n    toITRF() {\n        const p = Earth.precession(this.epoch);\n        const n = Earth.nutation(this.epoch);\n        const ast = (this.epoch.gmstAngle() + n.eqEq);\n        const rMOD = this.position\n            .rotZ(-p.zeta)\n            .rotY(p.theta)\n            .rotZ(-p.zed);\n        const vMOD = this.velocity\n            .rotZ(-p.zeta)\n            .rotY(p.theta)\n            .rotZ(-p.zed);\n        const rTOD = rMOD\n            .rotX(n.mEps)\n            .rotZ(-n.dPsi)\n            .rotX(-n.eps);\n        const vTOD = vMOD\n            .rotX(n.mEps)\n            .rotZ(-n.dPsi)\n            .rotX(-n.eps);\n        const rPEF = rTOD.rotZ(ast);\n        const vPEF = vTOD.rotZ(ast).add(Earth.rotation.negate().cross(rPEF));\n        return new ITRF(this.epoch, rPEF, vPEF);\n    }\n    /**\n     * Converts the J2000 coordinate to the TEME coordinate.\n     * @returns The TEME coordinate.\n     */\n    toTEME() {\n        const p = Earth.precession(this.epoch);\n        const n = Earth.nutation(this.epoch);\n        const eps = n.mEps + n.dEps;\n        const dPsiCosEps = (n.dPsi * Math.cos(eps));\n        const rMOD = this.position\n            .rotZ(-p.zeta)\n            .rotY(p.theta)\n            .rotZ(-p.zed);\n        const vMOD = this.velocity\n            .rotZ(-p.zeta)\n            .rotY(p.theta)\n            .rotZ(-p.zed);\n        const rTEME = rMOD\n            .rotX(n.mEps)\n            .rotZ(-n.dPsi)\n            .rotX(-eps)\n            .rotZ(dPsiCosEps);\n        const vTEME = vMOD\n            .rotX(n.mEps)\n            .rotZ(-n.dPsi)\n            .rotX(-eps)\n            .rotZ(dPsiCosEps);\n        return new TEME(this.epoch, rTEME, vTEME);\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { J2000 } from './J2000.js';\nimport { RelativeState } from './RelativeState.js';\n/**\n * Represents a Radial-Intrack-Crosstrack (RIC) coordinates.\n */\nexport class RIC extends RelativeState {\n    /**\n     * Gets the name of the RIC coordinate system.\n     * @returns The name of the RIC coordinate system.\n     */\n    get name() {\n        return 'RIC';\n    }\n    /**\n     * Creates a new RIC (Radial-Intrack-Crosstrack) coordinate from the J2000 state vectors.\n     * @param state - The J2000 state vector.\n     * @param origin - The J2000 state vector of the origin.\n     * @param transform - The transformation matrix.\n     * @returns The RIC coordinate.\n     */\n    static fromJ2000Matrix(state, origin, transform) {\n        const dr = state.position.subtract(origin.position);\n        const dv = state.velocity.subtract(origin.velocity);\n        return new RIC(transform.multiplyVector3D(dr), transform.multiplyVector3D(dv));\n    }\n    /**\n     * Creates a RIC (Radial-Intrack-Crosstrack) coordinate system from a J2000 state and origin.\n     * @param state The J2000 state.\n     * @param origin The J2000 origin.\n     * @returns The RIC coordinate system.\n     */\n    static fromJ2000(state, origin) {\n        return RIC.fromJ2000Matrix(state, origin, RelativeState.createMatrix(origin.position, origin.velocity));\n    }\n    /**\n     * Transforms the current RIC coordinate to the J2000 coordinate system using the provided origin and transform\n     * matrix.\n     * @param origin The origin J2000 coordinate.\n     * @param transform The transformation matrix.\n     * @returns The transformed J2000 coordinate.\n     */\n    toJ2000Matrix(origin, transform) {\n        const tt = transform.transpose();\n        const tr = tt.multiplyVector3D(this.position);\n        const tv = tt.multiplyVector3D(this.velocity);\n        return new J2000(origin.epoch, origin.position.add(tr), origin.velocity.add(tv));\n    }\n    /**\n     * Transforms the current RIC coordinate to the J2000 coordinate system using the provided origin.\n     * @param origin The origin J2000 coordinate.\n     * @returns The transformed J2000 coordinate.\n     */\n    toJ2000(origin) {\n        return this.toJ2000Matrix(origin, RelativeState.createMatrix(origin.position, origin.velocity));\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { Matrix } from '../operations/Matrix.js';\n/**\n * Represents the relative state of an object in 3D space.\n */\nexport class RelativeState {\n    position;\n    velocity;\n    constructor(position, velocity) {\n        this.position = position;\n        this.velocity = velocity;\n    }\n    /**\n     * Returns a string representation of the RelativeState object. The string includes the name, position, and velocity\n     * of the object.\n     * @returns A string representation of the RelativeState object.\n     */\n    toString() {\n        return [\n            `[${this.name}]`,\n            `  Position: ${this.position.toString(6)} km`,\n            `  Velocity: ${this.velocity.toString(9)} km/s`,\n        ].join('\\n');\n    }\n    /**\n     * Creates a matrix based on the given position and velocity vectors. The matrix represents the relative state of an\n     * object in 3D space.\n     * @param position - The position vector.\n     * @param velocity - The velocity vector.\n     * @returns The matrix representing the relative state.\n     */\n    static createMatrix(position, velocity) {\n        const ru = position.normalize();\n        const cu = position.cross(velocity).normalize();\n        const iu = cu.cross(ru).normalize();\n        return new Matrix([\n            [ru.x, ru.y, ru.z],\n            [iu.x, iu.y, iu.z],\n            [cu.x, cu.y, cu.z],\n        ]);\n    }\n    /**\n     * Calculates the range of the relative state.\n     * @returns The range in kilometers.\n     */\n    get range() {\n        return this.position.magnitude();\n    }\n    /**\n     * Calculates the range rate of the relative state. Range rate is the dot product of the position and velocity divided\n     * by the range.\n     * @returns The range rate in Kilometers per second.\n     */\n    get rangeRate() {\n        return this.position.dot(this.velocity) / this.range;\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { ClassicalElements, Earth, TAU, } from '../main.js';\n/**\n * A state vector is a set of coordinates used to specify the position and\n * velocity of an object in a particular reference frame.\n */\nexport class StateVector {\n    epoch;\n    position;\n    velocity;\n    constructor(epoch, position, velocity) {\n        this.epoch = epoch;\n        this.position = position;\n        this.velocity = velocity;\n    }\n    /**\n     * Returns a string representation of the StateVector object. The string includes the name, epoch, position, and\n     * velocity.\n     * @returns A string representation of the StateVector object.\n     */\n    toString() {\n        return [\n            `[${this.name}]`,\n            `  Epoch: ${this.epoch}`,\n            `  Position: ${this.position.toString(6)} km`,\n            `  Velocity: ${this.velocity.toString(9)} km/s`,\n        ].join('\\n');\n    }\n    /**\n     * Calculates the mechanical energy of the state vector.\n     * @returns The mechanical energy value.\n     */\n    get mechanicalEnergy() {\n        const r = this.position.magnitude();\n        const v = this.velocity.magnitude();\n        return v * v * 0.5 - Earth.mu / r;\n    }\n    /**\n     * Calculates the semimajor axis of the state vector.\n     * @returns The semimajor axis in kilometers.\n     */\n    get semimajorAxis() {\n        const energy = this.mechanicalEnergy;\n        return (-Earth.mu / (2.0 * energy));\n    }\n    /**\n     * Gets the period of the state vector in minutes.\n     * @returns The period in minutes.\n     */\n    get period() {\n        const a = this.semimajorAxis;\n        const periodSeconds = TAU * Math.sqrt((a * a * a) / Earth.mu);\n        return (periodSeconds / 60.0);\n    }\n    /**\n     * Gets the angular rate of the state vector.\n     * @returns The angular rate.\n     */\n    get angularRate() {\n        const a = this.semimajorAxis;\n        return Math.sqrt(Earth.mu / (a * a * a));\n    }\n    /**\n     * Converts the state vector to classical elements.\n     * @param mu The gravitational parameter of the celestial body. Defaults to Earth's gravitational parameter.\n     * @returns The classical elements corresponding to the state vector.\n     * @throws Error if classical elements are undefined for fixed frames.\n     */\n    toClassicalElements(mu = Earth.mu) {\n        if (!this.inertial) {\n            throw new Error('Classical elements are undefined for fixed frames.');\n        }\n        return ClassicalElements.fromStateVector(this, mu);\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { Earth } from '../body/Earth.js';\nimport { J2000 } from './J2000.js';\nimport { StateVector } from './StateVector.js';\n/**\n * True Equator Mean Equinox (TEME) is a coordinate system commonly used in satellite tracking and orbit prediction. It\n * is a reference frame that defines the position and orientation of an object relative to the Earth's equator and\n * equinox.\n *\n * By using the True Equator Mean Equinox (TEME) coordinate system, we can accurately describe the position and motion\n * of satellites relative to the Earth's equator and equinox. This is particularly useful for tracking and predicting\n * satellite orbits in various applications, such as satellite communication, navigation, and remote sensing.\n */\nexport class TEME extends StateVector {\n    /**\n     * Gets the name of the coordinate system.\n     * @returns The name of the coordinate system.\n     */\n    get name() {\n        return 'TEME';\n    }\n    /**\n     * Gets a value indicating whether the coordinate is inertial.\n     * @returns A boolean value indicating whether the coordinate is inertial.\n     */\n    get inertial() {\n        return true;\n    }\n    /**\n     * Creates a TEME (True Equator Mean Equinox) object from classical orbital elements.\n     * @param elements - The classical orbital elements.\n     * @returns A new TEME object.\n     */\n    static fromClassicalElements(elements) {\n        const rv = elements.toPositionVelocity();\n        return new TEME(elements.epoch, rv.position, rv.velocity);\n    }\n    /**\n     * Converts the TEME (True Equator Mean Equinox) coordinates to J2000 coordinates.\n     * @returns The J2000 coordinates.\n     */\n    toJ2000() {\n        const p = Earth.precession(this.epoch);\n        const n = Earth.nutation(this.epoch);\n        const eps = n.mEps + n.dEps;\n        const dPsiCosEps = n.dPsi * Math.cos(eps);\n        const rMOD = this.position\n            .rotZ(-dPsiCosEps)\n            .rotX(eps)\n            .rotZ(n.dPsi)\n            .rotX(-n.mEps);\n        const vMOD = this.velocity\n            .rotZ(-dPsiCosEps)\n            .rotX(eps)\n            .rotZ(n.dPsi)\n            .rotX(-n.mEps);\n        const rJ2K = rMOD\n            .rotZ(p.zed)\n            .rotY(-p.theta)\n            .rotZ(p.zeta);\n        const vJ2K = vMOD\n            .rotZ(p.zed)\n            .rotY(-p.theta)\n            .rotZ(p.zeta);\n        return new J2000(this.epoch, rJ2K, vJ2K);\n    }\n}\n","/* eslint-disable max-lines */\n/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { Sgp4OpsMode } from '../enums/Sgp4OpsMode.js';\nimport { Sgp4, Vector3D } from '../main.js';\nimport { Sgp4GravConstants } from '../sgp4/sgp4.js';\nimport { EpochUTC } from '../time/EpochUTC.js';\nimport { DEG2RAD, earthGravityParam, RAD2DEG, secondsPerDay, TAU } from '../utils/constants.js';\nimport { getDayOfYear, newtonNu, toPrecision } from '../utils/functions.js';\nimport { FormatTle, TEME } from './index.js';\nimport { TleFormatData } from './tle-format-data.js';\n/**\n * Tle is a static class with a collection of methods for working with TLEs.\n */\nexport class Tle {\n    line1;\n    line2;\n    epoch;\n    satnum;\n    satrec_;\n    /**\n     * Mapping of alphabets to their corresponding numeric values.\n     */\n    static alpha5_ = {\n        A: '10',\n        B: '11',\n        C: '12',\n        D: '13',\n        E: '14',\n        F: '15',\n        G: '16',\n        H: '17',\n        // I is skipped on purpose\n        J: '18',\n        K: '19',\n        L: '20',\n        M: '21',\n        N: '22',\n        // O is skipped on purpose\n        P: '23',\n        Q: '24',\n        R: '25',\n        S: '26',\n        T: '27',\n        U: '28',\n        V: '29',\n        W: '30',\n        X: '31',\n        Y: '32',\n        Z: '33',\n    };\n    /** The argument of perigee field. */\n    static argPerigee_ = new TleFormatData(35, 42);\n    /** The BSTAR drag term field. */\n    static bstar_ = new TleFormatData(54, 61);\n    /** The checksum field. */\n    static checksum_ = new TleFormatData(69, 69);\n    /** The classification field. */\n    static classification_ = new TleFormatData(8, 8);\n    /** The eccentricity field. */\n    static eccentricity_ = new TleFormatData(27, 33);\n    /** The element set number field. */\n    static elsetNum_ = new TleFormatData(65, 68);\n    /** The ephemeris type field. */\n    static ephemerisType_ = new TleFormatData(63, 63);\n    /** The epoch day field. */\n    static epochDay_ = new TleFormatData(21, 32);\n    /** The epoch year field. */\n    static epochYear_ = new TleFormatData(19, 20);\n    /** The inclination field. */\n    static inclination_ = new TleFormatData(9, 16);\n    /** The international designator launch number field. */\n    static intlDesLaunchNum_ = new TleFormatData(12, 14);\n    /** The international designator launch piece field. */\n    static intlDesLaunchPiece_ = new TleFormatData(15, 17);\n    /** The international designator year field. */\n    static intlDesYear_ = new TleFormatData(10, 11);\n    /** The line number field. */\n    static lineNumber_ = new TleFormatData(1, 1);\n    /** The mean anomaly field. */\n    static meanAnom_ = new TleFormatData(44, 51);\n    /** The first derivative of the mean motion field. */\n    static meanMoDev1_ = new TleFormatData(34, 43);\n    /** The second derivative of the mean motion field. */\n    static meanMoDev2_ = new TleFormatData(45, 52);\n    /** The mean motion field. */\n    static meanMo_ = new TleFormatData(53, 63);\n    /** The right ascension of the ascending node field. */\n    static rightAscension_ = new TleFormatData(18, 25);\n    /** The revolution number field. */\n    static revNum_ = new TleFormatData(64, 68);\n    /** The satellite number field. */\n    static satNum_ = new TleFormatData(3, 7);\n    constructor(line1, line2, opsMode = Sgp4OpsMode.AFSPC, gravConst = Sgp4GravConstants.wgs72) {\n        this.line1 = line1;\n        this.line2 = line2;\n        this.epoch = Tle.parseEpoch_(line1.substring(18, 32));\n        this.satnum = parseInt(Tle.convertA5to6Digit(line1.substring(2, 7)));\n        this.satrec_ = Sgp4.createSatrec(line1, line2, gravConst, opsMode);\n    }\n    toString() {\n        return `${this.line1}\\n${this.line2}`;\n    }\n    /**\n     * Gets the semimajor axis of the TLE.\n     * @returns The semimajor axis value.\n     */\n    get semimajorAxis() {\n        return Tle.tleSma_(this.line2);\n    }\n    /**\n     * Gets the eccentricity of the TLE.\n     * @returns The eccentricity value.\n     */\n    get eccentricity() {\n        return Tle.tleEcc_(this.line2);\n    }\n    /**\n     * Gets the inclination of the TLE.\n     * @returns The inclination in degrees.\n     */\n    get inclination() {\n        return Tle.tleInc_(this.line2);\n    }\n    /**\n     * Gets the inclination in degrees.\n     * @returns The inclination in degrees.\n     */\n    get inclinationDegrees() {\n        return Tle.tleInc_(this.line2) * RAD2DEG;\n    }\n    /**\n     * Gets the apogee of the TLE (Two-Line Elements) object.\n     * Apogee is the point in an orbit that is farthest from the Earth.\n     * It is calculated as the product of the semimajor axis and (1 + eccentricity).\n     * @returns The apogee value.\n     */\n    get apogee() {\n        return this.semimajorAxis * (1 + this.eccentricity);\n    }\n    /**\n     * Gets the perigee of the TLE (Two-Line Element Set).\n     * The perigee is the point in the orbit of a satellite or other celestial body where it is closest to the Earth.\n     * It is calculated as the product of the semimajor axis and the difference between 1 and the eccentricity.\n     * @returns The perigee value.\n     */\n    get perigee() {\n        return this.semimajorAxis * (1 - this.eccentricity);\n    }\n    /**\n     * Gets the period of the TLE in minutes.\n     * @returns The period of the TLE in minutes.\n     */\n    get period() {\n        const periodSec = (TAU * Math.sqrt(this.semimajorAxis ** 3 / earthGravityParam));\n        return (periodSec / 60);\n    }\n    /**\n     * Parses the epoch string and returns the corresponding EpochUTC object.\n     * @param epochStr - The epoch string to parse.\n     * @returns The parsed EpochUTC object.\n     */\n    static parseEpoch_(epochStr) {\n        let year = parseInt(epochStr.substring(0, 2));\n        if (year >= 57) {\n            year += 1900;\n        }\n        else {\n            year += 2000;\n        }\n        const days = parseFloat(epochStr.substring(2, 14)) - 1;\n        return EpochUTC.fromDateTimeString(`${year}-01-01T00:00:00.000Z`).roll(days * secondsPerDay);\n    }\n    static calcElsetAge(tle1, nowInput, outputUnits = 'days') {\n        nowInput ??= new Date();\n        const currentYearFull = nowInput.getUTCFullYear();\n        const currentYearShort = currentYearFull % 100;\n        const epochYearShort = parseInt(tle1.substring(18, 20), 10);\n        const epochDayOfYear = parseFloat(tle1.substring(20, 32));\n        let epochYearFull;\n        if (epochYearShort <= currentYearShort) {\n            epochYearFull = 2000 + epochYearShort;\n        }\n        else {\n            epochYearFull = 1900 + epochYearShort;\n        }\n        const epochJday = epochDayOfYear + (epochYearFull * 365);\n        const currentJday = getDayOfYear() + (currentYearFull * 365);\n        const currentTime = (nowInput.getUTCHours() * 3600 + nowInput.getUTCMinutes() * 60 +\n            nowInput.getUTCSeconds()) / 86400;\n        const daysOld = (currentJday + currentTime) - epochJday;\n        switch (outputUnits) {\n            case 'hours':\n                return daysOld * 24;\n            case 'minutes':\n                return daysOld * 1440;\n            case 'seconds':\n                return daysOld * 86400;\n            default:\n                return daysOld;\n        }\n    }\n    /**\n     * Propagates the TLE (Two-Line Element Set) to a specific epoch and returns the TEME (True Equator Mean Equinox)\n     * coordinates.\n     * @param epoch The epoch to propagate the TLE to.\n     * @returns The TEME coordinates at the specified epoch.\n     * @throws Error if propagation fails.\n     */\n    propagate(epoch) {\n        const r = new Float64Array(3);\n        const v = new Float64Array(3);\n        const stateVector = Sgp4.propagate(this.satrec_, epoch.difference(this.epoch) / 60.0);\n        if (!stateVector) {\n            throw new Error('Propagation failed');\n        }\n        Tle.sv2rv_(stateVector, r, v);\n        return new TEME(epoch, new Vector3D(r[0], r[1], r[2]), new Vector3D(v[0], v[1], v[2]));\n    }\n    /**\n     * Converts the state vector to position and velocity arrays.\n     * @param stateVector - The state vector containing position and velocity information.\n     * @param r - The array to store the position values.\n     * @param v - The array to store the velocity values.\n     */\n    static sv2rv_(stateVector, r, v) {\n        const pos = stateVector.position;\n        const vel = stateVector.velocity;\n        r[0] = pos.x;\n        r[1] = pos.y;\n        r[2] = pos.z;\n        v[0] = vel.x;\n        v[1] = vel.y;\n        v[2] = vel.z;\n    }\n    /**\n     * Returns the current state of the satellite in the TEME coordinate system.\n     * @returns The current state of the satellite.\n     */\n    currentState_() {\n        const r = new Float64Array(3);\n        const v = new Float64Array(3);\n        const stateVector = Sgp4.propagate(this.satrec_, 0.0);\n        Tle.sv2rv_(stateVector, r, v);\n        return new TEME(this.epoch, new Vector3D(r[0], r[1], r[2]), new Vector3D(v[0], v[1], v[2]));\n    }\n    /**\n     * Gets the state of the TLE in the TEME coordinate system.\n     * @returns The state of the TLE in the TEME coordinate system.\n     */\n    get state() {\n        return this.currentState_();\n    }\n    /**\n     * Calculates the Semi-Major Axis (SMA) from the second line of a TLE.\n     * @param line2 The second line of the TLE.\n     * @returns The Semi-Major Axis (SMA) in kilometers.\n     */\n    static tleSma_(line2) {\n        const n = parseFloat(line2.substring(52, 63));\n        return earthGravityParam ** (1 / 3) / ((TAU * n) / secondsPerDay) ** (2 / 3);\n    }\n    /**\n     * Parses the eccentricity value from the second line of a TLE.\n     * @param line2 The second line of the TLE.\n     * @returns The eccentricity value.\n     */\n    static tleEcc_(line2) {\n        return parseFloat(`0.${line2.substring(26, 33)}`);\n    }\n    /**\n     * Calculates the inclination angle from the second line of a TLE.\n     * @param line2 The second line of the TLE.\n     * @returns The inclination angle in radians.\n     */\n    static tleInc_(line2) {\n        return parseFloat(line2.substring(8, 16)) * DEG2RAD;\n    }\n    /**\n     * Creates a TLE (Two-Line Element) object from classical orbital elements.\n     * @param elements - The classical orbital elements.\n     * @returns A TLE object.\n     */\n    static fromClassicalElements(elements) {\n        const { epochYr, epochDay } = elements.epoch.toEpochYearAndDay();\n        const intl = '58001A  ';\n        const scc = '00001';\n        const tles = FormatTle.createTle({\n            inc: FormatTle.inclination(elements.inclinationDegrees),\n            meanmo: FormatTle.meanMotion(elements.revsPerDay),\n            ecen: FormatTle.eccentricity(elements.eccentricity.toFixed(7)),\n            argPe: FormatTle.argumentOfPerigee(elements.argPerigeeDegrees),\n            meana: FormatTle.meanAnomaly(newtonNu(elements.eccentricity, elements.trueAnomaly).m * RAD2DEG),\n            rasc: FormatTle.rightAscension(elements.rightAscensionDegrees),\n            epochday: epochDay,\n            epochyr: epochYr,\n            scc,\n            intl,\n        });\n        return new Tle(tles.tle1, tles.tle2);\n    }\n    /**\n     * Argument of perigee.\n     * @see https://en.wikipedia.org/wiki/Argument_of_perigee\n     * @example 69.9862\n     * @param tleLine2 The second line of the Tle to parse.\n     * @returns The argument of perigee in degrees (0 to 360).\n     */\n    static argOfPerigee(tleLine2) {\n        const argPe = parseFloat(tleLine2.substring(Tle.argPerigee_.start, Tle.argPerigee_.stop));\n        if (!(argPe >= 0 && argPe <= 360)) {\n            throw new Error(`Invalid argument of perigee: ${argPe}`);\n        }\n        return toPrecision(argPe, 4);\n    }\n    /**\n     * BSTAR drag term (decimal point assumed).  Estimates the effects of atmospheric drag on the satellite's motion.\n     * @see https://en.wikipedia.org/wiki/BSTAR\n     * @example 0.000036771\n     * @description ('36771-4' in the original Tle or 0.36771 * 10 ^ -4)\n     * @param tleLine1 The first line of the Tle to parse.\n     * @returns The drag coefficient.\n     */\n    static bstar(tleLine1) {\n        const BSTAR_PART_2 = Tle.bstar_.start + 1;\n        const BSTAR_PART_3 = Tle.bstar_.start + 6;\n        const BSTAR_PART_4 = Tle.bstar_.stop - 1;\n        const bstarSymbol = tleLine1.substring(Tle.bstar_.start, BSTAR_PART_2);\n        // Decimal place is assumed\n        let bstar1 = parseFloat(`0.${tleLine1.substring(BSTAR_PART_2, BSTAR_PART_3)}`);\n        const exponentSymbol = tleLine1.substring(BSTAR_PART_3, BSTAR_PART_4);\n        let exponent = parseInt(tleLine1.substring(BSTAR_PART_4, Tle.bstar_.stop));\n        if (exponentSymbol === '-') {\n            exponent *= -1;\n        }\n        else if (exponentSymbol !== '+') {\n            throw new Error(`Invalid BSTAR symbol: ${bstarSymbol}`);\n        }\n        bstar1 *= 10 ** exponent;\n        if (bstarSymbol === '-') {\n            bstar1 *= -1;\n        }\n        else if (bstarSymbol === '+' || bstarSymbol === ' ') {\n            // Do nothing\n        }\n        else {\n            throw new Error(`Invalid BSTAR symbol: ${bstarSymbol}`);\n        }\n        return toPrecision(bstar1, 14);\n    }\n    /**\n     * Tle line 1 checksum (modulo 10), for verifying the integrity of this line of the Tle.\n     * @example 3\n     * @param tleLine The first line of the Tle to parse.\n     * @returns The checksum value (0 to 9)\n     */\n    static checksum(tleLine) {\n        return parseInt(tleLine.substring(Tle.checksum_.start, Tle.checksum_.stop));\n    }\n    /**\n     * Returns the satellite classification.\n     * Some websites like https://KeepTrack.space and Celestrak.org will embed\n     * information in this field about the source of the Tle.\n     * @example 'U'\n     * unclassified\n     * @example 'C'\n     * confidential\n     * @example 'S'\n     * secret\n     * @param tleLine1 The first line of the Tle to parse.\n     * @returns The satellite classification.\n     */\n    static classification(tleLine1) {\n        return tleLine1.substring(Tle.classification_.start, Tle.classification_.stop);\n    }\n    /**\n     * Orbital eccentricity, decimal point assumed. All artificial Earth satellites have an eccentricity between 0\n     * (perfect circle) and 1 (parabolic orbit).\n     * @example 0.0006317\n     * (`0006317` in the original Tle)\n     * @param tleLine2 The second line of the Tle to parse.\n     * @returns The eccentricity of the satellite (0 to 1)\n     */\n    static eccentricity(tleLine2) {\n        const ecc = parseFloat(`0.${tleLine2.substring(Tle.eccentricity_.start, Tle.eccentricity_.stop)}`);\n        if (!(ecc >= 0 && ecc <= 1)) {\n            throw new Error(`Invalid eccentricity: ${ecc}`);\n        }\n        return toPrecision(ecc, 7);\n    }\n    /**\n     * Tle element set number, incremented for each new Tle generated.\n     * @see https://en.wikipedia.org/wiki/Two-line_element_set\n     * @example 999\n     * @param tleLine1 The first line of the Tle to parse.\n     * @returns The element number (1 to 999)\n     */\n    static elsetNum(tleLine1) {\n        return parseInt(tleLine1.substring(Tle.elsetNum_.start, Tle.elsetNum_.stop));\n    }\n    /**\n     * Private value - used by United States Space Force to reference the orbit model used to generate the Tle. Will\n     * always be seen as zero externally (e.g. by \"us\", unless you are \"them\" - in which case, hello!).\n     *\n     * Starting in 2024, this may contain a 4 if the Tle was generated using the new SGP4-XP model. Until the source code\n     * is released, there is no way to support that format in JavaScript or TypeScript.\n     * @example 0\n     * @param tleLine1 The first line of the Tle to parse.\n     * @returns The ephemeris type.\n     */\n    static ephemerisType(tleLine1) {\n        const ephemerisType = parseInt(tleLine1.substring(Tle.ephemerisType_.start, Tle.ephemerisType_.stop));\n        if (ephemerisType !== 0 && ephemerisType !== 4) {\n            throw new Error('Invalid ephemeris type');\n        }\n        if (ephemerisType === 4) {\n            throw new Error('SGP4-XP is not supported');\n        }\n        return ephemerisType;\n    }\n    /**\n     * Fractional day of the year when the Tle was generated (Tle epoch).\n     * @example 206.18396726\n     * @param tleLine1 The first line of the Tle to parse.\n     * @returns The day of the year the Tle was generated. (1 to 365.99999999)\n     */\n    static epochDay(tleLine1) {\n        const epochDay = parseFloat(tleLine1.substring(Tle.epochDay_.start, Tle.epochDay_.stop));\n        if (epochDay < 1 || epochDay > 366.99999999) {\n            throw new Error('Invalid epoch day');\n        }\n        return toPrecision(epochDay, 8);\n    }\n    /**\n     * Year when the Tle was generated (Tle epoch), last two digits.\n     * @example 17\n     * @param tleLine1 The first line of the Tle to parse.\n     * @returns The year the Tle was generated. (0 to 99)\n     */\n    static epochYear(tleLine1) {\n        const epochYear = parseInt(tleLine1.substring(Tle.epochYear_.start, Tle.epochYear_.stop));\n        if (epochYear < 0 || epochYear > 99) {\n            throw new Error('Invalid epoch year');\n        }\n        return epochYear;\n    }\n    /**\n     * Year when the Tle was generated (Tle epoch), four digits.\n     * @example 2008\n     * @param tleLine1 The first line of the Tle to parse.\n     * @returns The year the Tle was generated. (1957 to 2056)\n     */\n    static epochYearFull(tleLine1) {\n        const epochYear = parseInt(tleLine1.substring(Tle.epochYear_.start, Tle.epochYear_.stop));\n        if (epochYear < 0 || epochYear > 99) {\n            throw new Error('Invalid epoch year');\n        }\n        if (epochYear < 57) {\n            return epochYear + 2000;\n        }\n        return epochYear + 1900;\n    }\n    /**\n     * Inclination relative to the Earth's equatorial plane in degrees. 0 to 90 degrees is a prograde orbit and 90 to 180\n     * degrees is a retrograde orbit.\n     * @example 51.6400\n     * @param tleLine2 The second line of the Tle to parse.\n     * @returns The inclination of the satellite. (0 to 180)\n     */\n    static inclination(tleLine2) {\n        const inc = parseFloat(tleLine2.substring(Tle.inclination_.start, Tle.inclination_.stop));\n        if (inc < 0 || inc > 180) {\n            throw new Error(`Invalid inclination: ${inc}`);\n        }\n        return toPrecision(inc, 4);\n    }\n    /**\n     * International Designator (COSPAR ID)\n     * @see https://en.wikipedia.org/wiki/International_Designator\n     * @param tleLine1 The first line of the Tle to parse.\n     * @returns The International Designator.\n     */\n    static intlDes(tleLine1) {\n        const year2 = this.intlDesYear(tleLine1);\n        // Some TLEs don't have a year, so we can't generate an IntlDes\n        if (isNaN(year2)) {\n            return '';\n        }\n        const year4 = year2 < 57 ? year2 + 2000 : year2 + 1900;\n        const launchNum = this.intlDesLaunchNum(tleLine1);\n        const launchPiece = this.intlDesLaunchPiece(tleLine1);\n        return `${year4}-${launchNum.toString().padStart(3, '0')}${launchPiece}`;\n    }\n    /**\n     * International Designator (COSPAR ID): Launch number of the year.\n     * @example 67\n     * @param tleLine1 The first line of the Tle to parse.\n     * @returns The launch number of the International Designator. (1 to 999)\n     */\n    static intlDesLaunchNum(tleLine1) {\n        return parseInt(tleLine1.substring(Tle.intlDesLaunchNum_.start, Tle.intlDesLaunchNum_.stop));\n    }\n    /**\n     * International Designator  (COSPAR ID): Piece of the launch.\n     * @example 'A'\n     * @param tleLine1 The first line of the Tle to parse.\n     * @returns The launch piece of the International Designator. (A to ZZZ)\n     */\n    static intlDesLaunchPiece(tleLine1) {\n        return tleLine1.substring(Tle.intlDesLaunchPiece_.start, Tle.intlDesLaunchPiece_.stop).trim();\n    }\n    /**\n     * International Designator (COSPAR ID): Last 2 digits of launch year.\n     * @example 98\n     * @param tleLine1 The first line of the Tle to parse.\n     * @returns The year of the International Designator. (0 to 99)\n     */\n    static intlDesYear(tleLine1) {\n        return parseInt(tleLine1.substring(Tle.intlDesYear_.start, Tle.intlDesYear_.stop));\n    }\n    /**\n     * This should always return a 1 or a 2.\n     * @example 1\n     * @param tleLine The first line of the Tle to parse.\n     * @returns The line number of the Tle. (1 or 2)\n     */\n    static lineNumber(tleLine) {\n        const lineNum = parseInt(tleLine.substring(Tle.lineNumber_.start, Tle.lineNumber_.stop));\n        if (lineNum !== 1 && lineNum !== 2) {\n            throw new Error('Invalid line number');\n        }\n        return lineNum;\n    }\n    /**\n     * Mean anomaly. Indicates where the satellite was located within its orbit at the time of the Tle epoch.\n     * @see https://en.wikipedia.org/wiki/Mean_Anomaly\n     * @example 25.2906\n     * @param tleLine2 The second line of the Tle to parse.\n     * @returns The mean anomaly of the satellite. (0 to 360)\n     */\n    static meanAnomaly(tleLine2) {\n        const meanA = parseFloat(tleLine2.substring(Tle.meanAnom_.start, Tle.meanAnom_.stop));\n        if (!(meanA >= 0 && meanA <= 360)) {\n            throw new Error(`Invalid mean anomaly: ${meanA}`);\n        }\n        return toPrecision(meanA, 4);\n    }\n    /**\n     * First Time Derivative of the Mean Motion divided by two.  Defines how mean motion changes over time, so Tle\n     * propagators can still be used to make reasonable guesses when times are distant from the original Tle epoch. This\n     * is recorded in units of orbits per day per day.\n     * @example 0.00001961\n     * @param tleLine1 The first line of the Tle to parse.\n     * @returns The first derivative of the mean motion.\n     */\n    static meanMoDev1(tleLine1) {\n        const meanMoDev1 = parseFloat(tleLine1.substring(Tle.meanMoDev1_.start, Tle.meanMoDev1_.stop));\n        if (isNaN(meanMoDev1)) {\n            throw new Error('Invalid first derivative of mean motion.');\n        }\n        return toPrecision(meanMoDev1, 8);\n    }\n    /**\n     * Second Time Derivative of Mean Motion divided by six (decimal point assumed). Measures rate of change in the Mean\n     * Motion Dot so software can make reasonable guesses when times are distant from the original Tle epoch. Usually\n     * zero, unless the satellite is manuevering or in a decaying orbit. This is recorded in units of orbits per day per\n     * day per day.\n     * @example 0\n     * '00000-0' in the original Tle or 0.00000 * 10 ^ 0\n     * @param tleLine1 The first line of the Tle to parse.\n     * @returns The second derivative of the mean motion.\n     */\n    static meanMoDev2(tleLine1) {\n        const meanMoDev2 = parseFloat(tleLine1.substring(Tle.meanMoDev2_.start, Tle.meanMoDev2_.stop));\n        if (isNaN(meanMoDev2)) {\n            throw new Error('Invalid second derivative of mean motion.');\n        }\n        // NOTE: Should this limit to a specific number of decimals?\n        return meanMoDev2;\n    }\n    /**\n     * Revolutions around the Earth per day (mean motion).\n     * @see https://en.wikipedia.org/wiki/Mean_Motion\n     * @example 15.54225995\n     * @param tleLine2 The second line of the Tle to parse.\n     * @returns The mean motion of the satellite. (0 to 18)\n     */\n    static meanMotion(tleLine2) {\n        const meanMo = parseFloat(tleLine2.substring(Tle.meanMo_.start, Tle.meanMo_.stop));\n        if (!(meanMo > 0 && meanMo <= 18)) {\n            throw new Error(`Invalid mean motion: ${meanMo}`);\n        }\n        return toPrecision(meanMo, 8);\n    }\n    /**\n     * Calculates the period of a satellite orbit based on the given Tle line 2.\n     * @example 92.53035747\n     * @param tleLine2 The Tle line 2.\n     * @returns The period of the satellite orbit in minutes.\n     */\n    static period(tleLine2) {\n        const meanMo = Tle.meanMotion(tleLine2);\n        return (1440 / meanMo);\n    }\n    /**\n     * Right ascension of the ascending node in degrees. Essentially, this is the angle of the satellite as it crosses\n     * northward (ascending) across the Earth's equator (equatorial plane).\n     * @example 208.9163\n     * @param tleLine2 The second line of the Tle to parse.\n     * @returns The right ascension of the satellite. (0 to 360)\n     */\n    static rightAscension(tleLine2) {\n        const rightAscension = parseFloat(tleLine2.substring(Tle.rightAscension_.start, Tle.rightAscension_.stop));\n        if (!(rightAscension >= 0 && rightAscension <= 360)) {\n            throw new Error(`Invalid Right Ascension: ${rightAscension}`);\n        }\n        return toPrecision(rightAscension, 4);\n    }\n    /**\n     * NORAD catalog number. To support Alpha-5, the first digit can be a letter. This will NOT be converted to a number.\n     * Use satNum() for that.\n     * @see https://en.wikipedia.org/wiki/Satellite_Catalog_Number\n     * @example 25544\n     * @example B1234\n     * @param tleLine The first line of the Tle to parse.\n     * @returns NORAD catalog number.\n     */\n    static rawSatNum(tleLine) {\n        return tleLine.substring(Tle.satNum_.start, Tle.satNum_.stop);\n    }\n    /**\n     * Total satellite revolutions when this Tle was generated. This number rolls over (e.g. 99999 -> 0).\n     * @example 6766\n     * @param tleLine2 The second line of the Tle to parse.\n     * @returns The revolutions around the Earth per day (mean motion). (0 to 99999)\n     */\n    static revNum(tleLine2) {\n        return parseInt(tleLine2.substring(Tle.revNum_.start, Tle.revNum_.stop));\n    }\n    /**\n     * NORAD catalog number converted to a number.\n     * @see https://en.wikipedia.org/wiki/Satellite_Catalog_Number\n     * @example 25544\n     * @example 111234\n     * @param tleLine The first line of the Tle to parse.\n     * @returns NORAD catalog number. (0 to 339999)\n     */\n    static satNum(tleLine) {\n        const satNumStr = tleLine.substring(Tle.satNum_.start, Tle.satNum_.stop);\n        const sixDigitSatNum = Tle.convertA5to6Digit(satNumStr);\n        return parseInt(sixDigitSatNum);\n    }\n    /**\n     * Parse the first line of the Tle.\n     * @param tleLine1 The first line of the Tle to parse.\n     * @returns Returns the data from the first line of the Tle.\n     */\n    static parseLine1(tleLine1) {\n        const lineNumber1 = Tle.lineNumber(tleLine1);\n        const satNum = Tle.satNum(tleLine1);\n        const satNumRaw = Tle.rawSatNum(tleLine1);\n        const classification = Tle.classification(tleLine1);\n        const intlDes = Tle.intlDes(tleLine1);\n        const intlDesYear = Tle.intlDesYear(tleLine1);\n        const intlDesLaunchNum = Tle.intlDesLaunchNum(tleLine1);\n        const intlDesLaunchPiece = Tle.intlDesLaunchPiece(tleLine1);\n        const epochYear = Tle.epochYear(tleLine1);\n        const epochYearFull = Tle.epochYearFull(tleLine1);\n        const epochDay = Tle.epochDay(tleLine1);\n        const meanMoDev1 = Tle.meanMoDev1(tleLine1);\n        const meanMoDev2 = Tle.meanMoDev2(tleLine1);\n        const bstar = Tle.bstar(tleLine1);\n        const ephemerisType = Tle.ephemerisType(tleLine1);\n        const elsetNum = Tle.elsetNum(tleLine1);\n        const checksum1 = Tle.checksum(tleLine1);\n        return {\n            lineNumber1,\n            satNum,\n            satNumRaw,\n            classification,\n            intlDes,\n            intlDesYear,\n            intlDesLaunchNum,\n            intlDesLaunchPiece,\n            epochYear,\n            epochYearFull,\n            epochDay,\n            meanMoDev1,\n            meanMoDev2,\n            bstar,\n            ephemerisType,\n            elsetNum,\n            checksum1,\n        };\n    }\n    /**\n     * Parse the second line of the Tle.\n     * @param tleLine2 The second line of the Tle to parse.\n     * @returns Returns the data from the second line of the Tle.\n     */\n    static parseLine2(tleLine2) {\n        const lineNumber2 = Tle.lineNumber(tleLine2);\n        const satNum = Tle.satNum(tleLine2);\n        const satNumRaw = Tle.rawSatNum(tleLine2);\n        const inclination = Tle.inclination(tleLine2);\n        const rightAscension = Tle.rightAscension(tleLine2);\n        const eccentricity = Tle.eccentricity(tleLine2);\n        const argOfPerigee = Tle.argOfPerigee(tleLine2);\n        const meanAnomaly = Tle.meanAnomaly(tleLine2);\n        const meanMotion = Tle.meanMotion(tleLine2);\n        const revNum = Tle.revNum(tleLine2);\n        const checksum2 = Tle.checksum(tleLine2);\n        const period = Tle.period(tleLine2);\n        return {\n            lineNumber2,\n            satNum,\n            satNumRaw,\n            inclination,\n            rightAscension,\n            eccentricity,\n            argOfPerigee,\n            meanAnomaly,\n            meanMotion,\n            revNum,\n            checksum2,\n            period,\n        };\n    }\n    /**\n     * Parses the Tle into orbital data.\n     *\n     * If you want all of the data then use parseTleFull instead.\n     * @param tleLine1 Tle line 1\n     * @param tleLine2 Tle line 2\n     * @returns Returns most commonly used orbital data from Tle\n     */\n    static parse(tleLine1, tleLine2) {\n        const line1 = Tle.parseLine1(tleLine1);\n        const line2 = Tle.parseLine2(tleLine2);\n        if (line1.satNum !== line2.satNum) {\n            throw new Error('Satellite numbers do not match');\n        }\n        if (line1.satNumRaw !== line2.satNumRaw) {\n            throw new Error('Raw satellite numbers do not match');\n        }\n        if (line1.lineNumber1 !== 1) {\n            throw new Error('First line number must be 1');\n        }\n        if (line2.lineNumber2 !== 2) {\n            throw new Error('Second line number must be 2');\n        }\n        return {\n            satNum: line1.satNum,\n            intlDes: line1.intlDes,\n            epochYear: line1.epochYear,\n            epochDay: line1.epochDay,\n            meanMoDev1: line1.meanMoDev1,\n            meanMoDev2: line1.meanMoDev2,\n            bstar: line1.bstar,\n            inclination: line2.inclination,\n            rightAscension: line2.rightAscension,\n            eccentricity: line2.eccentricity,\n            argOfPerigee: line2.argOfPerigee,\n            meanAnomaly: line2.meanAnomaly,\n            meanMotion: line2.meanMotion,\n            period: line2.period,\n        };\n    }\n    /**\n     * Parses all of the data contained in the Tle.\n     *\n     * If you only want the most commonly used data then use parseTle instead.\n     * @param tleLine1 The first line of the Tle to parse.\n     * @param tleLine2 The second line of the Tle to parse.\n     * @returns Returns all of the data from the Tle.\n     */\n    static parseAll(tleLine1, tleLine2) {\n        const line1 = Tle.parseLine1(tleLine1);\n        const line2 = Tle.parseLine2(tleLine2);\n        if (line1.satNum !== line2.satNum) {\n            throw new Error('Satellite numbers do not match');\n        }\n        if (line1.satNumRaw !== line2.satNumRaw) {\n            throw new Error('Raw satellite numbers do not match');\n        }\n        if (line1.lineNumber1 !== 1) {\n            throw new Error('First line number must be 1');\n        }\n        if (line2.lineNumber2 !== 2) {\n            throw new Error('Second line number must be 2');\n        }\n        return { ...line1, ...line2 };\n    }\n    /**\n     * Converts a 6 digit SCC number to a 5 digit SCC alpha 5 number\n     * @param sccNum The 6 digit SCC number\n     * @returns The 5 digit SCC alpha 5 number\n     */\n    static convert6DigitToA5(sccNum) {\n        // Only applies to 6 digit numbers\n        if (sccNum.length < 6) {\n            return sccNum;\n        }\n        if (typeof sccNum[0] !== 'string') {\n            throw new Error('Invalid SCC number');\n        }\n        // Already an alpha 5 number\n        if (RegExp(/[A-Z]/iu, 'u').test(sccNum[0])) {\n            return sccNum;\n        }\n        // Extract the trailing 4 digits\n        const rest = sccNum.slice(2, 6);\n        /*\n         * Convert the first two digit numbers into a Letter. Skip I and O as they\n         * look too similar to 1 and 0 A=10, B=11, C=12, D=13, E=14, F=15, G=16,\n         * H=17, J=18, K=19, L=20, M=21, N=22, P=23, Q=24, R=25, S=26, T=27, U=28,\n         * V=29, W=30, X=31, Y=32, Z=33\n         */\n        let first = parseInt(`${sccNum[0]}${sccNum[1]}`);\n        const iPlus = first >= 18 ? 1 : 0;\n        const tPlus = first >= 24 ? 1 : 0;\n        first = first + iPlus + tPlus;\n        return `${String.fromCharCode(first + 55)}${rest}`;\n    }\n    /**\n     * Converts a 5-digit SCC number to a 6-digit SCC number.\n     * @param sccNum - The 5-digit SCC number to convert.\n     * @returns The converted 6-digit SCC number.\n     */\n    static convertA5to6Digit(sccNum) {\n        if (sccNum.length < 5) {\n            return sccNum;\n        }\n        const values = sccNum.toUpperCase().split('');\n        if (!values[0]) {\n            throw new Error('Invalid SCC number');\n        }\n        if (values[0] in Tle.alpha5_) {\n            const firstLetter = values[0];\n            values[0] = Tle.alpha5_[firstLetter];\n        }\n        return values.join('');\n    }\n}\n","export * from './ClassicalElements.js';\nexport * from './EquinoctialElements.js';\nexport * from './FormatTle.js';\nexport * from './Geodetic.js';\nexport * from './ITRF.js';\nexport * from './J2000.js';\nexport * from './RelativeState.js';\nexport * from './RIC.js';\nexport * from './StateVector.js';\nexport * from './TEME.js';\nexport * from './Tle.js';\nexport { Hill } from './Hill.js';\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * Represents the format data of a TLE (Two-Line Element) set. This is used to\n * make it easier to remember the starting and ending positions of the columns\n * containing the TLE data.\n */\nexport class TleFormatData {\n    /** The starting position of the TLE data in the source string. */\n    start;\n    /** The ending position of the TLE data in the source string. */\n    stop;\n    /** The length of the TLE data in the source string. */\n    length;\n    /**\n     * Creates a new instance of TleFormatData.\n     * @param start The starting position of the TLE data in the source string.\n     * @param end The ending position of the TLE data in the source string.\n     */\n    constructor(start, end) {\n        this.start = start - 1;\n        this.stop = end;\n        this.length = this.stop - this.start;\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\n/* eslint-disable class-methods-use-this */\nimport { ForceModel } from '../force/ForceModel.js';\nimport { J2000, Matrix, OrbitRegime, RelativeState, RIC, Tle, Vector, Vector3D, } from '../main.js';\nimport { RungeKutta89Propagator } from '../propagator/RungeKutta89Propagator.js';\nimport { CovarianceFrame, StateCovariance } from './StateCovariance.js';\n// / Sigma point covariance sample.\nexport class CovarianceSample {\n    origin_;\n    samples_ = [];\n    matrix_ = Matrix.zero(6, 12);\n    /**\n     * Create a new [CovarianceSample] object from an inertial state, covariance\n     * and optional force models for the origin state and samples.\n     *\n     * Two-body physics will be used if a force model is not provided.\n     * @param state The origin state.\n     * @param covariance The covariance.\n     * @param tle The TLE object.\n     * @param originForceModel The force model for the origin state.\n     * @param sampleForceModel The force model for the samples.\n     */\n    constructor(state, covariance, tle, originForceModel, sampleForceModel) {\n        originForceModel ??= new ForceModel().setGravity();\n        sampleForceModel ??= new ForceModel().setGravity();\n        // Scale covariance using TLE quality and regime aging factor if TLE info is provided\n        let scale = [1, 1, 1];\n        if (tle) {\n            const tleAgeDays = Tle.calcElsetAge(tle.line1, new Date(), 'days');\n            const quality = this.evaluateTleQuality(tle);\n            const aging = this.getRegimeAgingFactor(tle, tleAgeDays);\n            scale = [\n                quality[0] * aging[0],\n                quality[1] * aging[1],\n                quality[2] * aging[2],\n            ];\n        }\n        this.origin_ = new RungeKutta89Propagator(state, originForceModel);\n        const s = covariance.matrix.cholesky().elements;\n        const sqrt6 = Math.sqrt(6.0);\n        for (let i = 0; i < 6; i++) {\n            for (let j = 0; j < 6; j++) {\n                /*\n                 * Apply scale[0] to R, scale[1] to I, scale[2] to C (x, y, z)\n                 * Position: i = 0,1,2; Velocity: i = 3,4,5\n                 */\n                const scaleIdx = i % 3;\n                s[i][j] *= sqrt6 * scale[scaleIdx];\n            }\n        }\n        // 6 x 12 matrix\n        const sigmapts = Matrix.zero(6, 12).elements;\n        for (let i = 0; i < 6; i++) {\n            const jj = (i - 1) * 2 + 2;\n            for (let j = 0; j < 3; j++) {\n                sigmapts[j][jj] = s[j][i];\n                sigmapts[j + 3][jj] = s[j + 3][i];\n                sigmapts[j][jj + 1] = -s[j][i];\n                sigmapts[j + 3][jj + 1] = -s[j + 3][i];\n            }\n        }\n        for (let i = 0; i < 12; i++) {\n            const sampleR = new Vector3D(sigmapts[0][i], sigmapts[1][i], sigmapts[2][i]);\n            const sampleV = new Vector3D(sigmapts[3][i], sigmapts[4][i], sigmapts[5][i]);\n            if (covariance.frame === CovarianceFrame.ECI) {\n                const sample = new J2000(state.epoch, state.position.add(sampleR), state.velocity.add(sampleV));\n                this.samples_.push(new RungeKutta89Propagator(sample, sampleForceModel));\n            }\n            else if (covariance.frame === CovarianceFrame.RIC) {\n                const sample = new RIC(sampleR, sampleV).toJ2000(state);\n                this.samples_.push(new RungeKutta89Propagator(sample, sampleForceModel));\n            }\n        }\n    }\n    // / Current covariance sample epoch.\n    get epoch() {\n        return this.origin_.state.epoch;\n    }\n    // / Current covariance sample origin state.\n    get state() {\n        return this.origin_.state;\n    }\n    // / Rebuild covariance from sigma points.\n    _rebuildCovariance(matrix) {\n        const pts = matrix.elements;\n        const c = 1.0 / 12.0;\n        const yu = new Vector([0, 0, 0, 0, 0, 0]).elements;\n        const y = Matrix.zero(6, 12);\n        for (let i = 0; i < 12; i++) {\n            for (let j = 0; j < 6; j++) {\n                yu[j] += pts[j][i];\n            }\n        }\n        for (let j = 0; j < 6; j++) {\n            yu[j] *= c;\n        }\n        for (let i = 0; i < 12; i++) {\n            for (let j = 0; j < 6; j++) {\n                y.elements[j][i] = pts[j][i] - yu[j];\n            }\n        }\n        const yt = y.transpose();\n        const tmp = y.multiply(yt);\n        return tmp.scale(c);\n    }\n    // / Propagate covariance to a new epoch.\n    propagate(epoch) {\n        this.origin_.propagate(epoch);\n        for (const sample of this.samples_) {\n            sample.propagate(epoch);\n        }\n    }\n    // / Apply a maneuver to this covariance.\n    maneuver(maneuver) {\n        this.origin_.maneuver(maneuver);\n        for (const sample of this.samples_) {\n            sample.maneuver(maneuver);\n        }\n    }\n    // / Desample covariance in J2000 frame.\n    desampleJ2000() {\n        for (let i = 0; i < 12; i++) {\n            const state = this.samples_[i].state;\n            this.matrix_.elements[0][i] = state.position.x;\n            this.matrix_.elements[1][i] = state.position.y;\n            this.matrix_.elements[2][i] = state.position.z;\n            this.matrix_.elements[3][i] = state.velocity.x;\n            this.matrix_.elements[4][i] = state.velocity.y;\n            this.matrix_.elements[5][i] = state.velocity.z;\n        }\n        const matrix = this._rebuildCovariance(this.matrix_);\n        return new StateCovariance(matrix, CovarianceFrame.ECI);\n    }\n    // / Desample covariance in RIC frame.\n    desampleRIC() {\n        const rot = RelativeState.createMatrix(this.origin_.state.position, this.origin_.state.velocity);\n        for (let i = 0; i < 12; i++) {\n            const state = RIC.fromJ2000Matrix(this.samples_[i].state, this.origin_.state, rot);\n            this.matrix_.elements[0][i] = state.position.x;\n            this.matrix_.elements[1][i] = state.position.y;\n            this.matrix_.elements[2][i] = state.position.z;\n            this.matrix_.elements[3][i] = state.velocity.x;\n            this.matrix_.elements[4][i] = state.velocity.y;\n            this.matrix_.elements[5][i] = state.velocity.z;\n        }\n        const matrix = this._rebuildCovariance(this.matrix_);\n        return new StateCovariance(matrix, CovarianceFrame.RIC);\n    }\n    evaluateTleQuality(tle) {\n        let c = 1, i = 1, r = 1; // start with nominal 120 / 1000 / 100 m\n        /* ---- Meanâ€“motion first derivative (rev/dayÂ²) ---- */\n        const mm1 = Math.abs(Tle.meanMoDev1(tle.line1));\n        if (mm1 > 1e-3) { // clear manoeuvre or very low-drag orbit\n            i *= 3.0;\n            r *= 2.0;\n            c *= 1.2;\n        }\n        else if (mm1 > 1e-5) { // high drag but likely passive\n            i *= 1.6;\n            r *= 1.3;\n        }\n        /* ---- BSTAR drag term ---- */\n        const bstar = Math.abs(Tle.bstar(tle.line1));\n        if (bstar > 5e-4) { // <â‰ˆ400 km LEO\n            i *= 1.5;\n            r *= 1.5;\n            c *= 1.1;\n        }\n        else if (bstar > 1e-4) { // 400â€“600 km\n            i *= 1.2;\n            r *= 1.2;\n        }\n        /* ---- Eccentricity ---- */\n        const e = tle.eccentricity;\n        if (e > 0.05) { // HEO, GTO, cubesat transfer, etc.\n            r *= 1 + 6 * e;\n            i *= 1 + 4 * e;\n            c *= 1 + 1 * e;\n        }\n        else if (e > 0.02) { // mildly elliptical LEO/MEO\n            r *= 1 + 3 * e;\n            i *= 1 + 2 * e;\n        }\n        return [r, i, c];\n    }\n    getRegimeAgingFactor(tle, ageDays) {\n        const regime = tle.state.toClassicalElements().getOrbitRegime();\n        const t = Math.max(ageDays, 0) ** 1.5; // non-linear growth\n        switch (regime) {\n            case OrbitRegime.LEO:\n                // Target ~Ã—2 (R), Ã—3 (I), Ã—2.2 (C) after 1 day\n                return [1 + 1.0 * t, 1 + 2.0 * t, 1 + 1.2 * t];\n            case OrbitRegime.MEO:\n                // GNSS shells â€“ slower growth\n                return [1 + 0.4 * t, 1 + 0.9 * t, 1 + 0.6 * t];\n            case OrbitRegime.GEO:\n                return [1 + 0.2 * t, 1 + 0.5 * t, 1 + 0.3 * t];\n            case OrbitRegime.HEO:\n                // Highly elliptical transfer or Molniya\n                return [1 + 1.2 * t, 1 + 2.4 * t, 1 + 1.4 * t];\n            default:\n                return [1 + 0.6 * t, 1 + 1.2 * t, 1 + 0.8 * t];\n        }\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { Matrix, Vector } from '../main.js';\n/** Covariance Frame */\nexport var CovarianceFrame;\n(function (CovarianceFrame) {\n    /** Earth-centered inertial */\n    CovarianceFrame[\"ECI\"] = \"eci\";\n    /** Radial-Intrack-Crosstrack */\n    CovarianceFrame[\"RIC\"] = \"ric\";\n})(CovarianceFrame || (CovarianceFrame = {}));\n// / State covariance.\nexport class StateCovariance {\n    matrix;\n    frame;\n    /**\n     * Create a new [StateCovariance] object given its covariance [matrix] and\n     * [CovarianceFrame].\n     * @param matrix The covariance matrix.\n     * @param frame The covariance frame.\n     * @returns A new [StateCovariance] object.\n     */\n    constructor(matrix, frame) {\n        this.matrix = matrix;\n        this.frame = frame;\n        // Nothing to do here.\n    }\n    // / Create a new [StateCovariance] object from 1-sigma values.\n    static fromSigmas(sigmas, frame) {\n        const n = sigmas.length;\n        const output = Matrix.zero(n, n);\n        for (let i = 0; i < n; i++) {\n            output.elements[i][i] = Math.max(sigmas[i] * sigmas[i], 1e-32);\n        }\n        return new StateCovariance(output, frame);\n    }\n    /**\n     * Calculates the standard deviations (sigmas) of each element in the covariance matrix.\n     * @returns A vector containing the standard deviations of each element in the covariance matrix.\n     */\n    sigmas() {\n        const c = this.matrix.columns;\n        const result = new Float64Array(c);\n        for (let i = 0; i < c; i++) {\n            const variance = this.matrix.elements[i][i];\n            result[i] = Math.sqrt(variance);\n        }\n        return new Vector(result);\n    }\n}\n","export * from './CovarianceSample.js';\nexport * from './StateCovariance.js';\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { egm96Data } from './values/Egm96Data.js';\nimport { hpAtmosphereData } from './values/HpAtmosphereData.js';\nimport { iau1980Data } from './values/Iau1980Data.js';\nimport { leapSecondData } from './values/LeapSecondData.js';\n/**\n * Astrodynamic data management singleton.\n *\n * This class provides access to the various data sets used by the library.\n * It is a singleton class, and can be accessed via the static\n * [getInstance] method.\n */\nexport class DataHandler {\n    static instance_ = new DataHandler();\n    constructor() {\n        // Prevent instantiation.\n    }\n    /**\n     * Returns the singleton instance of the DataHandler class.\n     * @returns The singleton instance of the DataHandler class.\n     */\n    static getInstance() {\n        return DataHandler.instance_;\n    }\n    /**\n     * Retrieves the Egm96 coefficients for the given l and m values.\n     * @param l - The degree of the coefficient.\n     * @param m - The order of the coefficient.\n     * @returns The Egm96Entry object containing the coefficients.\n     */\n    getEgm96Coeffs(l, m) {\n        return egm96Data.getCoeffs(l, m);\n    }\n    /**\n     * Retrieves the IAU 1980 coefficients for the specified row.\n     * @param row The row index of the coefficients to retrieve.\n     * @returns The IAU 1980 entry containing the coefficients.\n     */\n    getIau1980Coeffs(row) {\n        return iau1980Data.getCoeffs(row);\n    }\n    /**\n     * Retrieves the number of leap seconds for a given Julian date.\n     * @param jd The Julian date.\n     * @returns The number of leap seconds.\n     */\n    getLeapSeconds(jd) {\n        return leapSecondData.getLeapSeconds(jd);\n    }\n    /**\n     * Retrieves the atmosphere data for a given height.\n     * @param height The height for which to retrieve the atmosphere data.\n     * @returns The atmosphere data for the given height, or null if no data is available.\n     */\n    getHpAtmosphere(height) {\n        return hpAtmosphereData.getAtmosphere(height);\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { factorial } from '../../utils/functions.js';\nimport { egm96 } from './egm96.js';\n// / Container for EGM-96 data.\nexport class Egm96Data {\n    coeffs_;\n    // / Create a new [Egm96Data] object.\n    constructor(coeffs) {\n        this.coeffs_ = coeffs;\n    }\n    /**\n     * Create a new [Egm96Data] container given a list of EGM-96\n     * coefficient tuples [vals].\n     * @param vals List of EGM-96 coefficient tuples.\n     * @returns A new [Egm96Data] object.\n     */\n    static fromVals(vals) {\n        const output = [];\n        for (const v of vals) {\n            const [l, m, clm, slm] = v;\n            const k = m === 0 ? 1 : 2;\n            const a = factorial(l + m);\n            const b = factorial(l - m) * (k * (2 * l + 1));\n            const nFac = Math.sqrt(a / b);\n            const normalizedClm = clm / nFac;\n            const normalizedSlm = slm / nFac;\n            output.push([l, m, normalizedClm, normalizedSlm]);\n        }\n        return new Egm96Data(output);\n    }\n    // / Return de-normalized EGM-96 coefficients for a given [l] and [m] index.\n    getCoeffs(l, m) {\n        return this.coeffs_[Egm96Data.index_(l, m)];\n    }\n    // / Return the EGM-96 index for a given [l] and [m] lookup.\n    static index_(l, m) {\n        return (((l - 2) * (l + 2) + l) >> 1) - 1 + m;\n    }\n}\n// / De-normalized EGM-96 data container.\nexport const egm96Data = Egm96Data.fromVals(egm96);\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { hpAtmosphere } from './hpAtmosphere.js';\nimport { HpAtmosphereResult } from './HpAtmosphereResult.js';\n// / Container for Harris-Priester atmosphere data.\nexport class HpAtmosphereData {\n    table_;\n    hMin_;\n    hMax_;\n    constructor(table) {\n        this.table_ = table;\n        if (table.length === 0 || typeof table[0]?.[0] === 'undefined') {\n            throw new Error('Table must have at least one valid entry.');\n        }\n        this.hMin_ = table[0][0];\n        this.hMax_ = table[table.length - 1]?.[0] ?? 0;\n    }\n    static fromVals(vals) {\n        const output = [];\n        for (const v of vals) {\n            const [h, minD, maxD] = v;\n            output.push([h, minD, maxD]);\n        }\n        return new HpAtmosphereData(output);\n    }\n    getAtmosphere(height) {\n        if (height < this.hMin_ || height > this.hMax_) {\n            return null;\n        }\n        let index = 0;\n        while (index < this.table_.length - 2 && height > (this.table_[index + 1])[0]) {\n            index++;\n        }\n        return new HpAtmosphereResult(height, (this.table_[index]), (this.table_[index + 1]));\n    }\n}\nexport const hpAtmosphereData = HpAtmosphereData.fromVals(hpAtmosphere);\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\n// / Harris-Priester atmospheric density bracket.\nexport class HpAtmosphereResult {\n    // / Height above Earth's surface _(km)_.\n    height;\n    // / Lower bound for atmospheric parameters.\n    hp0;\n    // / Upper bound for atmospheric parameters.\n    hp1;\n    // / Create a new [HpAtmosphereResult] object.\n    constructor(height, hp0, hp1) {\n        this.height = height;\n        this.hp0 = hp0;\n        this.hp1 = hp1;\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { iau1980 } from './iau1980.js';\n// / Container for IAU-1980 data.\nexport class Iau1980Data {\n    coeffs_;\n    // / Create a new [Iau1980Data] object.\n    constructor(coeffs) {\n        this.coeffs_ = coeffs;\n    }\n    /**\n     * Create a new [Iau1980Data] container object from an array of IAU-1980\n     * coefficient tuples [coeffs].\n     * @param coeffs IAU-1980 coefficients.\n     * @returns A new [Iau1980Data] object.\n     */\n    static fromCoeffs(coeffs) {\n        const output = [];\n        for (const c of coeffs) {\n            const [a1, a2, a3, a4, a5, ai, bi, ci, di] = c;\n            output.push([a1, a2, a3, a4, a5, ai, bi, ci, di]);\n        }\n        return new Iau1980Data(output);\n    }\n    // / Get IAU-1980 coefficients for a given row number.\n    getCoeffs(row) {\n        return this.coeffs_[row];\n    }\n}\n// / IAU-1980 data container.\nexport const iau1980Data = Iau1980Data.fromCoeffs(iau1980);\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\n// / Leap second data.\nexport class LeapSecond {\n    // / Julian date.\n    jd;\n    // / Offset seconds.\n    offset;\n    // / Create a new [LeapSecond] object.\n    constructor(jd, offset) {\n        this.jd = jd;\n        this.offset = offset;\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { LeapSecond } from './LeapSecond.js';\n// / Leap second value tuples.\nconst leapSeconds = [\n    [2441317.5, 10],\n    [2441499.5, 11],\n    [2441683.5, 12],\n    [2442048.5, 13],\n    [2442413.5, 14],\n    [2442778.5, 15],\n    [2443144.5, 16],\n    [2443509.5, 17],\n    [2443874.5, 18],\n    [2444239.5, 19],\n    [2444786.5, 20],\n    [2445151.5, 21],\n    [2445516.5, 22],\n    [2446247.5, 23],\n    [2447161.5, 24],\n    [2447892.5, 25],\n    [2448257.5, 26],\n    [2448804.5, 27],\n    [2449169.5, 28],\n    [2449534.5, 29],\n    [2450083.5, 30],\n    [2450630.5, 31],\n    [2451179.5, 32],\n    [2453736.5, 33],\n    [2454832.5, 34],\n    [2456109.5, 35],\n    [2457204.5, 36],\n    [2457754.5, 37],\n];\n// / Leap second data container.\nclass LeapSecondData {\n    offsets_;\n    jdFirst_;\n    jdLast_;\n    offsetFirst_;\n    offsetLast_;\n    constructor(offsets) {\n        this.offsets_ = offsets;\n        this.jdFirst_ = (this.offsets_[0]).jd;\n        this.jdLast_ = (this.offsets_[this.offsets_.length - 1]).jd;\n        this.offsetFirst_ = (this.offsets_[0]).offset;\n        this.offsetLast_ = (this.offsets_[this.offsets_.length - 1]).offset;\n    }\n    /**\n     * Create a new [LeapSecondData] container given a list of leap second\n     * value tuples [vals].\n     * @param vals Leap second value tuples.\n     * @returns A new [LeapSecondData] container.\n     */\n    static fromVals(vals) {\n        const output = [];\n        for (const v of vals) {\n            const [jd, offset] = v;\n            output.push(new LeapSecond(jd, offset));\n        }\n        return new LeapSecondData(output);\n    }\n    // / Return the number of leap seconds for a given Julian date [jd].\n    getLeapSeconds(jd) {\n        if (jd >= this.jdLast_) {\n            return this.offsetLast_;\n        }\n        if (jd <= this.jdFirst_) {\n            return this.offsetFirst_;\n        }\n        for (let i = 0; i < this.offsets_.length - 2; i++) {\n            const currentLeapSecond = this.offsets_[i];\n            const nextLeapSecond = this.offsets_[i + 1];\n            if (jd >= currentLeapSecond.jd && jd < nextLeapSecond.jd) {\n                return currentLeapSecond.offset;\n            }\n        }\n        return 0;\n    }\n}\n// / Leap second data container.\nexport const leapSecondData = LeapSecondData.fromVals(leapSeconds);\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\n// / The first degree 36 EGM-96 normalized coefficients.\nexport const egm96 = [\n    [2, 0, -0.000484165371736, 0],\n    [2, 1, -1.86987635955e-10, 1.19528012031e-9],\n    [2, 2, 0.00000243914352398, -0.00000140016683654],\n    [3, 0, 9.57254173792e-7, 0],\n    [3, 1, 0.00000202998882184, 2.48513158716e-7],\n    [3, 2, 9.04627768605e-7, -6.19025944205e-7],\n    [3, 3, 7.21072657057e-7, 0.00000141435626958],\n    [4, 0, 5.39873863789e-7, 0],\n    [4, 1, -5.36321616971e-7, -4.73440265853e-7],\n    [4, 2, 3.50694105785e-7, 6.6267157254e-7],\n    [4, 3, 9.90771803829e-7, -2.00928369177e-7],\n    [4, 4, -1.88560802735e-7, 3.08853169333e-7],\n    [5, 0, 6.8532347563e-8, 0],\n    [5, 1, -6.21012128528e-8, -9.44226127525e-8],\n    [5, 2, 6.52438297612e-7, -3.23349612668e-7],\n    [5, 3, -4.51955406071e-7, -2.14847190624e-7],\n    [5, 4, -2.95301647654e-7, 4.96658876769e-8],\n    [5, 5, 1.74971983203e-7, -6.69384278219e-7],\n    [6, 0, -1.49957994714e-7, 0],\n    [6, 1, -7.60879384947e-8, 2.62890545501e-8],\n    [6, 2, 4.81732442832e-8, -3.73728201347e-7],\n    [6, 3, 5.71730990516e-8, 9.02694517163e-9],\n    [6, 4, -8.62142660109e-8, -4.71408154267e-7],\n    [6, 5, -2.6713332549e-7, -5.36488432483e-7],\n    [6, 6, 9.67616121092e-9, -2.37192006935e-7],\n    [7, 0, 9.0978937145e-8, 0],\n    [7, 1, 2.79872910488e-7, 9.54336911867e-8],\n    [7, 2, 3.29743816488e-7, 9.30667596042e-8],\n    [7, 3, 2.50398657706e-7, -2.17198608738e-7],\n    [7, 4, -2.75114355257e-7, -1.23800392323e-7],\n    [7, 5, 1.93765507243e-9, 1.77377719872e-8],\n    [7, 6, -3.58856860645e-7, 1.51789817739e-7],\n    [7, 7, 1.09185148045e-9, 2.44415707993e-8],\n    [8, 0, 4.96711667324e-8, 0],\n    [8, 1, 2.33422047893e-8, 5.90060493411e-8],\n    [8, 2, 8.02978722615e-8, 6.54175425859e-8],\n    [8, 3, -1.91877757009e-8, -8.63454445021e-8],\n    [8, 4, -2.44600105471e-7, 7.00233016934e-8],\n    [8, 5, -2.55352403037e-8, 8.91462164788e-8],\n    [8, 6, -6.57361610961e-8, 3.09238461807e-7],\n    [8, 7, 6.72811580072e-8, 7.47440473633e-8],\n    [8, 8, -1.24092493016e-7, 1.20533165603e-7],\n    [9, 0, 2.76714300853e-8, 0],\n    [9, 1, 1.43387502749e-7, 2.16834947618e-8],\n    [9, 2, 2.22288318564e-8, -3.22196647116e-8],\n    [9, 3, -1.60811502143e-7, -7.42287409462e-8],\n    [9, 4, -9.00179225336e-9, 1.94666779475e-8],\n    [9, 5, -1.66165092924e-8, -5.41113191483e-8],\n    [9, 6, 6.26941938248e-8, 2.22903525945e-7],\n    [9, 7, -1.18366323475e-7, -9.65152667886e-8],\n    [9, 8, 1.88436022794e-7, -3.08566220421e-9],\n    [9, 9, -4.77475386132e-8, 9.66412847714e-8],\n    [10, 0, 5.26222488569e-8, 0],\n    [10, 1, 8.35115775652e-8, -1.31314331796e-7],\n    [10, 2, -9.42413882081e-8, -5.1579165739e-8],\n    [10, 3, -6.89895048176e-9, -1.53768828694e-7],\n    [10, 4, -8.40764549716e-8, -7.92806255331e-8],\n    [10, 5, -4.93395938185e-8, -5.05370221897e-8],\n    [10, 6, -3.75885236598e-8, -7.95667053872e-8],\n    [10, 7, 8.11460540925e-9, -3.36629641314e-9],\n    [10, 8, 4.04927981694e-8, -9.18705975922e-8],\n    [10, 9, 1.25491334939e-7, -3.76516222392e-8],\n    [10, 10, 1.00538634409e-7, -2.4014844952e-8],\n    [11, 0, -5.09613707522e-8, 0],\n    [11, 1, 1.51687209933e-8, -2.68604146166e-8],\n    [11, 2, 1.86309749878e-8, -9.90693862047e-8],\n    [11, 3, -3.09871239854e-8, -1.4813180426e-7],\n    [11, 4, -3.89580205051e-8, -6.3666651198e-8],\n    [11, 5, 3.77848029452e-8, 4.94736238169e-8],\n    [11, 6, -1.18676592395e-9, 3.44769584593e-8],\n    [11, 7, 4.11565188074e-9, -8.98252808977e-8],\n    [11, 8, -5.984108413e-9, 2.43989612237e-8],\n    [11, 9, -3.14231072723e-8, 4.17731829829e-8],\n    [11, 10, -5.21882681927e-8, -1.83364561788e-8],\n    [11, 11, 4.60344448746e-8, -6.96662308185e-8],\n    [12, 0, 3.77252636558e-8, 0],\n    [12, 1, -5.40654977836e-8, -4.35675748979e-8],\n    [12, 2, 1.42979642253e-8, 3.20975937619e-8],\n    [12, 3, 3.93995876403e-8, 2.44264863505e-8],\n    [12, 4, -6.86908127934e-8, 4.15081109011e-9],\n    [12, 5, 3.0941112873e-8, 7.82536279033e-9],\n    [12, 6, 3.41523275208e-9, 3.91765484449e-8],\n    [12, 7, -1.86909958587e-8, 3.56131849382e-8],\n    [12, 8, -2.53769398865e-8, 1.69361024629e-8],\n    [12, 9, 4.22880630662e-8, 2.52692598301e-8],\n    [12, 10, -6.17619654902e-9, 3.08375794212e-8],\n    [12, 11, 1.12502994122e-8, -6.37946501558e-9],\n    [12, 12, -2.4953260739e-9, -1.117806019e-8],\n    [13, 0, 4.22982206413e-8, 0],\n    [13, 1, -5.13569699124e-8, 3.90510386685e-8],\n    [13, 2, 5.59217667099e-8, -6.27337565381e-8],\n    [13, 3, -2.19360927945e-8, 9.74829362237e-8],\n    [13, 4, -3.13762599666e-9, -1.19627874492e-8],\n    [13, 5, 5.90049394905e-8, 6.64975958036e-8],\n    [13, 6, -3.59038073075e-8, -6.57280613686e-9],\n    [13, 7, 2.53002147087e-9, -6.21470822331e-9],\n    [13, 8, -9.83150822695e-9, -1.04740222825e-8],\n    [13, 9, 2.47325771791e-8, 4.52870369936e-8],\n    [13, 10, 4.1032465393e-8, -3.6812102948e-8],\n    [13, 11, -4.43869677399e-8, -4.76507804288e-9],\n    [13, 12, -3.12622200222e-8, 8.78405809267e-8],\n    [13, 13, -6.12759553199e-8, 6.85261488594e-8],\n    [14, 0, -2.42786502921e-8, 0],\n    [14, 1, -1.86968616381e-8, 2.94747542249e-8],\n    [14, 2, -3.67789379502e-8, -5.16779392055e-9],\n    [14, 3, 3.58875097333e-8, 2.04618827833e-8],\n    [14, 4, 1.83865617792e-9, -2.26780613566e-8],\n    [14, 5, 2.87344273542e-8, -1.63882249728e-8],\n    [14, 6, -1.94810485574e-8, 2.47831272781e-9],\n    [14, 7, 3.75003839415e-8, -4.17291319429e-9],\n    [14, 8, -3.50946485865e-8, -1.53515265203e-8],\n    [14, 9, 3.20284939341e-8, 2.88804922064e-8],\n    [14, 10, 3.90329180008e-8, -1.44308452469e-9],\n    [14, 11, 1.53970516502e-8, -3.90548173245e-8],\n    [14, 12, 8.40829163869e-9, -3.11327189117e-8],\n    [14, 13, 3.22147043964e-8, 4.5189722496e-8],\n    [14, 14, -5.18980794309e-8, -4.81506636748e-9],\n    [15, 0, 1.47910068708e-9, 0],\n    [15, 1, 1.00817268177e-8, 1.09773066324e-8],\n    [15, 2, -2.13942673775e-8, -3.08914875777e-8],\n    [15, 3, 5.21392929041e-8, 1.72892926103e-8],\n    [15, 4, -4.08150084078e-8, 6.50174707794e-9],\n    [15, 5, 1.24935723108e-8, 8.08375563996e-9],\n    [15, 6, 3.31211643896e-8, -3.68246004304e-8],\n    [15, 7, 5.96210699259e-8, 5.31841171879e-9],\n    [15, 8, -3.22428691498e-8, 2.21523579587e-8],\n    [15, 9, 1.28788268085e-8, 3.75629820829e-8],\n    [15, 10, 1.04688722521e-8, 1.47222147015e-8],\n    [15, 11, -1.11675061934e-9, 1.80996198432e-8],\n    [15, 12, -3.23962134415e-8, 1.55243104746e-8],\n    [15, 13, -2.83933019117e-8, -4.22066791103e-9],\n    [15, 14, 5.1916885933e-9, -2.43752739666e-8],\n    [15, 15, -1.90930538322e-8, -4.71139421558e-9],\n    [16, 0, -3.15322986722e-9, 0],\n    [16, 1, 2.58360856231e-8, 3.25447560859e-8],\n    [16, 2, -2.33671404512e-8, 2.88799363439e-8],\n    [16, 3, -3.36019429391e-8, -2.2041898801e-8],\n    [16, 4, 4.02316284314e-8, 4.83837716909e-8],\n    [16, 5, -1.29501939245e-8, -3.19458578129e-9],\n    [16, 6, 1.40239252323e-8, -3.50760208303e-8],\n    [16, 7, -7.08412635136e-9, -8.81581561131e-9],\n    [16, 8, -2.09018868094e-8, 5.0052739053e-9],\n    [16, 9, -2.18588720643e-8, -3.95012419994e-8],\n    [16, 10, -1.17529900814e-8, 1.14211582961e-8],\n    [16, 11, 1.87574042592e-8, -3.03161919925e-9],\n    [16, 12, 1.95400194038e-8, 6.66983574071e-9],\n    [16, 13, 1.38196369576e-8, 1.02778499508e-9],\n    [16, 14, -1.93182168856e-8, -3.86174893776e-8],\n    [16, 15, -1.45149060142e-8, -3.27443078739e-8],\n    [16, 16, -3.79671710746e-8, 3.02155372655e-9],\n    [17, 0, 1.97605066395e-8, 0],\n    [17, 1, -2.54177575118e-8, -3.06630529689e-8],\n    [17, 2, -1.95988656721e-8, 6.4926589341e-9],\n    [17, 3, 5.64123066224e-9, 6.78327095529e-9],\n    [17, 4, 7.07457075637e-9, 2.49437600834e-8],\n    [17, 5, -1.54987006052e-8, 6.60021551851e-9],\n    [17, 6, -1.18194012847e-8, -2.89770975177e-8],\n    [17, 7, 2.42149702381e-8, -4.22222973697e-9],\n    [17, 8, 3.88442097559e-8, 3.58904095943e-9],\n    [17, 9, 3.81356493231e-9, -2.81466943714e-8],\n    [17, 10, -3.88216085542e-9, 1.81328176508e-8],\n    [17, 11, -1.57356600363e-8, 1.06560649404e-8],\n    [17, 12, 2.88013010655e-8, 2.03450136084e-8],\n    [17, 13, 1.65503425731e-8, 2.04667531435e-8],\n    [17, 14, -1.41983872649e-8, 1.14948025244e-8],\n    [17, 15, 5.42100361657e-9, 5.32610369811e-9],\n    [17, 16, -3.01992205043e-8, 3.65331918531e-9],\n    [17, 17, -3.43086856041e-8, -1.98523455381e-8],\n    [18, 0, 5.08691038332e-9, 0],\n    [18, 1, 7.21098449649e-9, -3.88714473013e-8],\n    [18, 2, 1.40631771205e-8, 1.00093396253e-8],\n    [18, 3, -5.07232520873e-9, -4.90865931335e-9],\n    [18, 4, 5.48759308217e-8, -1.3526711772e-9],\n    [18, 5, 5.48710485555e-9, 2.64338629459e-8],\n    [18, 6, 1.46570755271e-8, -1.36438019951e-8],\n    [18, 7, 6.75812328417e-9, 6.88577494235e-9],\n    [18, 8, 3.07619845144e-8, 4.17827734107e-9],\n    [18, 9, -1.8847060188e-8, 3.68302736953e-8],\n    [18, 10, 5.27535358934e-9, -4.66091535881e-9],\n    [18, 11, -7.2962851896e-9, 1.9521520802e-9],\n    [18, 12, -2.97449412422e-8, -1.64497878395e-8],\n    [18, 13, -6.27919717152e-9, -3.48383939938e-8],\n    [18, 14, -8.1560533641e-9, -1.28636585027e-8],\n    [18, 15, -4.05003412879e-8, -2.02684998021e-8],\n    [18, 16, 1.04141042028e-8, 6.61468817624e-9],\n    [18, 17, 3.58771586841e-9, 4.48065587564e-9],\n    [18, 18, 3.12351953717e-9, -1.09906032543e-8],\n    [19, 0, -3.25780965394e-9, 0],\n    [19, 1, -7.59903885319e-9, 1.26835472605e-9],\n    [19, 2, 3.53541528655e-8, -1.31346303514e-9],\n    [19, 3, -9.74103607309e-9, 1.50662259043e-9],\n    [19, 4, 1.57039009057e-8, -7.61677383811e-9],\n    [19, 5, 1.09629213379e-8, 2.83172176438e-8],\n    [19, 6, -4.08745178658e-9, 1.86219430719e-8],\n    [19, 7, 4.78275337044e-9, -7.172834559e-9],\n    [19, 8, 2.9490836428e-8, -9.93037002883e-9],\n    [19, 9, 3.07961427159e-9, 6.94110477214e-9],\n    [19, 10, -3.38415069043e-8, -7.37981767136e-9],\n    [19, 11, 1.60443652916e-8, 9.96673453483e-9],\n    [19, 12, -2.47106581581e-9, 9.16852310642e-9],\n    [19, 13, -7.4471737998e-9, -2.82584466742e-8],\n    [19, 14, -4.70502589215e-9, -1.29526697983e-8],\n    [19, 15, -1.76580549771e-8, -1.40350990039e-8],\n    [19, 16, -2.16950096188e-8, -7.24534721567e-9],\n    [19, 17, 2.90444936079e-8, -1.5345653107e-8],\n    [19, 18, 3.48382199593e-8, -9.54146344917e-9],\n    [19, 19, -2.5734934943e-9, 4.83151822363e-9],\n    [20, 0, 2.22384610651e-8, 0],\n    [20, 1, 5.16303125218e-9, 6.69626726966e-9],\n    [20, 2, 1.98831128238e-8, 1.75183843257e-8],\n    [20, 3, -3.62601436785e-9, 3.79590724141e-8],\n    [20, 4, 2.42238118652e-9, -2.11057611874e-8],\n    [20, 5, -1.07042562564e-8, -7.71860083169e-9],\n    [20, 6, 1.1047483757e-8, -2.17720365898e-9],\n    [20, 7, -2.10090282728e-8, -2.23491503969e-11],\n    [20, 8, 4.42419185637e-9, 1.83035804593e-9],\n    [20, 9, 1.78846216942e-8, -6.63940865358e-9],\n    [20, 10, -3.25394919988e-8, -5.12308873621e-9],\n    [20, 11, 1.38992707697e-8, -1.87706454942e-8],\n    [20, 12, -6.3575060075e-9, 1.80260853103e-8],\n    [20, 13, 2.75222725997e-8, 6.90887077588e-9],\n    [20, 14, 1.15841169405e-8, -1.43176160143e-8],\n    [20, 15, -2.60130744291e-8, -7.84379672413e-10],\n    [20, 16, -1.24137147118e-8, -2.77500443628e-10],\n    [20, 17, 4.3690966796e-9, -1.37420446198e-8],\n    [20, 18, 1.51842883022e-8, -8.08429903142e-10],\n    [20, 19, -3.14942002852e-9, 1.06505202245e-8],\n    [20, 20, 4.01448327968e-9, -1.20450644785e-8],\n    [21, 0, 5.87820252575e-9, 0],\n    [21, 1, -1.61000670141e-8, 2.84359400791e-8],\n    [21, 2, -6.54460482558e-9, 3.78474868508e-9],\n    [21, 3, 1.9549199526e-8, 2.26286963716e-8],\n    [21, 4, -5.76604339239e-9, 1.94493782631e-8],\n    [21, 5, 2.58856303016e-9, 1.70850368669e-9],\n    [21, 6, -1.40168810589e-8, -2.73814826381e-12],\n    [21, 7, -8.64357168475e-9, 4.42612277119e-9],\n    [21, 8, -1.70477278237e-8, 1.5071119263e-9],\n    [21, 9, 1.64489062394e-8, 8.30113196365e-9],\n    [21, 10, -1.09928976409e-8, -1.46913794684e-9],\n    [21, 11, 6.99300364214e-9, -3.53590565124e-8],\n    [21, 12, -3.19300109594e-9, 1.45786917947e-8],\n    [21, 13, -1.8985452459e-8, 1.40514791436e-8],\n    [21, 14, 2.03580785674e-8, 7.5577246284e-9],\n    [21, 15, 1.75530220278e-8, 1.04533886832e-8],\n    [21, 16, 7.86969109367e-9, -6.56089715279e-9],\n    [21, 17, -6.99484489981e-9, -7.36064901147e-9],\n    [21, 18, 2.59643291521e-8, -1.1156080613e-8],\n    [21, 19, -2.7374163641e-8, 1.63958190052e-8],\n    [21, 20, -2.68682473584e-8, 1.62086057168e-8],\n    [21, 21, 8.30374873932e-9, -3.75546121742e-9],\n    [22, 0, -1.13735124259e-8, 0],\n    [22, 1, 1.62309865679e-8, -3.77303475153e-9],\n    [22, 2, -2.64090261387e-8, -2.10832402428e-9],\n    [22, 3, 1.1658001654e-8, 1.06764617222e-8],\n    [22, 4, -2.70979141451e-9, 1.74980820565e-8],\n    [22, 5, -1.8645262501e-9, 7.44718166476e-10],\n    [22, 6, 9.64390704406e-9, -6.37316743908e-9],\n    [22, 7, 1.59715981795e-8, 4.39600942993e-9],\n    [22, 8, -2.35157426998e-8, 4.83673695086e-9],\n    [22, 9, 8.29435796737e-9, 8.73382159986e-9],\n    [22, 10, 6.00704037701e-9, 2.21854121109e-8],\n    [22, 11, -4.96078301539e-9, -1.78822672474e-8],\n    [22, 12, 2.13502315463e-9, -7.96120522503e-9],\n    [22, 13, -1.72631843979e-8, 1.97026896892e-8],\n    [22, 14, 1.09297133018e-8, 8.25280905301e-9],\n    [22, 15, 2.58410840629e-8, 4.60172998318e-9],\n    [22, 16, 1.41258558921e-10, -7.182380053e-9],\n    [22, 17, 8.89294096846e-9, -1.45618348246e-8],\n    [22, 18, 1.05047447464e-8, -1.64271275481e-8],\n    [22, 19, 1.41305509124e-8, -3.84537168599e-9],\n    [22, 20, -1.67617655441e-8, 1.99561513321e-8],\n    [22, 21, -2.50948756455e-8, 2.36151346133e-8],\n    [22, 22, -9.59596694809e-9, 2.49861413883e-9],\n    [23, 0, -2.26201075082e-8, 0],\n    [23, 1, 1.10870239758e-8, 1.6137915153e-8],\n    [23, 2, -1.35191027779e-8, -5.01411714852e-9],\n    [23, 3, -2.45128011445e-8, -1.60570438998e-8],\n    [23, 4, -2.39887874558e-8, 7.31536362289e-9],\n    [23, 5, 7.99636624146e-10, -1.6144974141e-10],\n    [23, 6, -1.26082781309e-8, 1.61308155632e-8],\n    [23, 7, -8.04132133762e-9, -1.11647197494e-9],\n    [23, 8, 7.53785326469e-9, -3.2967992522e-10],\n    [23, 9, 2.5505325495e-9, -1.28071525548e-8],\n    [23, 10, 1.65167929134e-8, -1.85239620853e-9],\n    [23, 11, 9.42656822725e-9, 1.52386181583e-8],\n    [23, 12, 1.63632625535e-8, -1.24098327824e-8],\n    [23, 13, -1.15107832808e-8, -4.84279171627e-9],\n    [23, 14, 6.75321602206e-9, -1.82899962212e-9],\n    [23, 15, 1.8689804286e-8, -3.60523754481e-9],\n    [23, 16, 6.13840121864e-9, 1.10362707266e-8],\n    [23, 17, -5.5372102391e-9, -1.2845906046e-8],\n    [23, 18, 8.43361263813e-9, -1.49115921605e-8],\n    [23, 19, -5.20848228342e-9, 1.07789593943e-8],\n    [23, 20, 8.60434396837e-9, -5.34641639372e-9],\n    [23, 21, 1.54578189867e-8, 1.15333325358e-8],\n    [23, 22, -1.78417206471e-8, 4.33092348903e-9],\n    [23, 23, 2.85393980111e-9, -1.1323294597e-8],\n    [24, 0, 7.63657386411e-10, 0],\n    [24, 1, -3.14943681427e-9, -1.77191190396e-9],\n    [24, 2, 1.38595572093e-9, 1.711040664e-8],\n    [24, 3, -4.76406913528e-9, -9.42329378125e-9],\n    [24, 4, 6.05108036341e-9, 5.49769910191e-9],\n    [24, 5, -7.2947904748e-9, -2.13826490504e-8],\n    [24, 6, 4.54210367535e-9, 1.85596665318e-9],\n    [24, 7, -6.14244489298e-9, 4.70081667951e-9],\n    [24, 8, 1.54822444425e-8, -4.34472097787e-9],\n    [24, 9, -9.76623425797e-9, -1.6275513762e-8],\n    [24, 10, 1.08934628974e-8, 2.09168783608e-8],\n    [24, 11, 1.45280775337e-8, 1.87398018797e-8],\n    [24, 12, 1.18970310717e-8, -6.2293309815e-9],\n    [24, 13, -2.89676673058e-9, 3.13251295024e-9],\n    [24, 14, -2.00006558603e-8, -1.87249636821e-9],\n    [24, 15, 6.10396350698e-9, -1.58957680563e-8],\n    [24, 16, 8.88750753375e-9, 2.96492703352e-9],\n    [24, 17, -1.19629964611e-8, -5.82074593955e-9],\n    [24, 18, -6.52630641555e-10, -1.01332355837e-8],\n    [24, 19, -4.38896550264e-9, -8.14552569977e-9],\n    [24, 20, -5.17551981851e-9, 8.90354942378e-9],\n    [24, 21, 6.03436755046e-9, 1.40116090741e-8],\n    [24, 22, 3.93640283055e-9, -4.28327655754e-9],\n    [24, 23, -6.1428347955e-9, -8.692679021e-9],\n    [24, 24, 1.23903921309e-8, -3.75059286959e-9],\n    [25, 0, 3.21309208115e-9, 0],\n    [25, 1, 6.89649208567e-9, -7.995518294e-9],\n    [25, 2, 2.19498139173e-8, 9.01370249111e-9],\n    [25, 3, -1.17774931587e-8, -1.26719024392e-8],\n    [25, 4, 9.4254362892e-9, 6.84937199311e-10],\n    [25, 5, -1.00497487339e-8, -9.2212239967e-10],\n    [25, 6, 1.66832871654e-8, 4.30583576199e-10],\n    [25, 7, 7.71426681671e-9, -4.11703290425e-9],\n    [25, 8, 3.1565194415e-9, -7.81960217669e-10],\n    [25, 9, -2.99385350515e-8, 2.12695473199e-8],\n    [25, 10, 8.81931818034e-9, -4.18041586166e-9],\n    [25, 11, 1.2340148568e-9, 1.08069128123e-8],\n    [25, 12, -7.65146786755e-9, 1.1747374286e-8],\n    [25, 13, 8.32308127158e-9, -1.13072604626e-8],\n    [25, 14, -1.97042124794e-8, 6.53183488635e-9],\n    [25, 15, -4.35732052985e-9, -7.35147227573e-9],\n    [25, 16, 9.18239548455e-10, -1.28124888592e-8],\n    [25, 17, -1.52176535379e-8, -3.21280397924e-9],\n    [25, 18, 1.21901534245e-9, -1.49040483259e-8],\n    [25, 19, 7.77589111757e-9, 9.92518771941e-9],\n    [25, 20, -7.50856670672e-9, -5.62826155305e-10],\n    [25, 21, 1.0723284068e-8, 8.16090174381e-9],\n    [25, 22, -1.39902235929e-8, 3.58546198324e-9],\n    [25, 23, 8.40270853655e-9, -1.23338407961e-8],\n    [25, 24, 4.12447134569e-9, -8.30716465317e-9],\n    [25, 25, 1.07484366767e-8, 4.72369913984e-9],\n    [26, 0, 5.05833635414e-9, 0],\n    [26, 1, -1.54756177965e-9, -7.70012788871e-9],\n    [26, 2, -3.58729876836e-9, 1.14484111182e-8],\n    [26, 3, 1.40505671267e-8, 4.30905534294e-9],\n    [26, 4, 1.90548709216e-8, -1.94161179658e-8],\n    [26, 5, 1.07190025408e-8, 9.08952851813e-9],\n    [26, 6, 1.13116909406e-8, -9.34393384449e-9],\n    [26, 7, -1.562282956e-9, 4.81168302477e-9],\n    [26, 8, 3.94920146317e-9, 1.153405253e-9],\n    [26, 9, -1.20371433638e-8, 4.75177058134e-10],\n    [26, 10, -1.41246124334e-8, -6.45217247294e-9],\n    [26, 11, -5.20385857649e-9, 2.12443340407e-9],\n    [26, 12, -1.75071176484e-8, 2.01974971938e-9],\n    [26, 13, -3.35708835245e-11, 1.50474091686e-9],\n    [26, 14, 7.96385051492e-9, 7.84704068835e-9],\n    [26, 15, -1.32388781089e-8, 8.03960091442e-9],\n    [26, 16, 1.29093226253e-9, -6.11434455706e-9],\n    [26, 17, -1.24494157564e-8, 7.8077484564e-9],\n    [26, 18, -1.30317424459e-8, 4.9998916257e-9],\n    [26, 19, -2.05807464595e-9, 3.54396135438e-9],\n    [26, 20, 6.55952144018e-9, -1.1687804118e-8],\n    [26, 21, -8.70038868454e-9, 1.68222257564e-9],\n    [26, 22, 1.01580452049e-8, 7.54358531576e-9],\n    [26, 23, 1.24105057436e-9, 1.08580088935e-8],\n    [26, 24, 8.58620351967e-9, 1.48288510099e-8],\n    [26, 25, 3.93441578873e-9, -5.97792415806e-10],\n    [26, 26, 3.93179749568e-10, 1.93894997772e-9],\n    [27, 0, 2.7717632236e-9, 0],\n    [27, 1, 2.48982909452e-9, 3.77378455357e-9],\n    [27, 2, 1.45270146453e-9, 5.03113268026e-10],\n    [27, 3, -3.62306812856e-10, 1.088457625e-8],\n    [27, 4, -5.99191537157e-10, 9.40517681233e-9],\n    [27, 5, 1.67690560888e-8, 1.38338587209e-8],\n    [27, 6, 3.64265989803e-9, 6.13032807744e-9],\n    [27, 7, -1.23459266009e-8, -3.86514075952e-9],\n    [27, 8, -6.1040764482e-9, -8.99504471581e-9],\n    [27, 9, 3.40113157078e-9, 1.10992938665e-8],\n    [27, 10, -1.33158893187e-8, 1.72832279915e-10],\n    [27, 11, 1.98322808107e-9, -9.69054254426e-9],\n    [27, 12, -1.13695413044e-8, 1.90072943781e-9],\n    [27, 13, -4.97224781272e-9, -4.14521559996e-9],\n    [27, 14, 1.55033957088e-8, 1.1882128969e-8],\n    [27, 15, -1.80057326196e-9, 1.1763698622e-9],\n    [27, 16, 2.7572995289e-9, 2.78770269194e-9],\n    [27, 17, 3.79281571763e-9, 3.14983101049e-10],\n    [27, 18, -2.87144071715e-9, 7.44190558718e-9],\n    [27, 19, -3.26518614707e-10, -2.93243500455e-9],\n    [27, 20, -8.55182561846e-10, 3.47617208115e-9],\n    [27, 21, 4.86877030983e-9, -7.0872528354e-9],\n    [27, 22, -5.74332100084e-9, 2.90056687384e-9],\n    [27, 23, -5.41033470941e-9, -1.10452433655e-8],\n    [27, 24, 4.16951885933e-10, -1.80038186307e-9],\n    [27, 25, 1.22815470212e-8, 5.62425137285e-9],\n    [27, 26, -6.59498075164e-9, -2.22838418639e-9],\n    [27, 27, 7.60067381059e-9, 6.9238741892e-10],\n    [28, 0, -9.10376375863e-9, 0],\n    [28, 1, -5.55484993587e-9, 7.9330019258e-9],\n    [28, 2, -1.5189131211e-8, -7.97957089012e-9],\n    [28, 3, 2.5318254224e-9, 1.11373049392e-8],\n    [28, 4, -1.99212752126e-9, 1.25054704704e-8],\n    [28, 5, 1.08871875702e-8, -4.22573826989e-9],\n    [28, 6, -5.22194316032e-9, 1.32656509709e-8],\n    [28, 7, -7.05588863746e-10, 5.12740997711e-9],\n    [28, 8, -4.23704976329e-9, -3.32584474553e-9],\n    [28, 9, 1.13842461859e-8, -1.04163010811e-8],\n    [28, 10, -9.22867885082e-9, 8.17851851593e-9],\n    [28, 11, -2.9809734257e-9, -1.45944538949e-9],\n    [28, 12, -4.83471863256e-10, 9.64951845027e-9],\n    [28, 13, 1.64993974957e-9, 6.63803768689e-9],\n    [28, 14, -8.23334828619e-9, -1.26939492243e-8],\n    [28, 15, -1.22774798187e-8, -1.97537366262e-9],\n    [28, 16, -3.57280690709e-9, -1.35890044766e-8],\n    [28, 17, 1.33742628184e-8, -4.72374226319e-9],\n    [28, 18, 5.62532322748e-9, -3.87230727328e-9],\n    [28, 19, 5.77104709635e-9, 2.35011734292e-8],\n    [28, 20, -1.15922189521e-9, 6.62939940662e-9],\n    [28, 21, 6.63154344375e-9, 6.33201211223e-9],\n    [28, 22, -1.94231451662e-9, -7.33725263107e-9],\n    [28, 23, 6.20158165102e-9, 2.61202437682e-9],\n    [28, 24, 1.11186270621e-8, -1.35606378769e-8],\n    [28, 25, 7.29495896149e-9, -1.76041477031e-8],\n    [28, 26, 1.23084992259e-8, 3.89251843939e-9],\n    [28, 27, -8.11971206724e-9, 1.3027922855e-9],\n    [28, 28, 6.9872587832e-9, 6.80526167979e-9],\n    [29, 0, -4.97406439473e-9, 0],\n    [29, 1, 4.98979084585e-9, -9.82512461189e-9],\n    [29, 2, -3.12119754621e-9, -2.63433487676e-9],\n    [29, 3, 1.82518120454e-9, -1.05769977751e-8],\n    [29, 4, -2.42786314995e-8, 2.26110758622e-9],\n    [29, 5, -6.8110306367e-9, 6.01242555817e-9],\n    [29, 6, 1.19592879211e-8, 9.7020069574e-9],\n    [29, 7, -5.91100934209e-9, -2.14599788734e-9],\n    [29, 8, -1.6946723555e-8, 1.11160276839e-8],\n    [29, 9, -1.2937116169e-9, 1.41793573226e-9],\n    [29, 10, 1.37184624798e-8, 1.79543486167e-9],\n    [29, 11, -5.96272885876e-9, 6.33350180946e-9],\n    [29, 12, -4.56278910357e-10, -5.01222008898e-9],\n    [29, 13, -1.09095923049e-9, -2.34179014389e-9],\n    [29, 14, -3.23718965114e-9, -4.58306325034e-9],\n    [29, 15, -9.57359749406e-9, -6.77546725808e-9],\n    [29, 16, 1.37450063496e-9, -1.4864526654e-8],\n    [29, 17, -1.57662415501e-9, -3.92506699434e-9],\n    [29, 18, -3.67597840865e-9, -2.58549575294e-9],\n    [29, 19, -6.30046143533e-9, 5.86840708296e-9],\n    [29, 20, -7.96446331531e-9, 5.74239983127e-9],\n    [29, 21, -9.8726430286e-9, -5.51700601596e-9],\n    [29, 22, 1.15574836058e-8, -1.47663300854e-9],\n    [29, 23, -1.84576717899e-9, 2.63546763516e-9],\n    [29, 24, 3.42199668119e-10, -2.38230581193e-9],\n    [29, 25, 5.85864038329e-9, 8.68333958543e-9],\n    [29, 26, 7.87039835357e-9, -6.92232980921e-9],\n    [29, 27, -7.98313300841e-9, -1.01903214091e-9],\n    [29, 28, 9.73355537526e-9, -5.71293958601e-9],\n    [29, 29, 1.28224843767e-8, -5.01548480482e-9],\n    [30, 0, 6.02882084759e-9, 0],\n    [30, 1, -5.57556615596e-10, 1.24285275602e-9],\n    [30, 2, -1.0370644769e-8, -2.61802322444e-9],\n    [30, 3, 2.14692300603e-9, -1.36464188501e-8],\n    [30, 4, -4.55090433473e-10, -3.91117213505e-9],\n    [30, 5, -4.36973977446e-9, -5.35558974983e-9],\n    [30, 6, 3.28451285815e-10, 3.17808233981e-9],\n    [30, 7, 4.04923220309e-9, 1.83962458779e-9],\n    [30, 8, 2.54952865236e-9, 4.62058281854e-9],\n    [30, 9, -7.32592511128e-9, -9.7277817424e-9],\n    [30, 10, 4.27609484555e-9, -4.10864961814e-9],\n    [30, 11, -1.04043005227e-8, 1.07581457651e-8],\n    [30, 12, 1.71622295302e-8, -1.08456775556e-8],\n    [30, 13, 1.42173587056e-8, 2.96806226352e-9],\n    [30, 14, 5.11505860834e-9, 8.07288811257e-9],\n    [30, 15, 2.10512146846e-10, -1.04541123836e-9],\n    [30, 16, -1.08921920457e-8, 4.35254063533e-9],\n    [30, 17, -6.14382436271e-9, -6.03140938575e-9],\n    [30, 18, -1.1114926509e-8, -7.65521957976e-9],\n    [30, 19, -1.2967398433e-8, 2.42005669694e-9],\n    [30, 20, -4.89261172033e-9, 1.27655684422e-8],\n    [30, 21, -1.0628473781e-8, -5.97537587412e-9],\n    [30, 22, -4.83763240001e-9, -9.37720111156e-9],\n    [30, 23, 5.7411388543e-9, -1.03756082222e-8],\n    [30, 24, -2.35238020789e-9, -2.7590933962e-9],\n    [30, 25, 3.04426404856e-9, -1.54853389229e-8],\n    [30, 26, 1.22149787623e-9, 1.24069551653e-8],\n    [30, 27, -7.95063844863e-9, 1.27529431593e-8],\n    [30, 28, -5.47120800289e-9, -7.96006293513e-9],\n    [30, 29, 4.1592295424e-9, 1.89489104417e-9],\n    [30, 30, 2.64794018006e-9, 8.12994755178e-9],\n    [31, 0, 7.33100089318e-9, 0],\n    [31, 1, 6.11169376734e-9, -1.60774540844e-8],\n    [31, 2, 7.49625106123e-9, 6.37776322444e-9],\n    [31, 3, -8.89920966189e-9, -7.6550294416e-9],\n    [31, 4, 1.22555580723e-8, -4.94466436575e-9],\n    [31, 5, -8.71279064045e-9, 3.08325747379e-9],\n    [31, 6, -1.68890803585e-9, 1.3703621527e-9],\n    [31, 7, -2.71996133536e-9, -6.8862512168e-10],\n    [31, 8, -7.50260355354e-10, 2.28102724239e-9],\n    [31, 9, -6.55840403272e-10, 5.24179002617e-9],\n    [31, 10, 3.99161675027e-9, -4.73500202132e-9],\n    [31, 11, 6.93506892777e-10, 2.08668068881e-8],\n    [31, 12, 5.5287540984e-10, 4.52042167068e-9],\n    [31, 13, 9.40389423562e-9, 4.6684078573e-9],\n    [31, 14, -7.88650771167e-9, 3.51952460147e-9],\n    [31, 15, 4.29954776132e-9, -2.80870684394e-9],\n    [31, 16, -7.19430261173e-9, 6.11805049979e-9],\n    [31, 17, -2.53821168958e-9, 6.83008216722e-9],\n    [31, 18, -6.02099321996e-10, -2.04187286905e-9],\n    [31, 19, 2.89086482301e-9, 4.43976791609e-9],\n    [31, 20, -1.75732193914e-9, 5.64081954558e-9],\n    [31, 21, -9.67143669208e-9, 7.09357408027e-9],\n    [31, 22, -9.0531201252e-9, -1.18308417466e-8],\n    [31, 23, 8.32234353898e-9, 4.51774572555e-9],\n    [31, 24, -2.81565064366e-9, -3.34369513768e-9],\n    [31, 25, -1.64574268169e-8, -2.20460908971e-9],\n    [31, 26, -1.26653070356e-8, 1.59189398991e-9],\n    [31, 27, -1.34953305827e-9, 1.07507650019e-8],\n    [31, 28, 1.04226918411e-8, 2.8072229491e-9],\n    [31, 29, -1.5812688103e-9, -2.18247510672e-9],\n    [31, 30, -9.47416722001e-10, -7.78077525656e-9],\n    [31, 31, -8.59193452715e-9, -1.85200316483e-9],\n    [32, 0, -2.33966288032e-9, 0],\n    [32, 1, -1.69210486076e-9, 1.27760467976e-9],\n    [32, 2, 1.13999662663e-8, -3.35609127916e-9],\n    [32, 3, -1.444433154e-10, 4.05424830941e-9],\n    [32, 4, 8.56367829112e-10, -6.75422476107e-9],\n    [32, 5, 8.60776205333e-9, 1.82572279646e-9],\n    [32, 6, -1.00402568672e-8, -7.6305617634e-9],\n    [32, 7, 1.37058613278e-9, 2.75465347035e-9],\n    [32, 8, 1.19653531908e-8, 4.91018212548e-9],\n    [32, 9, 7.332252213e-9, 7.18971591052e-10],\n    [32, 10, 9.12133506379e-11, -5.70680927495e-9],\n    [32, 11, -5.42043742127e-9, 7.583606425e-9],\n    [32, 12, -1.70289059214e-8, 1.40808168623e-8],\n    [32, 13, 4.02186822027e-9, 5.34936491964e-9],\n    [32, 14, -5.44420334437e-9, 2.20410694316e-9],\n    [32, 15, 5.1658020828e-9, -8.74727531741e-9],\n    [32, 16, 4.14867061294e-9, 4.27270420004e-9],\n    [32, 17, -6.46857778906e-9, 1.01916486215e-8],\n    [32, 18, 1.27286345117e-8, -1.12136888089e-9],\n    [32, 19, 7.55189536923e-10, -2.7754653073e-9],\n    [32, 20, 3.8161056442e-9, 3.19534855653e-10],\n    [32, 21, -2.33262996771e-9, 1.16411650251e-8],\n    [32, 22, -1.20880678762e-8, -2.72691793232e-9],\n    [32, 23, 8.18682122143e-9, -2.33549712722e-9],\n    [32, 24, -3.55036315667e-9, 6.54834763861e-10],\n    [32, 25, -1.89374992503e-8, -6.43429532848e-9],\n    [32, 26, 5.22535531492e-9, -3.68856221241e-9],\n    [32, 27, -4.53740085214e-9, -6.68075560111e-9],\n    [32, 28, 1.653041745e-9, -5.73130340772e-9],\n    [32, 29, 4.32768192965e-9, 2.88179889934e-9],\n    [32, 30, -6.74805866294e-9, 1.39346268546e-9],\n    [32, 31, -6.26740251766e-9, -2.18475608171e-10],\n    [32, 32, 3.3975660331e-9, 1.42646165155e-9],\n    [33, 0, -3.49357179498e-9, 0],\n    [33, 1, -1.39642913445e-9, -2.16391760811e-9],\n    [33, 2, -7.48774194896e-9, -5.0187208152e-10],\n    [33, 3, -1.99661955793e-9, 7.0930410268e-9],\n    [33, 4, -4.270199819e-9, 2.27426656698e-9],\n    [33, 5, 2.37784729729e-10, 3.74439169451e-9],\n    [33, 6, 1.22603039921e-9, -2.87328300836e-9],\n    [33, 7, -6.11215086076e-9, 2.49383366316e-9],\n    [33, 8, -8.23144405057e-10, 1.44915555407e-8],\n    [33, 9, 5.05097392033e-9, 7.4051746902e-9],\n    [33, 10, -2.39709923317e-9, 1.07022906758e-9],\n    [33, 11, 2.43388836443e-9, -8.67071813487e-9],\n    [33, 12, -2.33510532329e-9, 8.9435069891e-9],\n    [33, 13, 2.6041538193e-9, 3.13805750981e-9],\n    [33, 14, 4.92959662302e-9, 5.71204550617e-9],\n    [33, 15, -4.64145303396e-9, -3.47835302325e-9],\n    [33, 16, 7.39530517571e-9, 6.28613189283e-9],\n    [33, 17, -5.73064590551e-9, 1.28779114927e-8],\n    [33, 18, -9.74285933562e-9, -1.89598124592e-9],\n    [33, 19, 8.52447331156e-9, 2.07561717246e-9],\n    [33, 20, -3.32627500309e-9, -7.77689999053e-9],\n    [33, 21, 9.38761672387e-10, 8.17787598674e-10],\n    [33, 22, -1.05439940875e-8, -1.56190227392e-8],\n    [33, 23, 1.15896250314e-10, -1.01356350767e-8],\n    [33, 24, 1.11416074527e-8, -8.57153776484e-9],\n    [33, 25, 5.24730532375e-9, -1.04941656537e-8],\n    [33, 26, 1.09590005596e-8, 4.5404144025e-9],\n    [33, 27, -1.32772908147e-9, 1.26154161942e-9],\n    [33, 28, 1.75943381421e-9, -1.02060346415e-9],\n    [33, 29, -1.63075128633e-8, 5.72191328891e-9],\n    [33, 30, -1.56977064277e-9, -1.84579402264e-8],\n    [33, 31, 4.69481868853e-9, 1.02290050028e-9],\n    [33, 32, 6.56775919022e-9, -4.39711913398e-9],\n    [33, 33, -1.52043850303e-9, 8.31263004529e-9],\n    [34, 0, -9.08833340447e-9, 0],\n    [34, 1, -2.76889795047e-9, 6.3891897021e-9],\n    [34, 2, 6.7688190654e-9, 5.30082118696e-9],\n    [34, 3, 1.25429669786e-8, 8.11619669834e-9],\n    [34, 4, -8.30005417504e-9, 1.19586870272e-9],\n    [34, 5, -3.88131685638e-9, 3.54963449977e-9],\n    [34, 6, 4.84093709579e-10, 7.62975480293e-9],\n    [34, 7, 2.75125793239e-9, -6.56263573163e-9],\n    [34, 8, -9.83446807592e-9, 4.68751478021e-9],\n    [34, 9, 1.53042494664e-9, 2.10165697829e-9],\n    [34, 10, -7.52633242389e-9, 1.46544229781e-9],\n    [34, 11, -3.82043431506e-9, -1.07829735599e-9],\n    [34, 12, 1.42629362262e-8, -4.60063642968e-9],\n    [34, 13, -3.56240984255e-9, 1.03329523096e-9],\n    [34, 14, -2.50187664392e-9, 9.64686908241e-9],\n    [34, 15, 3.75939804157e-10, 6.2628624977e-9],\n    [34, 16, -1.45874042713e-9, -1.4938092908e-9],\n    [34, 17, -4.73747570512e-9, 3.93698829389e-9],\n    [34, 18, -1.47488701345e-8, -5.38197998817e-9],\n    [34, 19, -3.59837568897e-9, 7.15302015583e-9],\n    [34, 20, 3.64466859655e-9, -1.01824147346e-8],\n    [34, 21, -9.81980297066e-10, -7.42166456548e-9],\n    [34, 22, -3.18152215406e-9, 3.36620175035e-9],\n    [34, 23, -1.1297312057e-9, -1.18981902172e-8],\n    [34, 24, 8.78079044954e-9, 4.20436158037e-9],\n    [34, 25, 8.41097170248e-9, -9.86300815266e-9],\n    [34, 26, 3.99964384231e-9, -1.29360014691e-8],\n    [34, 27, 1.31566196208e-8, -3.91137836409e-9],\n    [34, 28, -1.65320604713e-10, -2.00370653858e-8],\n    [34, 29, 7.08151676681e-9, -4.31563574113e-9],\n    [34, 30, -2.05666035677e-8, -5.86948946952e-10],\n    [34, 31, -4.57411268111e-9, -1.60852780125e-9],\n    [34, 32, 9.14033593474e-9, 2.31645138264e-9],\n    [34, 33, 1.37617937967e-8, 4.3547198646e-9],\n    [34, 34, -8.54011998155e-9, 1.65364599023e-9],\n    [35, 0, 8.60443158492e-9, 0],\n    [35, 1, -1.07631176168e-8, -1.03576288219e-8],\n    [35, 2, -1.48166749807e-8, 7.47316845223e-9],\n    [35, 3, 1.88623900305e-9, 3.49967679465e-9],\n    [35, 4, -2.82338523108e-9, 9.20674937921e-9],\n    [35, 5, -7.23688443416e-9, -1.15478796146e-8],\n    [35, 6, 3.28708320436e-9, 7.90142264483e-9],\n    [35, 7, -3.45829826367e-9, 4.71386839716e-9],\n    [35, 8, 4.15911228686e-9, 9.21486965423e-9],\n    [35, 9, -7.83584593022e-10, -1.08780700595e-9],\n    [35, 10, -2.63078124596e-9, 1.14437669825e-8],\n    [35, 11, 3.1135284219e-9, -3.11508942142e-9],\n    [35, 12, 8.10432165903e-9, -6.4323395678e-9],\n    [35, 13, -1.60870380988e-9, 3.02852925442e-9],\n    [35, 14, -7.16511186947e-9, -7.02737046917e-9],\n    [35, 15, -1.53690564123e-8, 8.75984924717e-9],\n    [35, 16, -6.89772047703e-9, -7.36827047584e-9],\n    [35, 17, 7.03755899027e-10, -8.82920485773e-9],\n    [35, 18, -5.55247661498e-9, -1.14710477959e-8],\n    [35, 19, -1.07112499273e-9, -3.41854119412e-9],\n    [35, 20, 9.92702305837e-10, -1.13573745208e-10],\n    [35, 21, 1.29333785663e-8, -8.17657795386e-10],\n    [35, 22, 7.51479477595e-9, 5.7229930908e-9],\n    [35, 23, -8.16391242216e-9, -2.22442612532e-9],\n    [35, 24, 2.78435090517e-9, 6.38499607176e-9],\n    [35, 25, 7.16858934156e-9, 1.99781103645e-9],\n    [35, 26, -4.70300232305e-9, 4.61488943108e-9],\n    [35, 27, 1.09602089094e-8, -1.33812635796e-8],\n    [35, 28, 7.88159460716e-9, -1.53673024839e-8],\n    [35, 29, 7.70786810766e-9, 3.40140754669e-9],\n    [35, 30, -4.0519283993e-9, 2.87370616224e-9],\n    [35, 31, 7.84140204315e-9, 4.0412480788e-9],\n    [35, 32, -3.16267901777e-9, -7.41858064221e-9],\n    [35, 33, 5.8609633966e-9, -3.07739390905e-9],\n    [35, 34, -1.21632099674e-9, 2.66717400938e-9],\n    [35, 35, -5.8786572941e-9, -5.01230638002e-9],\n    [36, 0, -4.02590604243e-9, 0],\n    [36, 1, -1.13386686386e-9, 5.14982653283e-9],\n    [36, 2, -4.31575901448e-9, -3.40211031655e-9],\n    [36, 3, 7.00409280444e-11, -1.58895672921e-8],\n    [36, 4, 3.00961129935e-9, 1.38917218538e-9],\n    [36, 5, -7.42261535513e-9, 1.4033786019e-9],\n    [36, 6, 1.08546024568e-8, -3.16311943226e-9],\n    [36, 7, 1.70813806147e-9, 6.17680210154e-9],\n    [36, 8, 3.44939360246e-9, -5.03767857861e-9],\n    [36, 9, 2.92192219493e-9, -3.74028113708e-10],\n    [36, 10, 4.23119681703e-9, 6.83503143788e-9],\n    [36, 11, -4.10039232642e-9, 4.75118294475e-9],\n    [36, 12, 4.87204962837e-10, -9.84587714675e-9],\n    [36, 13, -6.15416963507e-9, 8.0318113556e-9],\n    [36, 14, -1.04141682764e-8, -5.94203574762e-9],\n    [36, 15, 9.54892409044e-10, 3.33310574172e-9],\n    [36, 16, 1.25505913598e-9, -1.60569406116e-10],\n    [36, 17, 4.95066186034e-9, -8.65314022477e-9],\n    [36, 18, 1.77184202015e-9, 4.4603340077e-9],\n    [36, 19, -5.25149217565e-9, -6.65319486115e-9],\n    [36, 20, -6.03793346956e-9, 3.52627660597e-9],\n    [36, 21, 1.0690892473e-8, -5.67948915026e-9],\n    [36, 22, 3.21356130034e-9, 1.61234121461e-9],\n    [36, 23, -3.61160199501e-10, 2.74891917069e-9],\n    [36, 24, 2.10662869987e-9, -4.24514998756e-9],\n    [36, 25, 4.3497929214e-9, 1.5607147346e-8],\n    [36, 26, 3.68762567031e-9, 9.37175113714e-9],\n    [36, 27, -7.91229464362e-9, 8.8299681063e-9],\n    [36, 28, 2.22637976824e-9, -4.34372617405e-9],\n    [36, 29, 1.84511675839e-9, 2.0734471834e-10],\n    [36, 30, -1.00411515955e-8, 6.05413293608e-9],\n    [36, 31, -8.39084442298e-9, -5.54047445598e-9],\n    [36, 32, 1.25654207109e-8, 2.30476235625e-9],\n    [36, 33, 3.89957606637e-9, -3.50340856893e-9],\n    [36, 34, -9.08693282663e-9, 4.35776976715e-9],\n    [36, 35, -1.38812503272e-10, -1.25527291076e-8],\n    [36, 36, 4.6014646572e-9, -5.94245336314e-9],\n];\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\n// / Harris-Priester atmosphere data, assuming mean solar flux.\nexport const hpAtmosphere = [\n    [100, 4.974e-7, 4.974e-7],\n    [120, 2.49e-8, 2.49e-8],\n    [130, 8.377e-9, 8.71e-9],\n    [140, 3.899e-9, 4.059e-9],\n    [150, 2.122e-9, 2.215e-9],\n    [160, 1.263e-9, 1.344e-9],\n    [170, 8.008e-10, 8.758e-10],\n    [180, 5.283e-10, 6.01e-10],\n    [190, 3.617e-10, 4.297e-10],\n    [200, 2.557e-10, 3.162e-10],\n    [210, 1.839e-10, 2.396e-10],\n    [220, 1.341e-10, 1.853e-10],\n    [230, 9.949e-11, 1.455e-10],\n    [240, 7.488e-11, 1.157e-10],\n    [250, 5.709e-11, 9.308e-11],\n    [260, 4.403e-11, 7.555e-11],\n    [270, 3.43e-11, 6.182e-11],\n    [280, 2.697e-11, 5.095e-11],\n    [290, 2.139e-11, 4.226e-11],\n    [300, 1.708e-11, 3.526e-11],\n    [320, 1.099e-11, 2.511e-11],\n    [340, 7.214e-12, 1.819e-11],\n    [360, 4.824e-12, 1.337e-11],\n    [380, 3.274e-12, 9.955e-12],\n    [400, 2.249e-12, 7.492e-12],\n    [420, 1.558e-12, 5.684e-12],\n    [440, 1.091e-12, 4.355e-12],\n    [460, 7.701e-13, 3.362e-12],\n    [480, 5.474e-13, 2.612e-12],\n    [500, 3.916e-13, 2.042e-12],\n    [520, 2.819e-13, 1.605e-12],\n    [540, 2.042e-13, 1.267e-12],\n    [560, 1.488e-13, 1.005e-12],\n    [580, 1.092e-13, 7.997e-13],\n    [600, 8.07e-14, 6.39e-13],\n    [620, 6.012e-14, 5.123e-13],\n    [640, 4.519e-14, 4.121e-13],\n    [660, 3.43e-14, 3.325e-13],\n    [680, 2.632e-14, 2.691e-13],\n    [700, 2.043e-14, 2.185e-13],\n    [720, 1.607e-14, 1.779e-13],\n    [740, 1.281e-14, 1.452e-13],\n    [760, 1.036e-14, 1.19e-13],\n    [780, 8.496e-15, 9.776e-14],\n    [800, 7.069e-15, 8.059e-14],\n    [840, 4.68e-15, 5.741e-14],\n    [880, 3.2e-15, 4.21e-14],\n    [920, 2.21e-15, 3.13e-14],\n    [960, 1.56e-15, 2.36e-14],\n    [1000, 1.15e-15, 1.81e-14],\n];\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\n// / Array of the first 4 IAU-1980 coefficients.\nexport const iau1980 = [\n    [0, 0, 0, 0, 1, -171996, -174.2, 92025, 8.9],\n    [0, 0, 2, -2, 2, -13187, -1.6, 5736, -3.1],\n    [0, 0, 2, 0, 2, -2274, -0.2, 977, -0.5],\n    [0, 0, 0, 0, 2, 2062, 0.2, -895, 0.5],\n];\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\n/** Enumeration representing different methods for calculating angular diameter. */\nexport var AngularDiameterMethod;\n(function (AngularDiameterMethod) {\n    AngularDiameterMethod[AngularDiameterMethod[\"Circle\"] = 0] = \"Circle\";\n    AngularDiameterMethod[AngularDiameterMethod[\"Sphere\"] = 1] = \"Sphere\";\n})(AngularDiameterMethod || (AngularDiameterMethod = {}));\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\n/** Enumeration representing different methods for calculating angular distance. */\nexport var AngularDistanceMethod;\n(function (AngularDistanceMethod) {\n    AngularDistanceMethod[AngularDistanceMethod[\"Cosine\"] = 0] = \"Cosine\";\n    AngularDistanceMethod[AngularDistanceMethod[\"Haversine\"] = 1] = \"Haversine\";\n})(AngularDistanceMethod || (AngularDistanceMethod = {}));\n","export var CatalogSource;\n(function (CatalogSource) {\n    CatalogSource[\"USSF\"] = \"USSF\";\n    CatalogSource[\"CELESTRAK\"] = \"Celestrak\";\n    CatalogSource[\"UNIV_OF_MICH\"] = \"University of Michigan\";\n    CatalogSource[\"CALPOLY\"] = \"CalPoly\";\n    CatalogSource[\"NUSPACE\"] = \"NuSpace\";\n    CatalogSource[\"VIMPEL\"] = \"JSC Vimpel\";\n    CatalogSource[\"TLE_TXT\"] = \"TLE.txt\";\n    CatalogSource[\"EXTRA_JSON\"] = \"extra.json\";\n})(CatalogSource || (CatalogSource = {}));\n","export var CommLink;\n(function (CommLink) {\n    CommLink[\"AEHF\"] = \"AEHF\";\n    CommLink[\"GALILEO\"] = \"Galileo\";\n    CommLink[\"IRIDIUM\"] = \"Iridium\";\n    CommLink[\"STARLINK\"] = \"Starlink\";\n    CommLink[\"WGS\"] = \"WGS\";\n})(CommLink || (CommLink = {}));\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\n/** Orbit regime classifications. */\nexport var OrbitRegime;\n(function (OrbitRegime) {\n    OrbitRegime[\"LEO\"] = \"Low Earth Orbit\";\n    OrbitRegime[\"MEO\"] = \"Medium Earth Orbit\";\n    OrbitRegime[\"HEO\"] = \"Highly Eccentric Orbit\";\n    OrbitRegime[\"GEO\"] = \"Geosynchronous Orbit\";\n    OrbitRegime[\"OTHER\"] = \"Uncategorized Orbit\";\n})(OrbitRegime || (OrbitRegime = {}));\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nexport var PassType;\n(function (PassType) {\n    PassType[PassType[\"OUT_OF_VIEW\"] = -1] = \"OUT_OF_VIEW\";\n    PassType[PassType[\"ENTER\"] = 0] = \"ENTER\";\n    PassType[PassType[\"IN_VIEW\"] = 1] = \"IN_VIEW\";\n    PassType[PassType[\"EXIT\"] = 2] = \"EXIT\";\n})(PassType || (PassType = {}));\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nexport var Sgp4OpsMode;\n(function (Sgp4OpsMode) {\n    Sgp4OpsMode[\"AFSPC\"] = \"a\";\n    Sgp4OpsMode[\"IMPROVED\"] = \"i\";\n})(Sgp4OpsMode || (Sgp4OpsMode = {}));\n","export { OrbitRegime } from './OrbitRegime.js';\nexport { Sgp4OpsMode } from './Sgp4OpsMode.js';\nexport { AngularDiameterMethod } from './AngularDiameterMethod.js';\nexport { AngularDistanceMethod } from './AngularDistanceMethod.js';\nexport { PassType } from './PassType.js';\nexport { CatalogSource } from './CatalogSource.js';\nexport { CommLink } from './CommLink.js';\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { DataHandler, DEG2RAD, Earth, ITRF, J2000, Sun, Vector3D, } from '../main.js';\n/**\n * Harris-Priester atmospheric drag force model.\n * Atmospheric density model assumes mean solar flux.\n */\nexport class AtmosphericDrag {\n    mass;\n    area;\n    dragCoeff;\n    cosine;\n    constructor(mass, area, dragCoeff, cosine) {\n        this.mass = mass;\n        this.area = area;\n        this.dragCoeff = dragCoeff;\n        this.cosine = cosine;\n    }\n    static _getHPDensity(state, n) {\n        const hpa = DataHandler.getInstance().getHpAtmosphere(state.height);\n        if (hpa === null) {\n            return 0.0;\n        }\n        const sunPos = Sun.positionApparent(state.epoch);\n        const sunVec = new J2000(state.epoch, sunPos, Vector3D.origin).toITRF().position.normalize();\n        const bulVec = sunVec.rotZ(-30.0 * DEG2RAD);\n        const cosPsi = bulVec.normalize().dot(state.position.normalize());\n        const c2Psi2 = 0.5 * (1.0 + cosPsi);\n        const cPsi2 = Math.sqrt(c2Psi2);\n        const cosPow = cPsi2 > 1e-12 ? c2Psi2 * cPsi2 ** (n - 2) : 0.0;\n        const altitude = hpa.height;\n        const [h0, min0, max0] = hpa.hp0;\n        const [h1, min1, max1] = hpa.hp1;\n        const dH = (h0 - altitude) / (h0 - h1);\n        const rhoMin = min0 * (min1 / min0) ** dH;\n        if (cosPow === 0) {\n            return rhoMin;\n        }\n        const rhoMax = max0 * (max1 / max0) ** dH;\n        return rhoMin + (rhoMax - rhoMin) * cosPow;\n    }\n    acceleration(state) {\n        const itrfState = state.toITRF();\n        const density = AtmosphericDrag._getHPDensity(itrfState, this.cosine);\n        if (density === 0) {\n            return Vector3D.origin;\n        }\n        const rotation = new ITRF(state.epoch, Earth.rotation, Vector3D.origin).toJ2000().position;\n        const vRel = state.velocity.subtract(rotation.cross(state.position))\n            .scale(1000.0);\n        const vm = vRel.magnitude();\n        const fScale = -0.5 * density * ((this.dragCoeff * this.area) / this.mass) * vm;\n        return vRel.scale(fScale / 1000.0);\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { DataHandler, Earth, ITRF, Vector3D } from '../main.js';\n/**\n * designed to model the Earth's gravitational field, which is not uniformly distributed due to variations in mass\n * distribution within the Earth and the Earth's shape (it's not a perfect sphere). To accurately model this complex\n * field, the gravity model is expanded into a series of spherical harmonics, characterized by their degree and order.\n *\n * This `degree` parameter is related to the spatial resolution of the gravity model. A higher degree corresponds to a\n * finer resolution, capable of representing smaller-scale variations in the gravity field. The degree essentially\n * denotes how many times the gravitational potential function varies over the surface of the Earth.\n *\n * For each degree, there can be multiple orders ranging from 0 up to the degree. The `order` accounts for the\n * longitudinal variation in the gravity field. Each order within a degree captures different characteristics of the\n * gravity anomalies.\n *\n * `Degree 0` corresponds to the overall, mean gravitational force of the Earth (considered as a point mass).\n *\n * `Degree 1` terms are related to the Earth's center of mass but are usually not used because the center of mass is\n * defined as the origin of the coordinate system.\n *\n * `Degree 2` and higher capture the deviations from this spherical symmetry, such as the flattening at the poles and\n * bulging at the equator (degree 2), and other anomalies at finer scales as the degree increases.\n */\nexport class EarthGravity {\n    degree;\n    order;\n    _asphericalFlag;\n    /**\n     * Creates a new instance of the EarthGravity class.\n     * @param degree The degree of the Earth's gravity field. Must be between 0 and 36.\n     * @param order The order of the Earth's gravity field. Must be between 0 and 36.\n     */\n    constructor(degree, order) {\n        this.degree = Math.min(Math.max(degree, 0), 36);\n        this.order = Math.min(Math.max(order, 0), 36);\n        this._asphericalFlag = degree >= 2;\n    }\n    _spherical(state) {\n        const rMag = state.position.magnitude();\n        return state.position.scale(-Earth.mu / (rMag * rMag * rMag));\n    }\n    // eslint-disable-next-line max-statements\n    _aspherical(state) {\n        const posEcef = state.toITRF().position;\n        const ri = 1.0 / posEcef.magnitude();\n        const xor = posEcef.x * ri;\n        const yor = posEcef.y * ri;\n        const zor = posEcef.z * ri;\n        const ep = zor;\n        const reor = Earth.radiusEquator * ri;\n        let reorn = reor;\n        const muor2 = Earth.mu * ri * ri;\n        let sumH = 0.0;\n        let sumGm = 0.0;\n        let sumJ = 0.0;\n        let sumK = 0.0;\n        const cTil = new Float64Array(this.order + 4);\n        const sTil = new Float64Array(this.order + 4);\n        const pN = new Float64Array(this.order + 4);\n        const pNm1 = new Float64Array(this.order + 4);\n        const pNm2 = new Float64Array(this.order + 4);\n        pNm2[0] = 1.0;\n        pNm1[0] = ep;\n        pNm1[1] = 1.0;\n        cTil[0] = 1.0;\n        cTil[1] = xor;\n        sTil[1] = yor;\n        const dh = DataHandler.getInstance();\n        for (let n = 2, nm1 = 1, nm2 = 0, np1 = 3; n <= this.degree; nm2++, nm1++, n++, np1++) {\n            const twonm1 = 2.0 * n - 1.0;\n            reorn *= reor;\n            const cN0 = dh.getEgm96Coeffs(n, 0)[2];\n            pN[0] = (twonm1 * ep * pNm1[0] - nm1 * pNm2[0]) / n;\n            pN[1] = pNm2[1] + twonm1 * pNm1[0];\n            pN[2] = pNm2[2] + twonm1 * pNm1[1];\n            let sumHn = pN[1] * cN0;\n            let sumGmn = pN[0] * cN0 * np1;\n            if (this.order > 0) {\n                let sumJn = 0.0;\n                let sumKn = 0.0;\n                cTil[n] = cTil[1] * cTil[nm1] - sTil[1] * sTil[nm1];\n                sTil[n] = sTil[1] * cTil[nm1] + cTil[1] * sTil[nm1];\n                const lim = n < this.order ? n : this.order;\n                for (let m = 1, mm1 = 0, mm2 = -1, mp1 = 2, mp2 = 3; m <= lim; mm2++, mm1++, m++, mp1++, mp2++) {\n                    pN[mp1] = pNm2[mp1] + twonm1 * pNm1[m];\n                    const dm = m;\n                    const npmp1 = n + mp1;\n                    const pNm = pN[m];\n                    const pNmp1 = pN[mp1];\n                    const coefs = dh.getEgm96Coeffs(n, m);\n                    const cNm = coefs[2];\n                    const sNm = coefs[3];\n                    const mxPnm = dm * pNm;\n                    const bNmtil = cNm * cTil[m] + sNm * sTil[m];\n                    const pNmBnm = pNm * bNmtil;\n                    const bNmtm1 = cNm * cTil[mm1] + sNm * sTil[mm1];\n                    const aNmtm1 = cNm * sTil[mm1] - sNm * cTil[mm1];\n                    sumHn += pNmp1 * bNmtil;\n                    sumGmn += npmp1 * pNmBnm;\n                    sumJn += mxPnm * bNmtm1;\n                    sumKn -= mxPnm * aNmtm1;\n                }\n                sumJ += reorn * sumJn;\n                sumK += reorn * sumKn;\n            }\n            sumH += reorn * sumHn;\n            sumGm += reorn * sumGmn;\n            if (n < this.degree) {\n                for (let i = 0; i <= n; i++) {\n                    pNm2[i] = pNm1[i];\n                    pNm1[i] = pN[i];\n                }\n            }\n        }\n        const lambda = sumGm + ep * sumH;\n        const g = new Vector3D(-muor2 * (lambda * xor - sumJ), -muor2 * (lambda * yor - sumK), -muor2 * (lambda * zor - sumH));\n        return new ITRF(state.epoch, g, Vector3D.origin).toJ2000().position;\n    }\n    acceleration(state) {\n        let accVec = this._spherical(state);\n        if (this._asphericalFlag) {\n            accVec = accVec.add(this._aspherical(state));\n        }\n        return accVec;\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\n/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable class-methods-use-this */\n// / Base class for perturbation forces.\nexport class Force {\n    /**\n     * Calculate the acceleration due to the perturbing force on a given\n     * state vector.\n     * @param state The state vector.\n     * @throws If the force cannot be calculated.\n     */\n    acceleration(state) {\n        throw Error('Not implemented');\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { Earth, Vector3D } from '../main.js';\nimport { AtmosphericDrag } from './AtmosphericDrag.js';\nimport { EarthGravity } from './EarthGravity.js';\nimport { Gravity } from './Gravity.js';\nimport { SolarRadiationPressure } from './SolarRadiationPressure.js';\nimport { ThirdBodyGravity } from './ThirdBodyGravity.js';\n// / Force model for spacecraft propagation.\nexport class ForceModel {\n    _centralGravity;\n    _thirdBodyGravity;\n    _solarRadiationPressure;\n    _atmosphericDrag;\n    _maneuverThrust = null;\n    setGravity(mu = Earth.mu) {\n        this._centralGravity = new Gravity(mu);\n        return this;\n    }\n    setEarthGravity(degree, order) {\n        this._centralGravity = new EarthGravity(degree, order);\n    }\n    setThirdBodyGravity({ moon = false, sun = false }) {\n        this._thirdBodyGravity = new ThirdBodyGravity(moon, sun);\n    }\n    setSolarRadiationPressure(mass, area, coeff = 1.2) {\n        this._solarRadiationPressure = new SolarRadiationPressure(mass, area, coeff);\n    }\n    /**\n     * Sets the atmospheric drag for the force model.\n     * @deprecated This is still a work in progress!\n     * @param mass - The mass of the object.\n     * @param area - The cross-sectional area of the object.\n     * @param coeff - The drag coefficient. Default value is 2.2.\n     * @param cosine - The cosine of the angle between the object's velocity vector and the drag force vector.\n     */\n    setAtmosphericDrag(mass, area, coeff = 2.2, cosine = 4) {\n        this._atmosphericDrag = new AtmosphericDrag(mass, area, coeff, cosine);\n    }\n    loadManeuver(maneuver) {\n        this._maneuverThrust = maneuver;\n    }\n    clearManeuver() {\n        this._maneuverThrust = null;\n    }\n    acceleration(state) {\n        let accVec = Vector3D.origin;\n        if (this._centralGravity) {\n            accVec = accVec.add(this._centralGravity.acceleration(state));\n        }\n        if (this._thirdBodyGravity) {\n            accVec = accVec.add(this._thirdBodyGravity.acceleration(state));\n        }\n        if (this._solarRadiationPressure) {\n            accVec = accVec.add(this._solarRadiationPressure.acceleration(state));\n        }\n        if (this._atmosphericDrag) {\n            accVec = accVec.add(this._atmosphericDrag.acceleration(state));\n        }\n        if (this._maneuverThrust) {\n            accVec = accVec.add(this._maneuverThrust.acceleration(state));\n        }\n        return accVec;\n    }\n    derivative(state) {\n        return state.velocity.join(this.acceleration(state));\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { Earth } from '../main.js';\n// / Simple central-body gravity model.\nexport class Gravity {\n    // / Gravitational parameter _(kmÂ²/sÂ³)_.\n    mu;\n    /**\n     * Create a new [Gravity] object with optional gravitational\n     * @param mu Gravitational parameter _(kmÂ²/sÂ³)_.\n     */\n    constructor(mu = Earth.mu) {\n        this.mu = mu;\n    }\n    /**\n     * Calculates the gravitational force in spherical coordinates.\n     * @param state The J2000 state containing the position and velocity vectors.\n     * @returns The gravitational force vector in spherical coordinates.\n     */\n    _spherical(state) {\n        const rMag = state.position.magnitude();\n        return state.position.scale(-this.mu / (rMag * rMag * rMag));\n    }\n    /**\n     * Calculates the acceleration due to gravity at a given state.\n     * @param state The J2000 state at which to calculate the acceleration.\n     * @returns The acceleration vector.\n     */\n    acceleration(state) {\n        return this._spherical(state);\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { astronomicalUnit, Sun } from '../main.js';\nimport { Force } from './Force.js';\n// / Solar radiation pressure model.\nexport class SolarRadiationPressure extends Force {\n    mass;\n    area;\n    reflectCoeff;\n    // / Create a new [SolarRadiationPressure] object.\n    constructor(mass, area, reflectCoeff) {\n        super();\n        this.mass = mass;\n        this.area = area;\n        this.reflectCoeff = reflectCoeff;\n    }\n    // / Solar pressure _(N/mÂ²)_;\n    static _kRef = 4.56e-6 * astronomicalUnit ** 2;\n    acceleration(state) {\n        const rSun = Sun.positionApparent(state.epoch);\n        const r = state.position.subtract(rSun);\n        const rMag = r.magnitude();\n        const r2 = rMag * rMag;\n        const ratio = Sun.lightingRatio(state.position, rSun);\n        const p = (ratio * SolarRadiationPressure._kRef) / r2;\n        const flux = r.scale(p / rMag);\n        return flux.scale(((this.area * this.reflectCoeff) / this.mass) * 1e-3);\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { Moon, Sun, Vector3D } from '../main.js';\n// / Third-body gravity model.\nexport class ThirdBodyGravity {\n    moon;\n    sun;\n    // / Create a new [ThirdBodyGravity] object with the selected bodies enabled.\n    constructor(moon = false, sun = false) {\n        this.moon = moon;\n        this.sun = sun;\n        // Nothing to do here.\n    }\n    static _moonGravity(state) {\n        const rMoon = Moon.eci(state.epoch);\n        const aNum = rMoon.subtract(state.position);\n        const aDen = aNum.magnitude() ** 3;\n        const bNum = rMoon;\n        const bDen = rMoon.magnitude() ** 3;\n        const gravity = aNum.scale(1 / aDen).add(bNum.scale(-1 / bDen));\n        return gravity.scale(Moon.mu);\n    }\n    static _sunGravity(state) {\n        const rSun = Sun.positionApparent(state.epoch);\n        const aNum = rSun.subtract(state.position);\n        const aDen = aNum.magnitude() ** 3;\n        const bNum = rSun;\n        const bDen = rSun.magnitude() ** 3;\n        const gravity = aNum.scale(1 / aDen).add(bNum.scale(-1 / bDen));\n        return gravity.scale(Sun.mu);\n    }\n    acceleration(state) {\n        let accVec = Vector3D.origin;\n        if (this.moon) {\n            accVec = accVec.add(ThirdBodyGravity._moonGravity(state));\n        }\n        if (this.sun) {\n            accVec = accVec.add(ThirdBodyGravity._sunGravity(state));\n        }\n        return accVec;\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { RIC, Vector3D, } from '../main.js';\n// / Thrust force model.\nexport class Thrust {\n    center;\n    radial;\n    intrack;\n    crosstrack;\n    durationRate;\n    constructor(center, radial, intrack, crosstrack, durationRate = 0.0) {\n        this.center = center;\n        this.radial = radial;\n        this.intrack = intrack;\n        this.crosstrack = crosstrack;\n        this.durationRate = durationRate;\n        this.deltaV = new Vector3D(radial * 1e-3, intrack * 1e-3, crosstrack * 1e-3);\n    }\n    deltaV;\n    get magnitude() {\n        return this.deltaV.magnitude() * 1000.0;\n    }\n    get duration() {\n        return this.magnitude * this.durationRate;\n    }\n    get start() {\n        return this.center.roll(-0.5 * this.duration);\n    }\n    get stop() {\n        return this.center.roll(0.5 * this.duration);\n    }\n    acceleration(state) {\n        const relative = new RIC(Vector3D.origin, this.deltaV.scale(1.0 / this.duration));\n        return relative.toJ2000(state).velocity.subtract(state.velocity);\n    }\n    apply(state) {\n        const relative = new RIC(Vector3D.origin, this.deltaV);\n        return relative.toJ2000(state);\n    }\n    get isImpulsive() {\n        return this.duration <= 0;\n    }\n}\n","export { ForceModel } from './ForceModel.js';\n","export {};\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\n// / Container for cubic spline data.\nexport class CubicSpline {\n    t0;\n    p0;\n    m0;\n    t1;\n    p1;\n    m1;\n    // / Create a new [CubicSpline] object.\n    constructor(t0, p0, m0, t1, p1, m1) {\n        this.t0 = t0;\n        this.p0 = p0;\n        this.m0 = m0;\n        this.t1 = t1;\n        this.p1 = p1;\n        this.m1 = m1;\n        // Nothing to do here.\n    }\n    // / Interpolate position at the provided time [t] _(POSIX seconds)_.\n    position_(t) {\n        const t2 = t * t;\n        const t3 = t2 * t;\n        const r0 = this.p0.scale(2 * t3 - 3 * t2 + 1);\n        const v0 = this.m0.scale((t3 - 2 * t2 + t) * (this.t1 - this.t0));\n        const r1 = this.p1.scale(-2 * t3 + 3 * t2);\n        const v1 = this.m1.scale((t3 - t2) * (this.t1 - this.t0));\n        return r0.add(v0).add(r1).add(v1);\n    }\n    // / Interpolate velocity at the provided time [t] _(POSIX seconds)_.\n    velocity_(t) {\n        const t2 = t * t;\n        const r0 = this.p0.scale(6 * t2 - 6 * t);\n        const v0 = this.m0.scale((3 * t2 - 4 * t + 1) * (this.t1 - this.t0));\n        const r1 = this.p1.scale(-6 * t2 + 6 * t);\n        const v1 = this.m1.scale((3 * t2 - 2 * t) * (this.t1 - this.t0));\n        return r0\n            .add(v0)\n            .add(r1)\n            .add(v1)\n            .scale(1 / (this.t1 - this.t0));\n    }\n    /**\n     * Interpolates the position and velocity at a given time.\n     * (km) and velocity (km/s) vectors at the provided time.\n     * @param t The time value to interpolate at _(POSIX seconds)_.\n     * @returns An array containing the interpolated position and velocity as Vector3D objects.\n     */\n    interpolate(t) {\n        const n = (t - this.t0) / (this.t1 - this.t0);\n        return [this.position_(n), this.velocity_(n)];\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { EpochUTC, EpochWindow, J2000 } from '../main.js';\nimport { CubicSpline } from './CubicSpline.js';\nimport { StateInterpolator } from './StateInterpolator.js';\n/**\n * Cubic spline ephemeris interpolator.\n *\n * The [CubicSplineInterpolator] is a very fast and accurate interpolator\n * at the expense of memory due to the cached spline pairs used in the\n * interpolation operation. Accuracy is significantly impacted when using\n * sparse ephemerides.\n */\nexport class CubicSplineInterpolator extends StateInterpolator {\n    splines_;\n    constructor(splines_) {\n        super();\n        this.splines_ = splines_;\n    }\n    static fromEphemeris(ephemeris) {\n        const splines = [];\n        for (let i = 0; i < ephemeris.length - 1; i++) {\n            const e0 = ephemeris[i];\n            const t0 = e0.epoch.posix;\n            const p0 = e0.position;\n            const m0 = e0.velocity;\n            const e1 = ephemeris[i + 1];\n            const t1 = e1.epoch.posix;\n            const p1 = e1.position;\n            const m1 = e1.velocity;\n            splines.push(new CubicSpline(t0, p0, m0, t1, p1, m1));\n        }\n        return new CubicSplineInterpolator(splines);\n    }\n    get sizeBytes() {\n        return (64 * 14 * this.splines_.length) / 8;\n    }\n    matchSpline_(posix) {\n        let left = 0;\n        let right = this.splines_.length;\n        while (left < right) {\n            const middle = (left + right) >> 1;\n            if (this.splines_[middle].t1 < posix) {\n                left = middle + 1;\n            }\n            else {\n                right = middle;\n            }\n        }\n        return this.splines_[left];\n    }\n    interpolate(epoch) {\n        if (!this.inWindow(epoch)) {\n            return null;\n        }\n        const posix = epoch.posix;\n        const splineVecs = this\n            .matchSpline_(posix)\n            .interpolate(posix);\n        return new J2000(epoch, splineVecs[0], splineVecs[1]);\n    }\n    window() {\n        return new EpochWindow(new EpochUTC(this.splines_[0].t0), new EpochUTC(this.splines_[this.splines_.length - 1].t1));\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { EpochUTC, EpochWindow } from '../main.js';\n// / Interpolator base class.\nexport class Interpolator {\n    /*\n     * Return `true` if the provided [epoch] is within this interpolator's\n     * cached value range.\n     */\n    inWindow(epoch) {\n        const start = this.window().start;\n        const stop = this.window().end;\n        return start <= epoch && epoch <= stop;\n    }\n    /*\n     * Calculate the start/stop epoch between this and another [Interpolator].\n     *\n     * Returns `null` if there is no overlap between interpolators.\n     */\n    overlap(interpolator) {\n        const x1 = this.window().start;\n        const x2 = this.window().end;\n        const y1 = interpolator.window().start;\n        const y2 = interpolator.window().end;\n        if (x1 <= y2 && y1 <= x2) {\n            const e1 = new EpochUTC(Math.max(x1.posix, y1.posix));\n            const e2 = new EpochUTC(Math.min(x2.posix, y2.posix));\n            return new EpochWindow(e1, e2);\n        }\n        return null;\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { EpochUTC, EpochWindow, J2000, Vector3D } from '../main.js';\nimport { StateInterpolator } from './StateInterpolator.js';\nexport class LagrangeInterpolator extends StateInterpolator {\n    t_;\n    x_;\n    y_;\n    z_;\n    order;\n    constructor(t, x, y, z, order = 10) {\n        super();\n        this.t_ = t;\n        this.x_ = x;\n        this.y_ = y;\n        this.z_ = z;\n        this.order = order;\n    }\n    /**\n     * Creates a LagrangeInterpolator from an array of J2000 ephemeris data.\n     * @param ephemeris - The array of J2000 ephemeris data.\n     * @param order - The order of the LagrangeInterpolator. Default is 10.\n     * @returns A new LagrangeInterpolator instance.\n     */\n    static fromEphemeris(ephemeris, order = 10) {\n        const k = ephemeris.length;\n        const t = new Float64Array(k);\n        const x = new Float64Array(k);\n        const y = new Float64Array(k);\n        const z = new Float64Array(k);\n        for (let i = 0; i < k; i++) {\n            const state = ephemeris[i];\n            t[i] = state.epoch.posix;\n            x[i] = state.position.x;\n            y[i] = state.position.y;\n            z[i] = state.position.z;\n        }\n        return new LagrangeInterpolator(t, x, y, z, order);\n    }\n    get sizeBytes() {\n        return (64 * 4 * this.t_.length) / 8;\n    }\n    interpolate(epoch) {\n        if (!this.inWindow(epoch)) {\n            return null;\n        }\n        const posix = epoch.posix;\n        const subDex = this.slice_(posix);\n        const start = subDex.left;\n        const stop = subDex.right;\n        const ts = this.t_.subarray(start, stop);\n        const xs = this.x_.subarray(start, stop);\n        const ys = this.y_.subarray(start, stop);\n        const zs = this.z_.subarray(start, stop);\n        const position = new Vector3D(LagrangeInterpolator.position_(ts, xs, posix), LagrangeInterpolator.position_(ts, ys, posix), LagrangeInterpolator.position_(ts, zs, posix));\n        const velocity = new Vector3D(LagrangeInterpolator.velocity_(ts, xs, posix), LagrangeInterpolator.velocity_(ts, ys, posix), LagrangeInterpolator.velocity_(ts, zs, posix));\n        return new J2000(epoch, position, velocity);\n    }\n    static position_(xs, ys, x) {\n        const k = xs.length - 1;\n        let result = 0.0;\n        for (let j = 0; j < k; j++) {\n            let product = ys[j];\n            for (let m = 0; m < k; m++) {\n                if (j === m) {\n                    continue;\n                }\n                product *= (x - xs[m]) / (xs[j] - xs[m]);\n            }\n            result += product;\n        }\n        return result;\n    }\n    static velocity_(xs, ys, x) {\n        const k = xs.length;\n        let result = 0.0;\n        for (let j = 0; j < k; j++) {\n            let total = 0.0;\n            for (let i = 0; i < k; i++) {\n                if (i === j) {\n                    continue;\n                }\n                let product = 1 / (xs[j] - xs[i]);\n                for (let m = 0; m < k; m++) {\n                    if (m === i || m === j) {\n                        continue;\n                    }\n                    product *= (x - xs[m]) / (xs[j] - xs[m]);\n                }\n                total += product;\n            }\n            result += ys[j] * total;\n        }\n        return result;\n    }\n    static _getClosest(target, t1, d1, t2, d2) {\n        return target - t1 >= t2 - target ? d2 : d1;\n    }\n    slice_(posix) {\n        const n = this.t_.length;\n        if (posix <= this.t_[0]) {\n            return { left: 0, right: this.order };\n        }\n        if (posix >= this.t_[n - 1]) {\n            return { left: n - this.order, right: n };\n        }\n        let i = 0;\n        let j = this.t_.length;\n        let mid = 0;\n        while (i < j) {\n            mid = (i + j) >> 1;\n            if (this.t_[mid] === posix) {\n                break;\n            }\n            if (posix < this.t_[mid]) {\n                if (mid > 0 && posix > this.t_[mid - 1]) {\n                    mid = LagrangeInterpolator._getClosest(posix, this.t_[mid - 1], mid - 1, this.t_[mid], mid);\n                    break;\n                }\n                j = mid;\n            }\n            else {\n                if (mid < this.t_.length - 1 && posix < this.t_[mid + 1]) {\n                    mid = LagrangeInterpolator._getClosest(posix, this.t_[mid], mid, this.t_[mid + 1], mid + 1);\n                    break;\n                }\n                i = mid + 1;\n            }\n        }\n        const offset = Math.floor(this.order / 2);\n        const left = mid - offset;\n        const right = mid + offset - (this.order % 2 === 1 ? 1 : 0);\n        if (left < 0) {\n            return { left: 0, right: this.order };\n        }\n        if (right > n) {\n            return { left: n - this.order, right: n };\n        }\n        return { left, right };\n    }\n    window() {\n        return new EpochWindow(new EpochUTC(this.t_[0]), new EpochUTC(this.t_[this.t_.length - 1]));\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\n/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable class-methods-use-this */\nimport { Interpolator } from './Interpolator.js';\n// / Base class for state vector interpolators.\nexport class StateInterpolator extends Interpolator {\n    /**\n     * Interpolates the state at the given epoch.\n     * @param epoch The epoch in UTC format.\n     * @throws If the interpolator has not been initialized.\n     */\n    interpolate(epoch) {\n        throw new Error('Not implemented.');\n    }\n    // / Return the size _(bytes)_ of this interpolator's cached data.\n    get sizeBytes() {\n        throw new Error('Not implemented.');\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { copySign, Earth, EpochWindow, J2000, } from '../main.js';\nimport { CubicSplineInterpolator } from './CubicSplineInterpolator.js';\nimport { LagrangeInterpolator } from './LagrangeInterpolator.js';\nimport { StateInterpolator } from './StateInterpolator.js';\n/**\n * Two-body Velocity Verlet Blend interpolator.\n *\n * The [VerletBlendInterpolator] retains the original ephemerides, so the\n * original _\"truth\"_ states can be retrieved if needed without imparting any\n * additional error, so this can be used to build other interpolator types.\n * The implementation is simple and very tolerant when working with sparse\n * ephemerides.\n */\nexport class VerletBlendInterpolator extends StateInterpolator {\n    ephemeris;\n    constructor(ephemeris) {\n        super();\n        this.ephemeris = ephemeris;\n    }\n    get sizeBytes() {\n        return (64 * 7 * this.ephemeris.length) / 8;\n    }\n    window() {\n        return new EpochWindow(this.ephemeris[0].epoch, this.ephemeris[this.ephemeris.length - 1].epoch);\n    }\n    static getClosest_(target, s1, s2) {\n        return target - s1.epoch.posix >= s2.epoch.posix - target ? s2 : s1;\n    }\n    matchState_(epoch) {\n        const target = epoch.posix;\n        if (target <= this.ephemeris[0].epoch.posix) {\n            return this.ephemeris[0];\n        }\n        if (target >= this.ephemeris[this.ephemeris.length - 1].epoch.posix) {\n            return this.ephemeris[this.ephemeris.length - 1];\n        }\n        let i = 0;\n        let j = this.ephemeris.length;\n        let mid = 0;\n        while (i < j) {\n            mid = (i + j) >> 1;\n            if (this.ephemeris[mid].epoch.posix === target) {\n                return this.ephemeris[mid];\n            }\n            if (target < this.ephemeris[mid].epoch.posix) {\n                if (mid > 0 && target > this.ephemeris[mid - 1].epoch.posix) {\n                    return VerletBlendInterpolator.getClosest_(target, this.ephemeris[mid - 1], this.ephemeris[mid]);\n                }\n                j = mid;\n            }\n            else {\n                if (mid < this.ephemeris.length - 1 && target < this.ephemeris[mid + 1].epoch.posix) {\n                    return VerletBlendInterpolator.getClosest_(target, this.ephemeris[mid], this.ephemeris[mid + 1]);\n                }\n                i = mid + 1;\n            }\n        }\n        return this.ephemeris[mid];\n    }\n    static _gravity(position) {\n        const r = position.magnitude();\n        return position.scale(-Earth.mu / (r * r * r));\n    }\n    static integrate_(state, step) {\n        const x0 = state.position;\n        const a0 = VerletBlendInterpolator._gravity(x0);\n        const v0 = state.velocity;\n        const x1 = x0\n            .add(v0.scale(step))\n            .add(a0.scale(0.5 * step * step));\n        const a1 = VerletBlendInterpolator._gravity(x1);\n        const v1 = v0\n            .add(a0.add(a1).scale(0.5 * step));\n        return new J2000(state.epoch.roll(step), x1, v1);\n    }\n    interpolate(epoch) {\n        if (!this.inWindow(epoch)) {\n            return null;\n        }\n        let state = this.matchState_(epoch);\n        while (state.epoch.posix !== epoch.posix) {\n            const delta = epoch.posix - state.epoch.posix;\n            const stepMag = Math.min(5.0, Math.abs(delta));\n            const stepSize = copySign(stepMag, delta);\n            state = VerletBlendInterpolator.integrate_(state, stepSize);\n        }\n        return state;\n    }\n    getCachedState(epoch) {\n        if (!this.inWindow(epoch)) {\n            return null;\n        }\n        return this.matchState_(epoch);\n    }\n    toCubicSpline() {\n        return CubicSplineInterpolator.fromEphemeris(this.ephemeris);\n    }\n    toLagrange(order = 10) {\n        return LagrangeInterpolator.fromEphemeris(this.ephemeris, order);\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nexport * from './enums/index.js';\nexport * from './types/types.js';\nexport * from './interfaces/index.js';\nexport * from './time/index.js';\nexport * from './transforms/index.js';\nexport * from './utils/index.js';\nexport * from './operations/operations.js';\nexport { BaseObject } from './objects/index.js';\nexport { Earth } from './body/index.js';\nexport * from './coordinate/index.js';\nexport * from './observation/index.js';\nexport * from './data/DataHandler.js';\nexport * from './sgp4/index.js';\nexport * from './objects/index.js';\nexport * from './body/index.js';\nexport * from './operations/index.js';\nexport * from './force/index.js';\nexport * from './propagator/index.js';\nexport * from './orbit_determination/index.js';\nexport * from './covariance/index.js';\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { SpaceObjectType } from '../types/types.js';\nexport class BaseObject {\n    id;\n    name;\n    type;\n    position; // Where is the object\n    totalVelocity; // How fast is the object moving\n    velocity; // How fast is the object moving\n    active = true; // Is the object active\n    constructor(info) {\n        this.type = info.type ?? SpaceObjectType.UNKNOWN;\n        this.name = info.name ?? 'Unknown';\n        this.id = info.id ?? -1; // Default to -1 if no id is provided\n        this.active = info.active ?? true;\n        // Default to the center of the earth until position is calculated\n        this.position = info.position ?? {\n            x: 0,\n            y: 0,\n            z: 0,\n        };\n        // Default to 0 velocity until velocity is calculated\n        this.velocity = info.velocity ?? {\n            x: 0,\n            y: 0,\n            z: 0,\n        };\n        this.totalVelocity = Math.sqrt(this.velocity.x ** 2 + this.velocity.y ** 2 + this.velocity.z ** 2);\n    }\n    /**\n     * Checks if the object is a satellite.\n     * @returns True if the object is a satellite, false otherwise.\n     */\n    isSatellite() {\n        return false;\n    }\n    /**\n     * Checks if the object is a ground object.\n     * @returns True if the object is a ground object, false otherwise.\n     */\n    isGroundObject() {\n        return false;\n    }\n    /**\n     * Returns whether the object is a sensor.\n     * @returns True if the object is a sensor, false otherwise.\n     */\n    isSensor() {\n        return false;\n    }\n    /**\n     * Checks if the object is a marker.\n     * @returns True if the object is a marker, false otherwise.\n     */\n    isMarker() {\n        return false;\n    }\n    /**\n     * Returns whether the object's position is static.\n     * @returns True if the object is static, false otherwise.\n     */\n    isStatic() {\n        return this.velocity.x === 0 && this.velocity.y === 0 && this.velocity.z === 0;\n    }\n    isPayload() {\n        return this.type === SpaceObjectType.PAYLOAD;\n    }\n    isRocketBody() {\n        return this.type === SpaceObjectType.ROCKET_BODY;\n    }\n    isDebris() {\n        return this.type === SpaceObjectType.DEBRIS;\n    }\n    isStar() {\n        return this.type === SpaceObjectType.STAR;\n    }\n    isMissile() {\n        return this.type === SpaceObjectType.BALLISTIC_MISSILE;\n    }\n    isNotional() {\n        return this.type === SpaceObjectType.NOTIONAL;\n    }\n    getTypeString() {\n        const typeToStringMap = {\n            [SpaceObjectType.UNKNOWN]: 'Unknown',\n            [SpaceObjectType.PAYLOAD]: 'Payload',\n            [SpaceObjectType.ROCKET_BODY]: 'Rocket Body',\n            [SpaceObjectType.DEBRIS]: 'Debris',\n            [SpaceObjectType.SPECIAL]: 'Special',\n            [SpaceObjectType.BALLISTIC_MISSILE]: 'Ballistic Missile',\n            [SpaceObjectType.STAR]: 'Star',\n            [SpaceObjectType.INTERGOVERNMENTAL_ORGANIZATION]: 'Intergovernmental Organization',\n            [SpaceObjectType.SUBORBITAL_PAYLOAD_OPERATOR]: 'Suborbital Payload Operator',\n            [SpaceObjectType.PAYLOAD_OWNER]: 'Payload Owner',\n            [SpaceObjectType.METEOROLOGICAL_ROCKET_LAUNCH_AGENCY_OR_MANUFACTURER]: 'Meteorological Rocket Launch Agency or Manufacturer',\n            [SpaceObjectType.PAYLOAD_MANUFACTURER]: 'Payload Manufacturer',\n            [SpaceObjectType.LAUNCH_AGENCY]: 'Launch Agency',\n            [SpaceObjectType.LAUNCH_SITE]: 'Launch Site',\n            [SpaceObjectType.LAUNCH_POSITION]: 'Launch Position',\n            [SpaceObjectType.LAUNCH_FACILITY]: 'Launch Facility',\n            [SpaceObjectType.CONTROL_FACILITY]: 'Control Facility',\n            [SpaceObjectType.GROUND_SENSOR_STATION]: 'Ground Sensor Station',\n            [SpaceObjectType.OPTICAL]: 'Optical',\n            [SpaceObjectType.MECHANICAL]: 'Mechanical',\n            [SpaceObjectType.PHASED_ARRAY_RADAR]: 'Phased Array Radar',\n            [SpaceObjectType.OBSERVER]: 'Observer',\n            [SpaceObjectType.BISTATIC_RADIO_TELESCOPE]: 'Bistatic Radio Telescope',\n            [SpaceObjectType.COUNTRY]: 'Country',\n            [SpaceObjectType.LAUNCH_VEHICLE_MANUFACTURER]: 'Launch Vehicle Manufacturer',\n            [SpaceObjectType.ENGINE_MANUFACTURER]: 'Engine Manufacturer',\n        };\n        return typeToStringMap[this.type] ?? 'Unknown';\n    }\n    /**\n     * Validates a parameter value against a minimum and maximum value.\n     * @param value - The value to be validated.\n     * @param minValue - The minimum allowed value.\n     * @param maxValue - The maximum allowed value.\n     * @param errorMessage - The error message to be thrown if the value is invalid.\n     */\n    validateParameter(value, minValue, maxValue, errorMessage) {\n        if (typeof minValue !== 'undefined' && minValue !== null && value < minValue) {\n            throw new Error(errorMessage);\n        }\n        if (typeof maxValue !== 'undefined' && maxValue !== null && value > maxValue) {\n            throw new Error(errorMessage);\n        }\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { CatalogSource, FormatTle, } from '../main.js';\nimport { PayloadStatus } from '../types/types.js';\nimport { Satellite } from './Satellite.js';\n/**\n * Represents a detailed satellite object with launch, spacecraft, and operations details.\n */\nexport class DetailedSatellite extends Satellite {\n    configuration = '';\n    country = '';\n    dryMass = '';\n    equipment = '';\n    launchDate = '';\n    launchMass = '';\n    launchSite = '';\n    launchPad = '';\n    launchVehicle = '';\n    lifetime = '';\n    maneuver = '';\n    manufacturer = '';\n    mission = '';\n    bus = '';\n    motor = '';\n    owner = '';\n    payload = '';\n    power = '';\n    purpose = '';\n    length = '';\n    diameter = '';\n    shape = '';\n    span = '';\n    user = '';\n    source = '';\n    vmag;\n    rcs;\n    altId = '';\n    altName = '';\n    status = PayloadStatus.UNKNOWN;\n    constructor(\n    // TODO: Replace this intersection with a type alias\n    info, options) {\n        if (info.source === CatalogSource.VIMPEL) {\n            info = DetailedSatellite.setSccNumTo0_(info);\n        }\n        super(info, options);\n        this.active ??= true;\n        this.initSpaceCraftDetails_(info);\n        this.length = info.length ?? '';\n        this.diameter = info.diameter ?? '';\n        this.source = info.source ?? '';\n        this.vmag = info.vmag ?? null;\n        this.rcs = info.rcs ?? null;\n        this.altId = info.altId ?? '';\n        this.altName = info.altName ?? '';\n        this.initOperationDetails_(info);\n        this.initLaunchDetails_(info);\n        this.status = info.status ?? PayloadStatus.UNKNOWN;\n    }\n    static setSccNumTo0_(info) {\n        info.tle1 = FormatTle.setCharAt(info.tle1, 2, '0');\n        info.tle1 = FormatTle.setCharAt(info.tle1, 3, '0');\n        info.tle1 = FormatTle.setCharAt(info.tle1, 4, '0');\n        info.tle1 = FormatTle.setCharAt(info.tle1, 5, '0');\n        info.tle1 = FormatTle.setCharAt(info.tle1, 6, '0');\n        info.tle2 = FormatTle.setCharAt(info.tle2, 2, '0');\n        info.tle2 = FormatTle.setCharAt(info.tle2, 3, '0');\n        info.tle2 = FormatTle.setCharAt(info.tle2, 4, '0');\n        info.tle2 = FormatTle.setCharAt(info.tle2, 5, '0');\n        info.tle2 = FormatTle.setCharAt(info.tle2, 6, '0');\n        return info;\n    }\n    initSpaceCraftDetails_(info) {\n        this.lifetime = info.lifetime ?? '';\n        this.maneuver = info.maneuver ?? '';\n        this.manufacturer = info.manufacturer ?? '';\n        this.motor = info.motor ?? '';\n        this.power = info.power ?? '';\n        this.payload = info.payload ?? '';\n        this.purpose = info.purpose ?? '';\n        this.shape = info.shape ?? '';\n        this.span = info.span ?? '';\n        this.bus = info.bus ?? '';\n        this.configuration = info.configuration ?? '';\n        this.equipment = info.equipment ?? '';\n        this.dryMass = info.dryMass ?? '';\n    }\n    initOperationDetails_(info) {\n        this.mission = info.mission ?? '';\n        this.user = info.user ?? '';\n        this.owner = info.owner ?? '';\n        this.country = info.country ?? '';\n    }\n    initLaunchDetails_(info) {\n        this.launchDate = info.launchDate ?? '';\n        this.launchMass = info.launchMass ?? '';\n        this.launchSite = info.launchSite ?? '';\n        this.launchPad = info.launchPad ?? '';\n        this.launchVehicle = info.launchVehicle ?? '';\n    }\n    /**\n     * Returns the launch details of the satellite.\n     * @returns An object containing the launch date, launch mass, launch site, and launch vehicle of the satellite.\n     */\n    getLaunchDetails() {\n        return {\n            launchDate: this.launchDate,\n            launchMass: this.launchMass,\n            launchSite: this.launchSite,\n            launchVehicle: this.launchVehicle,\n        };\n    }\n    /**\n     * Returns an object containing the details of the operations.\n     * @returns An object containing the user, mission, owner, and country details.\n     */\n    getOperationsDetails() {\n        return {\n            user: this.user,\n            mission: this.mission,\n            owner: this.owner,\n            country: this.country,\n        };\n    }\n    /**\n     * Returns the space craft details.\n     * @returns The space craft details.\n     */\n    getSpaceCraftDetails() {\n        return {\n            lifetime: this.lifetime,\n            maneuver: this.maneuver,\n            manufacturer: this.manufacturer,\n            motor: this.motor,\n            power: this.power,\n            payload: this.payload,\n            purpose: this.purpose,\n            shape: this.shape,\n            span: this.span,\n            configuration: this.configuration,\n            equipment: this.equipment,\n            dryMass: this.dryMass,\n        };\n    }\n    clone() {\n        return new DetailedSatellite(this);\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { Sensor } from './Sensor.js';\nexport class DetailedSensor extends Sensor {\n    sensorId;\n    objName;\n    shortName;\n    uiName;\n    country;\n    dwellTime;\n    freqBand;\n    commLinks;\n    /** Is this sensor volumetric? */\n    isVolumetric;\n    /** The ideal zoom to see the sensor's full FOV */\n    zoom;\n    system;\n    operator;\n    url;\n    constructor(info) {\n        super(info);\n        this.commLinks = info.commLinks ?? [];\n        this.country = info.country;\n        this.dwellTime = info.changeObjectInterval;\n        this.freqBand = info.freqBand;\n        this.isVolumetric = info.volume;\n        this.objName = info.objName;\n        this.operator = info.operator;\n        this.sensorId = info.sensorId;\n        this.shortName = info.shortName;\n        this.system = info.system;\n        this.uiName = info.uiName;\n        this.url = info.url;\n        this.zoom = info.zoom;\n    }\n    isStatic() {\n        return true;\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { DEG2RAD, Geodetic, SpaceObjectType, calcGmst, lla2eci, llaRad2ecf, } from '../main.js';\nimport { BaseObject } from './BaseObject.js';\nexport class GroundObject extends BaseObject {\n    name = 'Unknown Ground Object';\n    lat;\n    lon;\n    alt;\n    constructor(info) {\n        super(info);\n        this.validateGroundObjectInputData_(info);\n        this.name = info.name ?? this.name;\n        this.lat = info.lat;\n        this.lon = info.lon;\n        this.alt = info.alt;\n    }\n    /**\n     * Calculates the relative azimuth, elevation, and range between this GroundObject and a Satellite.\n     * @param satellite The Satellite object.\n     * @param date The date for which to calculate the RAE values. Defaults to the current date.\n     * @returns The relative azimuth, elevation, and range values in kilometers and degrees.\n     */\n    rae(satellite, date = new Date()) {\n        return satellite.rae(this, date);\n    }\n    /**\n     * Calculates ECF position at a given time.\n     * @variation optimized version of this.toGeodetic().toITRF().position;\n     * @returns The ECF position vector of the ground object.\n     */\n    ecf() {\n        return llaRad2ecf(this.toGeodetic());\n    }\n    /**\n     * Calculates the Earth-Centered Inertial (ECI) position vector of the ground object at a given date.\n     * @variation optimzed version of this.toGeodetic().toITRF().toJ2000().position;\n     * @param date The date for which to calculate the ECI position vector. Defaults to the current date.\n     * @returns The ECI position vector of the ground object.\n     */\n    eci(date = new Date()) {\n        const { gmst } = calcGmst(date);\n        return lla2eci(this.toGeodetic(), gmst);\n    }\n    /**\n     * Returns the latitude, longitude, and altitude of the GroundObject.\n     * @returns The latitude, longitude, and altitude as an LlaVec3 object.\n     */\n    lla() {\n        return {\n            lat: this.lat,\n            lon: this.lon,\n            alt: this.alt,\n        };\n    }\n    /**\n     * Converts the latitude, longitude, and altitude of the GroundObject to radians and kilometers.\n     * @variation optimized version of this.toGeodetic() without class instantiation for better performance and\n     * serialization.\n     * @returns An object containing the latitude, longitude, and altitude in\n     * radians and kilometers.\n     */\n    llaRad() {\n        return {\n            lat: (this.lat * DEG2RAD),\n            lon: (this.lon * DEG2RAD),\n            alt: this.alt,\n        };\n    }\n    get latRad() {\n        return this.lat * DEG2RAD;\n    }\n    get lonRad() {\n        return this.lon * DEG2RAD;\n    }\n    /**\n     * Creates a GroundObject object from a Geodetic position.\n     * @param geodetic The geodetic coordinates.\n     * @returns A new GroundObject object.\n     */\n    static fromGeodetic(geodetic) {\n        return new GroundObject({\n            lat: geodetic.latDeg,\n            lon: geodetic.lonDeg,\n            alt: geodetic.alt,\n        });\n    }\n    /**\n     * Converts the ground position to geodetic coordinates.\n     * @returns The geodetic coordinates.\n     */\n    toGeodetic() {\n        return Geodetic.fromDegrees(this.lat, this.lon, this.alt);\n    }\n    /**\n     * Validates the input data for the GroundObject.\n     * @param info - The GroundPositionParams object containing the latitude,\n     * longitude, and altitude. @returns void\n     */\n    validateGroundObjectInputData_(info) {\n        this.validateParameter(info.lat, -90, 90, 'Invalid latitude - must be between -90 and 90');\n        this.validateParameter(info.lon, -180, 180, 'Invalid longitude - must be between -180 and 180');\n        this.validateParameter(info.alt, 0, null, 'Invalid altitude - must be greater than 0');\n    }\n    isGroundObject() {\n        switch (this.type) {\n            case SpaceObjectType.INTERGOVERNMENTAL_ORGANIZATION:\n            case SpaceObjectType.SUBORBITAL_PAYLOAD_OPERATOR:\n            case SpaceObjectType.PAYLOAD_OWNER:\n            case SpaceObjectType.METEOROLOGICAL_ROCKET_LAUNCH_AGENCY_OR_MANUFACTURER:\n            case SpaceObjectType.PAYLOAD_MANUFACTURER:\n            case SpaceObjectType.LAUNCH_VEHICLE_MANUFACTURER:\n            case SpaceObjectType.ENGINE_MANUFACTURER:\n            case SpaceObjectType.LAUNCH_AGENCY:\n            case SpaceObjectType.LAUNCH_SITE:\n            case SpaceObjectType.LAUNCH_POSITION:\n                return true;\n            default:\n                return false;\n        }\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { BaseObject } from './BaseObject.js';\nexport class LandObject extends BaseObject {\n    lat;\n    lon;\n    alt;\n    country;\n    Code;\n    constructor(info) {\n        super(info);\n        this.lat = info.lat;\n        this.lon = info.lon;\n        this.alt = info.alt;\n    }\n    isLandObject() {\n        return true;\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { BaseObject } from './BaseObject.js';\n/* eslint-disable class-methods-use-this */\nexport class Marker extends BaseObject {\n    isMarker() {\n        return true;\n    }\n}\n","/**\n * @author Theodore Kruczek.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2022-2024 Theodore Kruczek Permission is\n * hereby granted, free of charge, to any person obtaining a copy of this\n * software and associated documentation files (the \"Software\"), to deal in the\n * Software without restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do\n * so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nimport { DEG2RAD, RAD2DEG, SpaceObjectType, azel2uv, uv2azel } from '../main.js';\nimport { DetailedSensor } from './DetailedSensor.js';\nexport class RfSensor extends DetailedSensor {\n    boresightAz;\n    boresightEl;\n    faces;\n    beamwidth;\n    constructor(info) {\n        super(info);\n        switch (info.type) {\n            case SpaceObjectType.BISTATIC_RADIO_TELESCOPE:\n            case SpaceObjectType.MECHANICAL:\n            case SpaceObjectType.PHASED_ARRAY_RADAR:\n                break;\n            default:\n                throw new Error('Invalid sensor type');\n        }\n        this.boresightAz = info.boresightAz;\n        this.boresightEl = info.boresightEl;\n        if (info.boresightAz.length !== info.boresightEl.length) {\n            throw new Error('Boresight azimuth and elevation arrays must be the same length');\n        }\n        this.faces = info.boresightAz.length;\n        this.beamwidth = info.beamwidth;\n    }\n    /**\n     * Converts azimuth and elevation angles to unit vector coordinates.\n     * @param az - The azimuth angle in degrees.\n     * @param el - The elevation angle in degrees.\n     * @param face - The face number (optional).\n     * @returns The unit vector coordinates.\n     */\n    uvFromAzEl(az, el, face) {\n        const azRad = (az * DEG2RAD);\n        const elRad = (el * DEG2RAD);\n        const azDiff = (azRad - this.boresightAzRad(face ?? 0));\n        const elDiff = (elRad - this.boresightElRad(face ?? 0));\n        return azel2uv(azDiff, elDiff, this.beamwidthRad);\n    }\n    /**\n     * Converts the given UV coordinates to azimuth and elevation angles.\n     * @param u - The U coordinate.\n     * @param v - The V coordinate.\n     * @param face - The face number for multi-faced sensors. (optional)\n     * @returns An object containing the azimuth and elevation angles in degrees.\n     * @throws Error if face number is not specified for multi-faced sensors.\n     */\n    azElFromUV(u, v, face) {\n        if (!face && this.faces > 1) {\n            throw new Error('Face number must be specified for multi-faced sensors');\n        }\n        const { az, el } = uv2azel(u, v, this.beamwidthRad);\n        return {\n            az: ((az + this.boresightAz[face ?? 0]) * RAD2DEG),\n            el: ((el + this.boresightEl[face ?? 0]) * RAD2DEG),\n        };\n    }\n    /**\n     * Converts the boresight azimuth angle to radians.\n     * @param face - The face number for multi-faced sensors. (Optional)\n     * @returns The boresight azimuth angle in radians.\n     * @throws An error if the face number is not specified for multi-faced sensors.\n     */\n    boresightAzRad(face) {\n        if (!face && this.faces > 1) {\n            throw new Error('Face number must be specified for multi-faced sensors');\n        }\n        return (this.boresightAz[face ?? 0] * DEG2RAD);\n    }\n    /**\n     * Converts the boresight elevation angle of the sensor to radians.\n     * @param face - The face number of the sensor (optional for single-faced sensors).\n     * @returns The boresight elevation angle in radians.\n     * @throws Error if the face number is not specified for multi-faced sensors.\n     */\n    boresightElRad(face) {\n        if (!face && this.faces > 1) {\n            throw new Error('Face number must be specified for multi-faced sensors');\n        }\n        return (this.boresightEl[face ?? 0] * DEG2RAD);\n    }\n    /**\n     * Gets the beamwidth in radians.\n     * @returns The beamwidth in radians.\n     */\n    get beamwidthRad() {\n        return (this.beamwidth * DEG2RAD);\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { J2000 } from '../coordinate/J2000.js';\nimport { RIC } from '../coordinate/RIC.js';\nimport { Tle } from '../coordinate/Tle.js';\nimport { Sgp4 } from '../main.js';\nimport { RAE } from '../observation/RAE.js';\nimport { Vector3D } from '../operations/Vector3D.js';\nimport { EpochUTC } from '../time/EpochUTC.js';\nimport { ecf2rae, eci2ecf, eci2lla, jday } from '../transforms/index.js';\nimport { DEG2RAD, MILLISECONDS_TO_DAYS, MINUTES_PER_DAY, RAD2DEG } from '../utils/constants.js';\nimport { dopplerFactor } from './../utils/functions.js';\nimport { BaseObject } from './BaseObject.js';\n/**\n * Represents a satellite object with orbital information and methods for\n * calculating its position and other properties.\n */\nexport class Satellite extends BaseObject {\n    apogee;\n    argOfPerigee;\n    bstar;\n    eccentricity;\n    epochDay;\n    epochYear;\n    inclination;\n    intlDes;\n    meanAnomaly;\n    meanMoDev1;\n    meanMoDev2;\n    meanMotion;\n    options;\n    perigee;\n    period;\n    rightAscension;\n    satrec;\n    /** The satellite catalog number as listed in the TLE. */\n    sccNum;\n    /** The 5 digit alpha-numeric satellite catalog number. */\n    sccNum5;\n    /** The 6 digit numeric satellite catalog number. */\n    sccNum6;\n    tle1;\n    tle2;\n    /** The semi-major axis of the satellite's orbit. */\n    semiMajorAxis;\n    /** The semi-minor axis of the satellite's orbit. */\n    semiMinorAxis;\n    constructor(info, options) {\n        super(info);\n        if (info.tle1 && info.tle2) {\n            this.parseTleAndUpdateOrbit_(info.tle1, info.tle2, info.sccNum);\n        }\n        else if (info.omm) {\n            this.parseOmmAndUpdateOrbit_(info.omm);\n        }\n        else {\n            throw new Error('tle1 and tle2 or omm must be provided to create a Satellite object.');\n        }\n        this.options = options ?? {\n            notes: '',\n        };\n    }\n    parseTleAndUpdateOrbit_(tle1, tle2, sccNum) {\n        const tleData = Tle.parse(tle1, tle2);\n        this.tle1 = tle1;\n        this.tle2 = tle2;\n        this.sccNum = sccNum ?? tleData.satNum.toString();\n        this.sccNum5 = Tle.convert6DigitToA5(this.sccNum);\n        this.sccNum6 = Tle.convertA5to6Digit(this.sccNum5);\n        this.intlDes = tleData.intlDes;\n        this.epochYear = tleData.epochYear;\n        this.epochDay = tleData.epochDay;\n        this.meanMoDev1 = tleData.meanMoDev1;\n        this.meanMoDev2 = tleData.meanMoDev2;\n        this.bstar = tleData.bstar;\n        this.inclination = tleData.inclination;\n        this.rightAscension = tleData.rightAscension;\n        this.eccentricity = tleData.eccentricity;\n        this.argOfPerigee = tleData.argOfPerigee;\n        this.meanAnomaly = tleData.meanAnomaly;\n        this.meanMotion = tleData.meanMotion;\n        this.period = tleData.period;\n        this.semiMajorAxis = ((8681663.653 / this.meanMotion) ** (2 / 3));\n        this.semiMinorAxis = (this.semiMajorAxis * Math.sqrt(1 - this.eccentricity ** 2));\n        this.apogee = (this.semiMajorAxis * (1 + this.eccentricity) - 6371);\n        this.perigee = (this.semiMajorAxis * (1 - this.eccentricity) - 6371);\n        this.satrec = Sgp4.createSatrec(tle1, tle2);\n    }\n    parseOmmAndUpdateOrbit_(omm) {\n        this.sccNum = omm.NORAD_CAT_ID.padStart(5, '0');\n        this.sccNum5 = Tle.convert6DigitToA5(omm.NORAD_CAT_ID);\n        this.sccNum6 = Tle.convertA5to6Digit(this.sccNum5);\n        this.intlDes = omm.OBJECT_ID;\n        const YYYY = omm.EPOCH.slice(0, 4);\n        const MM = omm.EPOCH.slice(5, 7);\n        const DD = omm.EPOCH.slice(8, 10);\n        const hh = omm.EPOCH.slice(11, 13);\n        const mm = omm.EPOCH.slice(14, 16);\n        const ss = omm.EPOCH.slice(17, 23);\n        const epochDateObj = Date.UTC(Number(YYYY), Number(MM) - 1, Number(DD), Number(hh), Number(mm), Number(ss));\n        const dayOfYear = (epochDateObj - Date.UTC(Number(YYYY), 0, 0)) / 86400000;\n        const ommParsed = {\n            ...omm,\n            epoch: {\n                year: Number(YYYY),\n                month: Number(MM),\n                day: Number(DD),\n                hour: Number(hh),\n                minute: Number(mm),\n                second: Number(ss),\n                doy: dayOfYear,\n            },\n        };\n        this.epochYear = parseInt(YYYY.slice(2, 4));\n        this.epochDay = dayOfYear;\n        this.meanMoDev1 = parseFloat(omm.MEAN_MOTION_DOT);\n        this.meanMoDev2 = parseFloat(omm.MEAN_MOTION_DDOT);\n        this.bstar = parseFloat(omm.BSTAR);\n        this.inclination = parseFloat(omm.INCLINATION);\n        this.rightAscension = parseFloat(omm.RA_OF_ASC_NODE);\n        this.eccentricity = parseFloat(omm.ECCENTRICITY);\n        this.argOfPerigee = parseFloat(omm.ARG_OF_PERICENTER);\n        this.meanAnomaly = parseFloat(omm.MEAN_ANOMALY);\n        this.meanMotion = parseFloat(omm.MEAN_MOTION);\n        this.period = 1440 / this.meanMotion;\n        this.semiMajorAxis = ((8681663.653 / this.meanMotion) ** (2 / 3));\n        this.semiMinorAxis = (this.semiMajorAxis * Math.sqrt(1 - this.eccentricity ** 2));\n        this.apogee = (this.semiMajorAxis * (1 + this.eccentricity) - 6371);\n        this.perigee = (this.semiMajorAxis * (1 - this.eccentricity) - 6371);\n        this.satrec = Sgp4.createSatrecFromOmm(ommParsed);\n    }\n    /**\n     * Checks if the object is a satellite.\n     * @returns True if the object is a satellite, false otherwise.\n     */\n    isSatellite() {\n        return true;\n    }\n    /**\n     * Returns whether the satellite is static or not.\n     * @returns True if the satellite is static, false otherwise.\n     */\n    isStatic() {\n        return false;\n    }\n    /**\n     * Checks if the given SatelliteRecord object is valid by checking if its properties are all numbers.\n     * @param satrec - The SatelliteRecord object to check.\n     * @returns True if the SatelliteRecord object is valid, false otherwise.\n     */\n    static isValidSatrec(satrec) {\n        if (isNaN(satrec.a) ||\n            isNaN(satrec.am) ||\n            isNaN(satrec.alta) ||\n            isNaN(satrec.em) ||\n            isNaN(satrec.mo) ||\n            isNaN(satrec.ecco) ||\n            isNaN(satrec.no)) {\n            return false;\n        }\n        return true;\n    }\n    ageOfElset(nowInput, outputUnits = 'days') {\n        return Tle.calcElsetAge(this.tle1, nowInput, outputUnits);\n    }\n    editTle(tle1, tle2, sccNum) {\n        this.parseTleAndUpdateOrbit_(tle1, tle2, sccNum);\n    }\n    /**\n     * Calculates the azimuth angle of the satellite relative to the given sensor at the specified date. If no date is\n     * provided, the current time of the satellite is used.\n     * @variation optimized\n     * @param observer - The observer's position on the ground.\n     * @param date - The date at which to calculate the azimuth angle. Optional, defaults to the current date.\n     * @returns The azimuth angle of the satellite relative to the given sensor at the specified date.\n     */\n    az(observer, date = new Date()) {\n        const rae = this.rae(observer, date);\n        if (!rae) {\n            return null;\n        }\n        return (rae.az * RAD2DEG);\n    }\n    /**\n     * Calculates the RAE (Range, Azimuth, Elevation) values for a given sensor and date. If no date is provided, the\n     * current time is used.\n     * @variation expanded\n     * @param observer - The observer's position on the ground.\n     * @param date - The date at which to calculate the RAE values. Optional, defaults to the current date.\n     * @returns The RAE values for the given sensor and date.\n     */\n    toRae(observer, date = new Date()) {\n        const rae = this.rae(observer, date);\n        if (!rae) {\n            return null;\n        }\n        const rae2 = this.rae(observer, new Date(date.getTime() + 1000));\n        if (!rae2) {\n            return null;\n        }\n        const epoch = new EpochUTC(date.getTime() / 1000);\n        const rangeRate = rae2.rng - rae.rng;\n        const azimuthRate = rae2.az - rae.az;\n        const elevationRate = rae2.el - rae.el;\n        return new RAE(epoch, rae.rng, (rae.az * DEG2RAD), (rae.el * DEG2RAD), rangeRate, azimuthRate, elevationRate);\n    }\n    /**\n     * Calculates ECF position at a given time.\n     * @variation optimized\n     * @param date - The date at which to calculate the ECF position. Optional, defaults to the current date.\n     * @returns The ECF position at the specified date.\n     */\n    ecf(date = new Date()) {\n        const { gmst } = Satellite.calculateTimeVariables(date);\n        const eci = this.eci(date);\n        if (!eci) {\n            return null;\n        }\n        return eci2ecf(eci.position, gmst);\n    }\n    /**\n     * Calculates ECI position at a given time.\n     * @variation optimized\n     * @param date - The date at which to calculate the ECI position. Optional, defaults to the current date.\n     * @param j - Julian date. Optional, defaults to null.\n     * @param gmst - Greenwich Mean Sidereal Time. Optional, defaults to null.\n     * @returns The ECI position at the specified date.\n     */\n    eci(date, j, gmst) {\n        date ??= new Date();\n        const { m } = Satellite.calculateTimeVariables(date, this.satrec, j, gmst);\n        if (m === null) {\n            return null;\n        }\n        const pv = Sgp4.propagate(this.satrec, m);\n        if (!pv.position || !pv.velocity) {\n            return null;\n        }\n        return pv;\n    }\n    /**\n     * Calculates the J2000 coordinates for a given date. If no date is provided, the current time is used.\n     * @variation expanded\n     * @param date - The date for which to calculate the J2000 coordinates, defaults to the current date.\n     * @returns The J2000 coordinates for the specified date.\n     * @throws Error if propagation fails.\n     */\n    toJ2000(date = new Date()) {\n        const { m } = Satellite.calculateTimeVariables(date, this.satrec);\n        if (m === null) {\n            throw new Error('Propagation failed!');\n        }\n        const pv = Sgp4.propagate(this.satrec, m);\n        if (!pv.position) {\n            throw new Error('Propagation failed!');\n        }\n        else {\n            const p = pv.position;\n            const v = pv.velocity;\n            const epoch = new EpochUTC(date.getTime() / 1000);\n            const pos = new Vector3D(p.x, p.y, p.z);\n            const vel = new Vector3D(v.x, v.y, v.z);\n            return new J2000(epoch, pos, vel);\n        }\n    }\n    /**\n     * Returns the elevation angle of the satellite as seen by the given sensor at the specified time.\n     * @variation optimized\n     * @param observer - The observer's position on the ground.\n     * @param date - The date at which to calculate the elevation angle. Optional, defaults to the current date.\n     * @returns The elevation angle of the satellite as seen by the given sensor at the specified time.\n     */\n    el(observer, date = new Date()) {\n        const rae = this.rae(observer, date);\n        if (!rae) {\n            return null;\n        }\n        return (rae.el * RAD2DEG);\n    }\n    /**\n     * Calculates LLA position at a given time.\n     * @variation optimized\n     * @param date - The date at which to calculate the LLA position. Optional, defaults to the current date.\n     * @param j - Julian date. Optional, defaults to null.\n     * @param gmst - Greenwich Mean Sidereal Time. Optional, defaults to null.\n     * @returns The LLA position at the specified date.\n     */\n    lla(date, j, gmst) {\n        date ??= new Date();\n        if (!j || !gmst) {\n            const timeVar = Satellite.calculateTimeVariables(date, this.satrec);\n            j = timeVar.j;\n            gmst = timeVar.gmst;\n        }\n        const eci = this.eci(date, j, gmst);\n        if (!eci) {\n            return null;\n        }\n        const pos = eci.position;\n        const lla = eci2lla(pos, gmst);\n        return lla;\n    }\n    /**\n     * Converts the satellite's position to geodetic coordinates.\n     * @variation expanded\n     * @param date The date for which to calculate the geodetic coordinates. Defaults to the current date.\n     * @returns The geodetic coordinates of the satellite.\n     */\n    toGeodetic(date = new Date()) {\n        return this.toJ2000(date).toITRF().toGeodetic();\n    }\n    /**\n     * Converts the satellite's position to the International Terrestrial Reference Frame (ITRF) at the specified date.\n     * If no date is provided, the current date is used.\n     * @variation expanded\n     * @param date The date for which to convert the position. Defaults to the current date.\n     * @returns The satellite's position in the ITRF at the specified date.\n     */\n    toITRF(date = new Date()) {\n        return this.toJ2000(date).toITRF();\n    }\n    /**\n     * Converts the current satellite's position to the Reference-Inertial-Celestial (RIC) frame\n     * relative to the specified reference satellite at the given date.\n     * @variation expanded\n     * @param reference The reference satellite.\n     * @param date The date for which to calculate the RIC frame. Defaults to the current date.\n     * @returns The RIC frame representing the current satellite's position relative to the reference satellite.\n     */\n    toRIC(reference, date = new Date()) {\n        return RIC.fromJ2000(this.toJ2000(date), reference.toJ2000(date));\n    }\n    /**\n     * Converts the satellite object to a TLE (Two-Line Element) object.\n     * @returns The TLE object representing the satellite.\n     */\n    toTle() {\n        return new Tle(this.tle1, this.tle2);\n    }\n    /**\n     * Converts the satellite's position to classical orbital elements.\n     * @param date The date for which to calculate the classical elements. Defaults to the current date.\n     * @returns The classical orbital elements of the satellite.\n     */\n    toClassicalElements(date = new Date()) {\n        return this.toJ2000(date).toClassicalElements();\n    }\n    /**\n     * Calculates the RAE (Range, Azimuth, Elevation) vector for a given sensor and time.\n     * @variation optimized\n     * @param observer - The observer's position on the ground.\n     * @param date - The date at which to calculate the RAE vector. Optional, defaults to the current date.\n     * @param j - Julian date. Optional, defaults to null.\n     * @param gmst - Greenwich Mean Sidereal Time. Optional, defaults to null.\n     * @returns The RAE vector for the given sensor and time.\n     */\n    rae(observer, date, j, gmst) {\n        date ??= new Date();\n        gmst ??= Satellite.calculateTimeVariables(date, this.satrec).gmst;\n        const eci = this.eci(date, j, gmst);\n        if (!eci) {\n            return null;\n        }\n        const ecf = eci2ecf(eci.position, gmst);\n        return ecf2rae(observer, ecf);\n    }\n    /**\n     * Returns the range of the satellite from the given sensor at the specified time.\n     * @variation optimized\n     * @param observer - The observer's position on the ground.\n     * @param date - The date at which to calculate the range. Optional, defaults to the current date.\n     * @returns The range of the satellite from the given sensor at the specified time.\n     */\n    rng(observer, date = new Date()) {\n        const rae = this.rae(observer, date);\n        if (!rae) {\n            return null;\n        }\n        return rae.rng;\n    }\n    /**\n     * Applies the Doppler effect to the given frequency based on the observer's position and the date.\n     * @param freq - The frequency to apply the Doppler effect to.\n     * @param observer - The observer's position on the ground.\n     * @param date - The date at which to calculate the Doppler effect. Optional, defaults to the current date.\n     * @returns The frequency after applying the Doppler effect.\n     */\n    applyDoppler(freq, observer, date) {\n        const doppler = this.dopplerFactor(observer, date);\n        if (!doppler) {\n            return null;\n        }\n        return freq * doppler;\n    }\n    /**\n     * Calculates the Doppler factor for the satellite.\n     * @param observer The observer's ground position.\n     * @param date The optional date for which to calculate the Doppler factor. If not provided, the current date is used.\n     * @returns The calculated Doppler factor.\n     */\n    dopplerFactor(observer, date) {\n        const position = this.eci(date);\n        if (!position) {\n            return null;\n        }\n        return dopplerFactor(observer.eci(date), position.position, position.velocity);\n    }\n    /**\n     * Calculates the time variables for a given date relative to the TLE epoch.\n     * @param date Date to calculate\n     * @param satrec Satellite orbital information\n     * @param j Julian date\n     * @param gmst Greenwich Mean Sidereal Time\n     * @returns Time variables\n     */\n    static calculateTimeVariables(date, satrec, j, gmst) {\n        j ??= jday(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds()) + date.getUTCMilliseconds() * MILLISECONDS_TO_DAYS;\n        gmst ??= Sgp4.gstime(j);\n        const m = satrec ? (j - satrec.jdsatepoch) * MINUTES_PER_DAY : null;\n        return { gmst, m, j };\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { PassType } from '../enums/PassType.js';\nimport { calcGmst, EpochUTC, J2000, lla2eci, Vector3D } from '../main.js';\nimport { SpaceObjectType } from '../types/types.js';\nimport { GroundObject } from './GroundObject.js';\nexport class Sensor extends GroundObject {\n    minRng;\n    minAz;\n    minEl;\n    maxRng;\n    maxAz;\n    maxEl;\n    minRng2;\n    minAz2;\n    minEl2;\n    maxRng2;\n    maxAz2;\n    maxEl2;\n    constructor(info) {\n        // If there is a sensor type verify it is valid\n        if (info.type) {\n            switch (info.type) {\n                case SpaceObjectType.OPTICAL:\n                case SpaceObjectType.MECHANICAL:\n                case SpaceObjectType.PHASED_ARRAY_RADAR:\n                case SpaceObjectType.OBSERVER:\n                case SpaceObjectType.BISTATIC_RADIO_TELESCOPE:\n                case SpaceObjectType.SHORT_TERM_FENCE:\n                    break;\n                default:\n                    throw new Error('Invalid sensor type');\n            }\n        }\n        super(info);\n        this.validateSensorInputData_(info);\n        this.minRng = info.minRng;\n        this.minAz = info.minAz;\n        this.minEl = info.minEl;\n        this.maxRng = info.maxRng;\n        this.maxAz = info.maxAz;\n        this.maxEl = info.maxEl;\n        this.minRng2 = info.minRng2;\n        this.minAz2 = info.minAz2;\n        this.minEl2 = info.minEl2;\n        this.maxRng2 = info.maxRng2;\n        this.maxAz2 = info.maxAz2;\n        this.maxEl2 = info.maxEl2;\n    }\n    /**\n     * Checks if the object is a sensor.\n     * @returns True if the object is a sensor, false otherwise.\n     */\n    isSensor() {\n        return true;\n    }\n    calculatePasses(planningInterval, sat, date = new Date()) {\n        let isInViewLast = false;\n        let maxElThisPass = 0;\n        const msnPlanPasses = [];\n        const startTime = date.getTime();\n        for (let timeOffset = 0; timeOffset < planningInterval; timeOffset++) {\n            const curTime = new Date(startTime + timeOffset * 1000);\n            const rae = this.rae(sat, curTime);\n            if (!rae) {\n                continue;\n            }\n            const isInView = this.isRaeInFov(rae);\n            if (timeOffset === 0) {\n                // Propagate Backwards to get the previous pass\n                const oldRae = this.rae(sat, new Date(date.getTime() - 1 * 1000));\n                if (!oldRae) {\n                    continue;\n                }\n                isInViewLast = this.isRaeInFov(oldRae);\n            }\n            const type = Sensor.getPassType_(isInView, isInViewLast);\n            maxElThisPass = Math.max(maxElThisPass, rae.el);\n            if (type === PassType.ENTER || type === PassType.EXIT) {\n                const pass = {\n                    type,\n                    time: curTime,\n                    az: rae.az,\n                    el: rae.el,\n                    rng: rae.rng,\n                };\n                // Only set maxEl for EXIT passes\n                if (type === PassType.EXIT) {\n                    pass.maxElPass = maxElThisPass;\n                }\n                msnPlanPasses.push(pass);\n                maxElThisPass = 0;\n            }\n            isInViewLast = isInView;\n        }\n        return msnPlanPasses;\n    }\n    /**\n     * Checks if the given RAE vector is within the field of view of the sensor.\n     * @param rae - The RAE vector to check.\n     * @returns True if the RAE vector is within the field of view, false otherwise.\n     */\n    isRaeInFov(rae) {\n        if (rae.el < this.minEl || rae.el > this.maxEl) {\n            return false;\n        }\n        if (rae.rng < this.minRng || rae.rng > this.maxRng) {\n            return false;\n        }\n        if (this.minAz > this.maxAz) {\n            // North Facing Sensors\n            if (rae.az < this.minAz && rae.az > this.maxAz) {\n                return false;\n            }\n            // Normal Facing Sensors\n        }\n        else if (rae.az < this.minAz || rae.az > this.maxAz) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Checks if a satellite is in the field of view (FOV) of the sensor.\n     * @param sat - The satellite to check.\n     * @param date - The date to use for the calculation. Defaults to the current date.\n     * @returns A boolean indicating whether the satellite is in the FOV.\n     */\n    isSatInFov(sat, date = new Date()) {\n        const rae = this.rae(sat, date);\n        if (!rae) {\n            return false;\n        }\n        return this.isRaeInFov(rae);\n    }\n    /**\n     * Checks if the sensor is in deep space.\n     * @returns True if the sensor is in deep space, false otherwise.\n     */\n    isDeepSpace() {\n        return this.maxRng > 6000;\n    }\n    /**\n     * Checks if the sensor is near Earth.\n     * @returns True if the sensor is near Earth, false otherwise.\n     */\n    isNearEarth() {\n        return this.maxRng <= 6000;\n    }\n    toJ2000(date = new Date()) {\n        const gmst = calcGmst(date).gmst;\n        const position = lla2eci(this.llaRad(), gmst);\n        return new J2000(EpochUTC.fromDateTime(date), new Vector3D(position.x, position.y, position.z), new Vector3D(0, 0, 0));\n    }\n    /**\n     * Returns the pass type based on the current and previous visibility states.\n     * @param isInView - Indicates if the object is currently in view.\n     * @param isInViewLast - Indicates if the object was in view in the previous state.\n     * @returns The pass type.\n     */\n    static getPassType_(isInView, isInViewLast) {\n        let type = PassType.OUT_OF_VIEW;\n        if (isInView && !isInViewLast) {\n            type = PassType.ENTER;\n        }\n        else if (!isInView && isInViewLast) {\n            type = PassType.EXIT;\n        }\n        else if (isInView && isInViewLast) {\n            type = PassType.IN_VIEW;\n        }\n        return type;\n    }\n    /**\n     * Validates the field of view (FOV) parameters of the sensor.\n     * @param info - The sensor parameters.\n     */\n    validateFov_(info) {\n        this.validateParameter(info.maxAz, 0, 360, 'Invalid maximum azimuth - must be between 0 and 360');\n        this.validateParameter(info.minAz, 0, 360, 'Invalid maximum azimuth - must be between 0 and 360');\n        this.validateParameter(info.maxEl, -15, 180, 'Invalid maximum elevation - must be between 0 and 180');\n        this.validateParameter(info.minEl, -15, 90, 'Invalid minimum elevation - must be between 0 and 90');\n        this.validateParameter(info.maxRng, 0, null, 'Invalid maximum range - must be greater than 0');\n        this.validateParameter(info.minRng, 0, null, 'Invalid minimum range - must be greater than 0');\n    }\n    /**\n     * Validates the field of view parameters for the sensor.\n     * @param info - The sensor parameters.\n     */\n    validateFov2_(info) {\n        this.validateParameter(info.maxAz2, 0, 360, 'Invalid maximum azimuth2 - must be between 0 and 360');\n        this.validateParameter(info.minAz2, 0, 360, 'Invalid maximum azimuth2 - must be between 0 and 360');\n        this.validateParameter(info.maxEl2, -15, 180, 'Invalid maximum elevation2 - must be between 0 and 180');\n        this.validateParameter(info.minEl2, -15, 90, 'Invalid minimum elevation2 - must be between 0 and 90');\n        this.validateParameter(info.maxRng2, 0, null, 'Invalid maximum range2 - must be greater than 0');\n        this.validateParameter(info.minRng2, 0, null, 'Invalid minimum range2 - must be greater than 0');\n    }\n    /**\n     * Validates the input data for the sensor.\n     * @param info - The sensor parameters.\n     */\n    validateSensorInputData_(info) {\n        this.validateLla_(info);\n        this.validateFov_(info);\n        if (info.minAz2 || info.maxAz2 || info.minEl2 || info.maxEl2 || info.minRng2 || info.maxRng2) {\n            this.validateFov2_(info);\n        }\n    }\n    /**\n     * Validates the latitude, longitude, and altitude of a sensor.\n     * @param info - The sensor parameters containing the latitude, longitude, and altitude.\n     */\n    validateLla_(info) {\n        this.validateParameter(info.lat, -90, 90, 'Invalid latitude - must be between -90 and 90');\n        this.validateParameter(info.lon, -180, 180, 'Invalid longitude - must be between -180 and 180');\n        this.validateParameter(info.alt, 0, null, 'Invalid altitude - must be greater than 0');\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { Celestial, ecf2eci, jday, MILLISECONDS_TO_DAYS, rae2ecf, Sgp4, SpaceObjectType, } from '../main.js';\nimport { BaseObject } from './BaseObject.js';\nexport class Star extends BaseObject {\n    ra;\n    dec;\n    bf;\n    h;\n    pname;\n    vmag;\n    constructor(info) {\n        super(info);\n        this.type = SpaceObjectType.STAR;\n        this.ra = info.ra;\n        this.dec = info.dec;\n        this.pname = info.pname ?? '';\n        this.bf = info.bf ?? '';\n        this.h = info.h ?? '';\n        this.vmag = info.vmag;\n    }\n    eci(lla = { lat: 180, lon: 0, alt: 0 }, date = new Date()) {\n        const rae = this.rae(lla, date);\n        const { gmst } = Star.calculateTimeVariables_(date);\n        // Arbitrary distance to enable using ECI coordinates\n        return ecf2eci(rae2ecf(rae, { lat: 0, lon: 0, alt: 0 }), gmst);\n    }\n    rae(lla = { lat: 180, lon: 0, alt: 0 }, date = new Date()) {\n        const starPos = Celestial.azEl(date, lla.lat, lla.lon, this.ra, this.dec);\n        return { az: starPos.az, el: starPos.el, rng: 250000 };\n    }\n    static calculateTimeVariables_(date) {\n        const j = jday(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds()) +\n            date.getUTCMilliseconds() * MILLISECONDS_TO_DAYS;\n        const gmst = Sgp4.gstime(j);\n        return { gmst, j };\n    }\n}\n","export { BaseObject } from './BaseObject.js';\nexport { GroundObject } from './GroundObject.js';\nexport { Satellite } from './Satellite.js';\nexport { Sensor } from './Sensor.js';\nexport { Star } from './Star.js';\nexport { DetailedSatellite } from './DetailedSatellite.js';\nexport { DetailedSensor } from './DetailedSensor.js';\nexport { LandObject } from './LandObject.js';\nexport { Marker } from './Marker.js';\nexport { RfSensor } from './RfSensor.js';\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { Matrix, Vector3D } from '../main.js';\nexport const radecToPosition = (ra, dec, r) => {\n    const ca = Math.cos(ra);\n    const sa = Math.sin(ra);\n    const cd = Math.cos(dec);\n    const sd = Math.sin(dec);\n    return new Vector3D(r * cd * ca, r * cd * sa, r * sd);\n};\nexport const radecToVelocity = (ra, dec, r, raDot, decDot, rDot) => {\n    const ca = Math.cos(ra);\n    const sa = Math.sin(ra);\n    const cd = Math.cos(dec);\n    const sd = Math.sin(dec);\n    return new Vector3D(rDot * cd * ca - r * sd * ca * decDot - r * cd * sa * raDot, rDot * cd * sa - r * sd * sa * decDot + r * cd * ca * raDot, rDot * sd + r * cd * decDot);\n};\nexport const normalizeAngle = (a, b) => {\n    const x = a - b;\n    return Math.atan2(Math.sin(x), Math.cos(x));\n};\nexport const observationDerivative = (xh, xl, step, isAngle = false) => (isAngle ? normalizeAngle(xh, xl) : xh - xl) / step;\nexport const observationNoiseFromSigmas = (sigmas) => {\n    const n = sigmas.length;\n    const result = Array.from({ length: n }, () => Array(n).fill(0.0));\n    for (let i = 0; i < n; i++) {\n        const s = sigmas[i];\n        result[i][i] = 1 / (s * s);\n    }\n    return new Matrix(result);\n};\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nexport class PropagatorPairs {\n    posStep_;\n    velStep_;\n    constructor(posStep_, velStep_) {\n        this.posStep_ = posStep_;\n        this.velStep_ = velStep_;\n        // Do nothing.\n    }\n    _high = Array(6).fill(null);\n    _low = Array(6).fill(null);\n    set(index, high, low) {\n        this._high[index] = high;\n        this._low[index] = low;\n    }\n    get(index) {\n        return [this._high[index], this._low[index]];\n    }\n    /**\n     * Get the step size at the provided index.\n     * @param index The index.\n     * @returns The step size.\n     */\n    step(index) {\n        return index < 3 ? this.posStep_ : this.velStep_;\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\n/* eslint-disable no-undefined */\nimport { ITRF } from '../coordinate/ITRF.js';\nimport { AngularDistanceMethod } from '../enums/AngularDistanceMethod.js';\nimport { Vector3D } from '../operations/Vector3D.js';\nimport { DEG2RAD, halfPi, RAD2DEG, TAU } from '../utils/constants.js';\nimport { angularDistance } from '../utils/functions.js';\n// / Range, azimuth, and elevation.\nexport class RAE {\n    epoch;\n    rng;\n    azRad;\n    elRad;\n    rngRate;\n    azRateRad;\n    elRateRad;\n    constructor(epoch, rng, azRad, elRad, \n    /** The range rate of the satellite relative to the observer in kilometers per second. */\n    rngRate, \n    /** The azimuth rate of the satellite relative to the observer in radians per second. */\n    azRateRad, \n    /** The elevation rate of the satellite relative to the observer in radians per second. */\n    elRateRad) {\n        this.epoch = epoch;\n        this.rng = rng;\n        this.azRad = azRad;\n        this.elRad = elRad;\n        this.rngRate = rngRate;\n        this.azRateRad = azRateRad;\n        this.elRateRad = elRateRad;\n        // Do nothing\n    }\n    // / Create a new [Razel] object, using degrees for the angular values.\n    static fromDegrees(epoch, range, azimuth, elevation, rangeRate, azimuthRate, elevationRate) {\n        const azimuthRateRad = azimuthRate ? azimuthRate * DEG2RAD : undefined;\n        const elevationRateRad = elevationRate ? elevationRate * DEG2RAD : undefined;\n        return new RAE(epoch, range, (azimuth * DEG2RAD), (elevation * DEG2RAD), rangeRate, azimuthRateRad, elevationRateRad);\n    }\n    /**\n     * Create a [Razel] object from an inertial [state] and [site] vector.\n     * @param state The inertial [state] vector.\n     * @param site The observer [site] vector.\n     * @returns A new [Razel] object.\n     */\n    static fromStateVector(state, site) {\n        const stateEcef = state.toITRF();\n        const siteEcef = site.toITRF();\n        const po2 = halfPi;\n        const r = stateEcef.position.subtract(siteEcef.position);\n        const rDot = stateEcef.velocity;\n        const geo = siteEcef.toGeodetic();\n        const p = r.rotZ(geo.lon).rotY((po2 - geo.lat));\n        const pDot = rDot.rotZ(geo.lon).rotY((po2 - geo.lat));\n        const pS = p.x;\n        const pE = p.y;\n        const pZ = p.z;\n        const pSDot = pDot.x;\n        const pEDot = pDot.y;\n        const pZDot = pDot.z;\n        const pMag = p.magnitude();\n        const pSEMag = Math.sqrt(pS * pS + pE * pE);\n        const elevation = Math.asin(pZ / pMag);\n        let azimuth;\n        if (elevation !== po2) {\n            azimuth = Math.atan2(-pE, pS) + Math.PI;\n        }\n        else {\n            azimuth = Math.atan2(-pEDot, pSDot) + Math.PI;\n        }\n        const rangeRate = p.dot(pDot) / pMag;\n        const azimuthRate = (pSDot * pE - pEDot * pS) / (pS * pS + pE * pE);\n        const elevationRate = (pZDot - rangeRate * Math.sin(elevation)) / pSEMag;\n        return new RAE(state.epoch, pMag, (azimuth % TAU), elevation, rangeRate, azimuthRate, elevationRate);\n    }\n    /**\n     * Gets the azimuth in degrees.\n     * @returns The azimuth in degrees.\n     */\n    get az() {\n        return this.azRad * RAD2DEG;\n    }\n    /**\n     * Gets the elevation angle in degrees.\n     * @returns The elevation angle in degrees.\n     */\n    get el() {\n        return this.elRad * RAD2DEG;\n    }\n    /**\n     * Gets the azimuth rate in degrees per second.\n     * @returns The azimuth rate in degrees per second, or undefined if it is not available.\n     */\n    get azRate() {\n        return this.azRateRad ? this.azRateRad * RAD2DEG : undefined;\n    }\n    /**\n     * Gets the elevation rate in degrees per second.\n     * @returns The elevation rate in degrees per second, or undefined if the elevation rate is not set.\n     */\n    get elRate() {\n        return this.elRateRad ? this.elRateRad * RAD2DEG : undefined;\n    }\n    toString() {\n        return [\n            '[RazEl]',\n            `  Epoch:     ${this.epoch}`,\n            `  Azimuth:   ${this.az.toFixed(4)}Â°`,\n            `  Elevation: ${this.el.toFixed(4)}Â°`,\n            `  Range:     ${this.rng.toFixed(3)} km`,\n        ].join('\\n');\n    }\n    /**\n     * Return the position relative to the observer [site].\n     *\n     * An optional azimuth [az] _(rad)_ and elevation [el] _(rad)_ value can be\n     * passed to override the values contained in this observation.\n     * @param site The observer [site].\n     * @param azRad Azimuth _(rad)_.\n     * @param elRad Elevation _(rad)_.\n     * @returns A [Vector3D] object.\n     */\n    position(site, azRad, elRad) {\n        const ecef = site.toITRF();\n        const geo = ecef.toGeodetic();\n        const po2 = halfPi;\n        const newAz = azRad ?? this.azRad;\n        const newEl = elRad ?? this.elRad;\n        const sAz = Math.sin(newAz);\n        const cAz = Math.cos(newAz);\n        const sEl = Math.sin(newEl);\n        const cEl = Math.cos(newEl);\n        const pSez = new Vector3D((-this.rng * cEl * cAz), (this.rng * cEl * sAz), (this.rng * sEl));\n        const rEcef = pSez\n            .rotY(-(po2 - geo.lat))\n            .rotZ(-geo.lon)\n            .add(ecef.position);\n        return new ITRF(this.epoch, rEcef, Vector3D.origin).toJ2000().position;\n    }\n    /**\n     * Convert this observation into a [J2000] state vector.\n     *\n     * This will throw an error if the [rangeRate], [elevationRate], or\n     * [azimuthRate] are not defined.\n     * @param site The observer [site].\n     * @returns A [J2000] state vector.\n     */\n    toStateVector(site) {\n        // If the rates are not defined then assume stationary\n        this.rngRate ??= 0;\n        this.elRateRad ??= 0;\n        this.azRateRad ??= 0;\n        const ecef = site.toITRF();\n        const geo = ecef.toGeodetic();\n        const po2 = halfPi;\n        const sAz = Math.sin(this.azRad);\n        const cAz = Math.cos(this.azRad);\n        const sEl = Math.sin(this.elRad);\n        const cEl = Math.cos(this.elRad);\n        const pSez = new Vector3D((-this.rng * cEl * cAz), (this.rng * cEl * sAz), (this.rng * sEl));\n        const pDotSez = new Vector3D((-this.rngRate * cEl * cAz +\n            this.rng * sEl * cAz * this.elRateRad +\n            this.rng * cEl * sAz * this.azRateRad), (this.rngRate * cEl * sAz -\n            this.rng * sEl * sAz * this.elRateRad +\n            this.rng * cEl * cAz * this.azRateRad), (this.rngRate * sEl + this.rng * cEl * this.elRateRad));\n        const pEcef = pSez.rotY(-(po2 - geo.lat)).rotZ(-geo.lon);\n        const pDotEcef = pDotSez\n            .rotY(-(po2 - geo.lat))\n            .rotZ(-geo.lon);\n        const rEcef = pEcef.add(ecef.position);\n        return new ITRF(this.epoch, rEcef, pDotEcef).toJ2000();\n    }\n    /**\n     * Calculate the angular distance _(rad)_ between this and another [Razel]\n     * object.\n     * @param razel The other [Razel] object.\n     * @param method The angular distance method to use.\n     * @returns The angular distance _(rad)_.\n     */\n    angle(razel, method = AngularDistanceMethod.Cosine) {\n        return angularDistance(this.azRad, this.elRad, razel.azRad, razel.elRad, method);\n    }\n    /**\n     * Calculate the angular distance _(Â°)_ between this and another [Razel]\n     * object.\n     * @param razel The other [Razel] object.\n     * @param method The angular distance method to use.\n     * @returns The angular distance _(Â°)_.\n     */\n    angleDegrees(razel, method = AngularDistanceMethod.Cosine) {\n        return this.angle(razel, method) * RAD2DEG;\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { AngularDistanceMethod } from '../enums/AngularDistanceMethod.js';\nimport { DEG2RAD, RAD2DEG, TAU } from '../utils/constants.js';\nimport { angularDistance } from '../utils/functions.js';\nimport { radecToPosition, radecToVelocity } from './ObservationUtils.js';\n/**\n * Represents a geocentric right ascension and declination observation.\n *\n * In geocentric coordinates, observations are considered from the Earth's center. This approach simplifies calculations\n * for distant celestial objects, as it assumes a uniform observation point that ignores the observer's specific\n * location on Earth.\n */\nexport class RadecGeocentric {\n    epoch;\n    rightAscension;\n    declination;\n    range;\n    rightAscensionRate;\n    declinationRate;\n    rangeRate;\n    constructor(epoch, rightAscension, declination, range, rightAscensionRate, declinationRate, rangeRate) {\n        this.epoch = epoch;\n        this.rightAscension = rightAscension;\n        this.declination = declination;\n        this.range = range;\n        this.rightAscensionRate = rightAscensionRate;\n        this.declinationRate = declinationRate;\n        this.rangeRate = rangeRate;\n        // Nothing to do here.\n    }\n    /**\n     * Creates a RadecGeocentric object from the given parameters in degrees.\n     * @param epoch - The epoch in UTC.\n     * @param rightAscensionDegrees - The right ascension in degrees.\n     * @param declinationDegrees - The declination in degrees.\n     * @param range - The range in kilometers (optional).\n     * @param rightAscensionRateDegrees - The right ascension rate in degrees per second (optional).\n     * @param declinationRateDegrees - The declination rate in degrees per second (optional).\n     * @param rangeRate - The range rate in kilometers per second (optional).\n     * @returns A new RadecGeocentric object.\n     */\n    static fromDegrees(epoch, rightAscensionDegrees, declinationDegrees, range, rightAscensionRateDegrees, declinationRateDegrees, rangeRate) {\n        const rightAscensionRate = rightAscensionRateDegrees\n            ? rightAscensionRateDegrees * DEG2RAD\n            : null;\n        const declinationRate = declinationRateDegrees ? declinationRateDegrees * DEG2RAD : null;\n        return new RadecGeocentric(epoch, rightAscensionDegrees * DEG2RAD, declinationDegrees * DEG2RAD, range, rightAscensionRate, declinationRate, rangeRate);\n    }\n    /**\n     * Creates a RadecGeocentric object from a state vector in J2000 coordinates.\n     * @param state - The J2000 state vector.\n     * @returns A new RadecGeocentric object.\n     */\n    static fromStateVector(state) {\n        const rI = state.position.x;\n        const rJ = state.position.y;\n        const rK = state.position.z;\n        const vI = state.velocity.x;\n        const vJ = state.velocity.y;\n        const vK = state.velocity.z;\n        const rMag = state.position.magnitude();\n        const declination = Math.asin(rK / rMag);\n        const rIJMag = Math.sqrt(rI * rI + rJ * rJ);\n        let rightAscension;\n        if (rIJMag !== 0) {\n            rightAscension = Math.atan2(rJ, rI);\n        }\n        else {\n            rightAscension = Math.atan2(vJ, vI);\n        }\n        const rangeRate = state.position.dot(state.velocity) / rMag;\n        const rightAscensionRate = (vI * rJ - vJ * rI) / (-(rJ * rJ) - rI * rI);\n        const declinationRate = (vK - rangeRate * (rK / rMag)) / rIJMag;\n        return new RadecGeocentric(state.epoch, rightAscension % TAU, declination, rMag, rightAscensionRate, declinationRate, rangeRate);\n    }\n    /**\n     * Gets the right ascension in degrees.\n     * @returns The right ascension in degrees.\n     */\n    get rightAscensionDegrees() {\n        return this.rightAscension * RAD2DEG;\n    }\n    /**\n     * Gets the declination in degrees.\n     * @returns The declination in degrees.\n     */\n    get declinationDegrees() {\n        return this.declination * RAD2DEG;\n    }\n    /**\n     * Gets the right ascension rate in degrees per second.\n     * @returns The right ascension rate in degrees per second, or null if it is not available.\n     */\n    get rightAscensionRateDegrees() {\n        return this.rightAscensionRate ? this.rightAscensionRate * RAD2DEG : null;\n    }\n    /**\n     * Gets the rate of change of declination in degrees per second.\n     * @returns The rate of change of declination in degrees per second, or null if not available.\n     */\n    get declinationRateDegrees() {\n        return this.declinationRate ? this.declinationRate * RAD2DEG : null;\n    }\n    /**\n     * Calculates the position vector in geocentric coordinates.\n     * @param range - The range in kilometers (optional). If not provided, it uses the default range or 1.0 kilometer.\n     * @returns The position vector in geocentric coordinates.\n     */\n    position(range) {\n        const r = range ?? this.range ?? 1.0;\n        return radecToPosition(this.rightAscension, this.declination, r);\n    }\n    /**\n     * Calculates the velocity vector of the celestial object.\n     * @param range - The range of the celestial object in kilometers. If not provided, it uses the stored range value.\n     * @param rangeRate - The range rate of the celestial object in kilometers per second.\n     * If not provided, it uses the stored range rate value.\n     * @returns The velocity vector of the celestial object in kilometers per second.\n     * @throws Error if the right ascension rate or declination rate is missing.\n     */\n    velocity(range, rangeRate) {\n        if (!this.rightAscensionRate || !this.declinationRate) {\n            throw new Error('Velocity unsolvable, missing ra/dec rates.');\n        }\n        const r = range ?? this.range ?? 1.0;\n        const rd = rangeRate ?? this.rangeRate ?? 0.0;\n        return radecToVelocity(this.rightAscension, this.declination, r, this.rightAscensionRate, this.declinationRate, rd);\n    }\n    /**\n     * Calculates the angular distance between two celestial coordinates (RA and Dec).\n     * @param radec - The celestial coordinates to compare with.\n     * @param method - The method to use for calculating the angular distance. Default is `AngularDistanceMethod.Cosine`.\n     * @returns The angular distance between the two celestial coordinates in radians.\n     */\n    angle(radec, method = AngularDistanceMethod.Cosine) {\n        return angularDistance(this.rightAscension, this.declination, radec.rightAscension, radec.declination, method);\n    }\n    /**\n     * Calculates the angle in degrees between two RadecGeocentric objects.\n     * @param radec - The RadecGeocentric object to calculate the angle with.\n     * @param method - The method to use for calculating the angular distance. Default is AngularDistanceMethod.Cosine.\n     * @returns The angle in degrees.\n     */\n    angleDegrees(radec, method = AngularDistanceMethod.Cosine) {\n        return this.angle(radec, method) * RAD2DEG;\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { AngularDistanceMethod } from '../enums/AngularDistanceMethod.js';\nimport { Vector3D } from '../operations/Vector3D.js';\nimport { DEG2RAD, RAD2DEG, TAU } from '../utils/constants.js';\nimport { angularDistance } from '../utils/functions.js';\nimport { radecToPosition, radecToVelocity } from './ObservationUtils.js';\n/**\n * Represents a topocentric right ascension and declination observation.\n *\n * Topocentric coordinates take into account the observer's exact location on the Earth's surface. This model is crucial\n * for precise measurements of local astronomical events and nearby celestial objects, where the observer's latitude,\n * longitude, and altitude can significantly affect the observed position due to parallax. Topocentric coordinates are\n * particularly important for observations of the Moon, planets, and artificial satellites.\n */\nexport class RadecTopocentric {\n    epoch;\n    rightAscension;\n    declination;\n    range;\n    rightAscensionRate;\n    declinationRate;\n    rangeRate;\n    constructor(epoch, rightAscension, declination, range, rightAscensionRate, declinationRate, rangeRate) {\n        this.epoch = epoch;\n        this.rightAscension = rightAscension;\n        this.declination = declination;\n        this.range = range;\n        this.rightAscensionRate = rightAscensionRate;\n        this.declinationRate = declinationRate;\n        this.rangeRate = rangeRate;\n        // Nothing to do here.\n    }\n    /**\n     * Create a new RadecTopocentric object, using degrees for the angular values.\n     * @param epoch UTC epoch.\n     * @param rightAscensionDegrees Right-ascension in degrees.\n     * @param declinationDegrees Declination in degrees.\n     * @param range Range in km.\n     * @param rightAscensionRateDegrees Right-ascension rate in degrees per second.\n     * @param declinationRateDegrees Declination rate in degrees per second.\n     * @param rangeRate Range rate in km/s.\n     * @returns A new RadecTopocentric object.\n     */\n    static fromDegrees(epoch, rightAscensionDegrees, declinationDegrees, range, rightAscensionRateDegrees, declinationRateDegrees, rangeRate) {\n        const rightAscensionRate = rightAscensionRateDegrees\n            ? rightAscensionRateDegrees * DEG2RAD\n            : null;\n        const declinationRate = declinationRateDegrees\n            ? declinationRateDegrees * DEG2RAD\n            : null;\n        return new RadecTopocentric(epoch, rightAscensionDegrees * DEG2RAD, declinationDegrees * DEG2RAD, range, rightAscensionRate, declinationRate, rangeRate);\n    }\n    /**\n     * Create a new RadecTopocentric object from a J2000 state vector.\n     * @param state Inertial state vector.\n     * @param site Site vector.\n     * @returns A new RadecTopocentric object.\n     */\n    static fromStateVector(state, site) {\n        const p = state.position.subtract(site.position);\n        const pI = p.x;\n        const pJ = p.y;\n        const pK = p.z;\n        const pMag = p.magnitude();\n        const declination = Math.asin(pK / pMag);\n        const pDot = state.velocity.subtract(site.velocity);\n        const pIDot = pDot.x;\n        const pJDot = pDot.y;\n        const pKDot = pDot.z;\n        const pIJMag = Math.sqrt(pI * pI + pJ * pJ);\n        let rightAscension;\n        if (pIJMag !== 0) {\n            rightAscension = Math.atan2(pJ, pI);\n        }\n        else {\n            rightAscension = Math.atan2(pJDot, pIDot);\n        }\n        const rangeRate = p.dot(pDot) / pMag;\n        const rightAscensionRate = (pIDot * pJ - pJDot * pI) / (-(pJ * pJ) - pI * pI);\n        const declinationRate = (pKDot - rangeRate * Math.sin(declination)) / pIJMag;\n        return new RadecTopocentric(state.epoch, rightAscension % TAU, declination, pMag, rightAscensionRate, declinationRate, rangeRate);\n    }\n    /**\n     * Gets the right ascension in degrees.\n     * @returns The right ascension in degrees.\n     */\n    get rightAscensionDegrees() {\n        return this.rightAscension * RAD2DEG;\n    }\n    /**\n     * Gets the declination in degrees.\n     * @returns The declination in degrees.\n     */\n    get declinationDegrees() {\n        return this.declination * RAD2DEG;\n    }\n    /**\n     * Gets the right ascension rate in degrees per second.\n     * @returns The right ascension rate in degrees per second, or null if it is not available.\n     */\n    get rightAscensionRateDegrees() {\n        return this.rightAscensionRate\n            ? this.rightAscensionRate * RAD2DEG\n            : null;\n    }\n    /**\n     * Gets the rate of change of declination in degrees per second.\n     * @returns The rate of change of declination in degrees per second, or null if the declination rate is not defined.\n     */\n    get declinationRateDegrees() {\n        return this.declinationRate\n            ? this.declinationRate * RAD2DEG\n            : null;\n    }\n    /**\n     * Return the position relative to the observer site.\n     *\n     * An optional range value can be passed to override the value contained in this observation.\n     * @param site Observer site.\n     * @param range Range in km.\n     * @returns A Vector3D object.\n     */\n    position(site, range) {\n        const r = range ?? this.range ?? 1.0;\n        return radecToPosition(this.rightAscension, this.declination, r).add(site.position);\n    }\n    /**\n     * Return the velocity relative to the observer site.\n     *\n     * An optional range and rangeRate value can be passed to override the values contained in this observation.\n     * @param site Observer site.\n     * @param range Range in km.\n     * @param rangeRate Range rate in km/s.\n     * @returns A Vector3D object.\n     */\n    velocity(site, range, rangeRate) {\n        if (!this.rightAscensionRate || !this.declinationRate) {\n            throw new Error('Velocity unsolvable, missing ra/dec rates.');\n        }\n        const r = range ?? this.range ?? 1.0;\n        const rd = rangeRate ?? this.rangeRate ?? 0.0;\n        return radecToVelocity(this.rightAscension, this.declination, r, this.rightAscensionRate, this.declinationRate, rd).add(site.velocity);\n    }\n    /**\n     * Calculates the line of sight vector in the topocentric coordinate system.\n     * The line of sight vector points from the observer's location towards the celestial object.\n     * @returns The line of sight vector as a Vector3D object.\n     */\n    lineOfSight() {\n        const ca = Math.cos(this.rightAscension);\n        const cd = Math.cos(this.declination);\n        const sa = Math.sin(this.rightAscension);\n        const sd = Math.sin(this.declination);\n        return new Vector3D(cd * ca, cd * sa, sd);\n    }\n    /**\n     * Calculate the angular distance between this and another RadecTopocentric object.\n     * @param radec - The other RadecTopocentric object.\n     * @param method - The angular distance method to use.\n     * @returns The angular distance.\n     */\n    angle(radec, method = AngularDistanceMethod.Cosine) {\n        return angularDistance(this.rightAscension, this.declination, radec.rightAscension, radec.declination, method);\n    }\n    /**\n     * Calculate the angular distance between this and another RadecTopocentric object.\n     * @param radec - The other RadecTopocentric object.\n     * @param method - The angular distance method to use.\n     * @returns The angular distance\n     */\n    angleDegrees(radec, method = AngularDistanceMethod.Cosine) {\n        return this.angle(radec, method) * RAD2DEG;\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nexport * from './ObservationUtils.js';\nexport { RadecGeocentric } from './RadecGeocentric.js';\nexport { RadecTopocentric } from './RadecTopocentric.js';\nexport { RAE } from './RAE.js';\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { Random, TAU, Vector } from '../main.js';\n// / Box-Muller random Gaussian number generator.\nexport class BoxMuller {\n    _index = 0;\n    _cache = new Float64Array(2);\n    // / Mean value.\n    mu;\n    // / Standard deviation.\n    sigma;\n    // / Uniform random number generator.\n    rand;\n    /**\n     * Create a new [BoxMuller] object with mean [mu], standard deviation\n     * [sigma], and [seed] number.\n     * @param mu Mean value.\n     * @param sigma Standard deviation.\n     * @param seed Random seed.\n     */\n    constructor(mu, sigma, seed = 0) {\n        this.mu = mu;\n        this.sigma = sigma;\n        this.rand = new Random(seed);\n        this._generate();\n    }\n    // / Refill the cache with random Gaussian numbers.\n    _generate() {\n        this._index = 0;\n        const u1 = this.rand.nextFloat();\n        const u2 = this.rand.nextFloat();\n        const mag = this.sigma * Math.sqrt(-2.0 * Math.log(u1));\n        this._cache[0] = mag * Math.cos(TAU * u2) + this.mu;\n        this._cache[1] = mag * Math.sin(TAU * u2) + this.mu;\n    }\n    /**\n     * Generate a gaussian number, with mean [mu] and standard\n     * deviation [sigma].\n     * @returns A gaussian number.\n     */\n    nextGauss() {\n        if (this._index > 1) {\n            this._generate();\n        }\n        const result = this._cache[this._index];\n        this._index++;\n        return result;\n    }\n    /**\n     * Generate a [Vector] of gaussian numbers, with mean [mu] and standard\n     * deviation [sigma].\n     * @param n Number of gaussian numbers to generate.\n     * @returns A [Vector] of gaussian numbers.\n     */\n    gaussVector(n) {\n        const result = new Float64Array(n);\n        for (let i = 0; i < n; i++) {\n            result[i] = this.nextGauss();\n        }\n        return new Vector(result);\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { DEG2RAD, Matrix, RAD2DEG } from '../main.js';\n// / Class containing Euler angles.\nexport class EulerAngles {\n    // / Roll component _(rad)_.\n    roll;\n    // / Pitch component _(rad)_.\n    pitch;\n    // / Yaw component _(rad)_.\n    yaw;\n    /**\n     * Create a new EulerAngles object from roll, pitch, and yaw angles in radians.\n     * @param roll Roll angle in radians.\n     * @param pitch Pitch angle in radians.\n     * @param yaw Yaw angle in radians.\n     */\n    constructor(roll, pitch, yaw) {\n        this.roll = roll;\n        this.pitch = pitch;\n        this.yaw = yaw;\n    }\n    /**\n     * Create a new EulerAngles object from roll, pitch, and yaw angles.\n     * @param rollDeg Roll angle in degrees.\n     * @param pitchDeg Pitch angle in degrees.\n     * @param yawDeg Yaw angle in degrees.\n     * @returns EulerAngles object.\n     */\n    static fromDegrees(rollDeg, pitchDeg, yawDeg) {\n        const roll = rollDeg * DEG2RAD;\n        const pitch = pitchDeg * DEG2RAD;\n        const yaw = yawDeg * DEG2RAD;\n        return new EulerAngles(roll, pitch, yaw);\n    }\n    /**\n     * Create a new EulerAngles object from 3-2-1 ordered direction cosine matrix c.\n     * @param c 3-2-1 ordered direction cosine matrix.\n     * @returns EulerAngles object.\n     */\n    static fromDcm321(c) {\n        const roll = Math.atan(c.elements[1][2] / c.elements[2][2]);\n        const pitch = -Math.asin(c.elements[0][2]);\n        const yaw = Math.atan(c.elements[0][1] / c.elements[0][0]);\n        return new EulerAngles(roll, pitch, yaw);\n    }\n    /**\n     * Gets the roll angle in degrees.\n     * @returns The roll angle in degrees.\n     */\n    get rollDegrees() {\n        return this.roll * RAD2DEG;\n    }\n    /**\n     * Gets the pitch angle in degrees.\n     * @returns The pitch angle in degrees.\n     */\n    get pitchDegrees() {\n        return this.pitch * RAD2DEG;\n    }\n    /**\n     * Gets the yaw angle in degrees.\n     * @returns The yaw angle in degrees.\n     */\n    get yawDegrees() {\n        return this.yaw * RAD2DEG;\n    }\n    /**\n     * Gets the roll angle in radians.\n     * @returns The roll angle in radians.\n     */\n    get phi() {\n        return this.roll;\n    }\n    /**\n     * Gets the pitch angle in radians.\n     * @returns The pitch angle in radians.\n     */\n    get theta() {\n        return this.pitch;\n    }\n    /**\n     * Gets the yaw angle in radians.\n     * @returns The yaw angle in radians.\n     */\n    get psi() {\n        return this.yaw;\n    }\n    /**\n     * Gets the roll component in degrees.\n     * @returns The roll component in degrees.\n     */\n    get phiDegrees() {\n        return this.phi * RAD2DEG;\n    }\n    /**\n     * Gets the pitch component in degrees.\n     * @returns The pitch component in degrees.\n     */\n    get thetaDegrees() {\n        return this.theta * RAD2DEG;\n    }\n    /**\n     * Gets the yaw component in degrees.\n     * @returns The yaw component in degrees.\n     */\n    get psiDegrees() {\n        return this.psi * RAD2DEG;\n    }\n    /**\n     * Returns a string representation of the Euler angles.\n     * @param precision The number of decimal places to include in the string representation. Default is 6.\n     * @returns A string representation of the Euler angles.\n     */\n    toString(precision = 6) {\n        const rollStr = this.rollDegrees.toFixed(precision);\n        const pitchStr = this.pitchDegrees.toFixed(precision);\n        const yawStr = this.yawDegrees.toFixed(precision);\n        return `Euler(roll: ${rollStr}Â°, pitch: ${pitchStr}Â°, yaw: ${yawStr}Â°)`;\n    }\n    /**\n     * Calculates the Direction Cosine Matrix (DCM) using the 3-2-1 Euler angles convention.\n     * @returns The calculated DCM as a Matrix object.\n     */\n    dcm321() {\n        const sPhi = Math.sin(this.phi);\n        const cPhi = Math.cos(this.phi);\n        const sTheta = Math.sin(this.theta);\n        const cTheta = Math.cos(this.theta);\n        const sPsi = Math.sin(this.psi);\n        const cPsi = Math.cos(this.psi);\n        return new Matrix([\n            [cTheta * cPsi, cTheta * sPsi, -sTheta],\n            [sPhi * sTheta * cPsi - cPhi * sPsi, sPhi * sTheta * sPsi + cPhi * cPsi, sPhi * cTheta],\n            [cPhi * sTheta * cPsi + sPhi * sPsi, cPhi * sTheta * sPsi - sPhi * cPsi, cPhi * cTheta],\n        ]);\n    }\n    /**\n     * Rotates a 3D vector using a 3-2-1 Euler angle sequence.\n     * @param v The vector to rotate.\n     * @returns The rotated vector.\n     */\n    rotateVector321(v) {\n        return this.dcm321().multiplyVector3D(v);\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { Vector, Vector3D } from '../main.js';\n/**\n * A matrix is a rectangular array of numbers or other mathematical objects for\n * which operations such as addition and multiplication are defined.\n */\nexport class Matrix {\n    elements;\n    rows;\n    columns;\n    constructor(elements) {\n        this.elements = elements;\n        this.rows = elements.length;\n        this.columns = (elements[0]).length;\n    }\n    /**\n     * Creates a matrix with all elements set to zero.\n     * @param rows - The number of rows in the matrix.\n     * @param columns - The number of columns in the matrix.\n     * @returns A matrix with all elements set to zero.\n     */\n    static allZeros(rows, columns) {\n        return this.fill(rows, columns, 0.0);\n    }\n    /**\n     * Creates a new Matrix with the specified number of rows and columns, filled\n     * with the specified value.\n     * @param rows The number of rows in the matrix.\n     * @param columns The number of columns in the matrix.\n     * @param value The value to fill the matrix with. Default is 0.0.\n     * @returns A new Matrix filled with the specified value.\n     */\n    static fill(rows, columns, value = 0.0) {\n        const elements = [];\n        for (let i = 0; i < rows; i++) {\n            elements[i] = [];\n            for (let j = 0; j < columns; j++) {\n                (elements[i])[j] = value;\n            }\n        }\n        return new Matrix(elements);\n    }\n    /**\n     * Creates a rotation matrix around the X-axis.\n     * @param theta - The angle of rotation in radians.\n     * @returns The rotation matrix.\n     */\n    static rotX(theta) {\n        const cosT = Math.cos(theta);\n        const sinT = Math.sin(theta);\n        const result = Matrix.zero(3, 3);\n        (result.elements[0])[0] = 1.0;\n        (result.elements[1])[1] = cosT;\n        (result.elements[1])[2] = sinT;\n        (result.elements[2])[1] = -sinT;\n        (result.elements[2])[2] = cosT;\n        return result;\n    }\n    /**\n     * Creates a rotation matrix around the y-axis.\n     * @param theta - The angle of rotation in radians.\n     * @returns The rotation matrix.\n     */\n    static rotY(theta) {\n        const cosT = Math.cos(theta);\n        const sinT = Math.sin(theta);\n        const result = Matrix.zero(3, 3);\n        (result.elements[0])[0] = cosT;\n        (result.elements[0])[2] = -sinT;\n        (result.elements[1])[1] = 1.0;\n        (result.elements[2])[0] = sinT;\n        (result.elements[2])[2] = cosT;\n        return result;\n    }\n    /**\n     * Creates a rotation matrix around the Z-axis.\n     * @param theta The angle of rotation in radians.\n     * @returns The rotation matrix.\n     */\n    static rotZ(theta) {\n        const cosT = Math.cos(theta);\n        const sinT = Math.sin(theta);\n        const result = Matrix.zero(3, 3);\n        (result.elements[0])[0] = cosT;\n        (result.elements[0])[1] = sinT;\n        (result.elements[1])[0] = -sinT;\n        (result.elements[1])[1] = cosT;\n        (result.elements[2])[2] = 1.0;\n        return result;\n    }\n    /**\n     * Creates a zero matrix with the specified number of rows and columns.\n     * @param rows The number of rows in the matrix.\n     * @param columns The number of columns in the matrix.\n     * @returns A new Matrix object representing the zero matrix.\n     */\n    static zero(rows, columns) {\n        const elements = [];\n        for (let i = 0; i < rows; i++) {\n            elements[i] = [];\n            for (let j = 0; j < columns; j++) {\n                (elements[i])[j] = 0.0;\n            }\n        }\n        return new Matrix(elements);\n    }\n    /**\n     * Creates an identity matrix of the specified dimension.\n     * @param dimension The dimension of the identity matrix.\n     * @returns The identity matrix.\n     */\n    static identity(dimension) {\n        const elements = [];\n        for (let i = 0; i < dimension; i++) {\n            elements[i] = [];\n            for (let j = 0; j < dimension; j++) {\n                (elements[i])[j] = i === j ? 1.0 : 0.0;\n            }\n        }\n        return new Matrix(elements);\n    }\n    /**\n     * Creates a diagonal matrix with the given diagonal elements.\n     * @param d - An array of diagonal elements.\n     * @returns A new Matrix object representing the diagonal matrix.\n     */\n    static diagonal(d) {\n        const dimension = d.length;\n        const elements = [];\n        for (let i = 0; i < dimension; i++) {\n            elements[i] = [];\n            for (let j = 0; j < dimension; j++) {\n                (elements[i])[j] = i === j ? d[i] : 0.0;\n            }\n        }\n        return new Matrix(elements);\n    }\n    /**\n     * Adds the elements of another matrix to this matrix and returns the result.\n     * @param m - The matrix to be added.\n     * @returns The resulting matrix after addition.\n     */\n    add(m) {\n        const result = Matrix.zero(this.rows, this.columns);\n        for (let i = 0; i < this.rows; i++) {\n            for (let j = 0; j < this.columns; j++) {\n                (result.elements[i] ?? [])[j] = (this.elements[i]?.[j]) + (m.elements[i]?.[j]);\n            }\n        }\n        return result;\n    }\n    /**\n     * Subtracts the elements of another matrix from this matrix.\n     * @param m - The matrix to subtract.\n     * @returns A new matrix containing the result of the subtraction.\n     */\n    subtract(m) {\n        const result = Matrix.zero(this.rows, this.columns);\n        for (let i = 0; i < this.rows; i++) {\n            for (let j = 0; j < this.columns; j++) {\n                (result.elements[i] ?? [])[j] = (this.elements[i]?.[j]) - (m.elements[i]?.[j]);\n            }\n        }\n        return result;\n    }\n    /**\n     * Scales the matrix by multiplying each element by a scalar value.\n     * @param n - The scalar value to multiply each element by.\n     * @returns A new Matrix object representing the scaled matrix.\n     */\n    scale(n) {\n        const result = Matrix.zero(this.rows, this.columns);\n        for (let i = 0; i < this.rows; i++) {\n            for (let j = 0; j < this.columns; j++) {\n                (result.elements[i] ?? [])[j] = (this.elements[i]?.[j]) * n;\n            }\n        }\n        return result;\n    }\n    /**\n     * Negates the matrix by scaling it by -1.\n     * @returns The negated matrix.\n     */\n    negate() {\n        return this.scale(-1);\n    }\n    /**\n     * Multiplies this matrix with another matrix.\n     * @param m The matrix to multiply with.\n     * @returns The resulting matrix.\n     */\n    multiply(m) {\n        const result = Matrix.zero(this.rows, m.columns);\n        for (let i = 0; i < this.rows; i++) {\n            for (let j = 0; j < m.columns; j++) {\n                for (let k = 0; k < this.columns; k++) {\n                    ((result.elements[i])[j]) +=\n                        (this.elements[i]?.[k]) * (m.elements[k]?.[j]);\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Computes the outer product of this matrix with another matrix.\n     * @param m - The matrix to compute the outer product with.\n     * @returns The resulting matrix.\n     */\n    outerProduct(m) {\n        const result = Matrix.zero(this.rows, this.columns);\n        for (let i = 0; i < this.rows; i++) {\n            for (let j = 0; j < this.columns; j++) {\n                (result.elements[i])[j] = (this.elements[i]?.[j]) * (m.elements[i]?.[j]);\n            }\n        }\n        return result;\n    }\n    /**\n     * Multiplies the matrix by a vector.\n     * @param v The vector to multiply by.\n     * @returns A new vector representing the result of the multiplication.\n     */\n    multiplyVector(v) {\n        const result = [];\n        for (let i = 0; i < this.rows; i++) {\n            let total = 0.0;\n            for (let j = 0; j < this.columns; j++) {\n                total += (this.elements[i]?.[j]) * (v.elements[j]);\n            }\n            result[i] = total;\n        }\n        return new Vector(result);\n    }\n    /**\n     * Multiplies a 3D vector by the matrix.\n     * @template T - The type of the vector elements.\n     * @param v - The 3D vector to multiply.\n     * @returns The resulting 3D vector after multiplication.\n     */\n    multiplyVector3D(v) {\n        const result = [];\n        for (let i = 0; i < this.rows; i++) {\n            let total = 0.0;\n            for (let j = 0; j < this.columns; j++) {\n                switch (j) {\n                    case 0:\n                        total += (this.elements[i]?.[j]) * v.x;\n                        break;\n                    case 1:\n                        total += (this.elements[i]?.[j]) * v.y;\n                        break;\n                    case 2:\n                        total += (this.elements[i]?.[j]) * v.z;\n                        break;\n                    default:\n                        break;\n                }\n            }\n            result[i] = total;\n        }\n        return new Vector3D((result[0]), (result[1]), (result[2]));\n    }\n    /**\n     * Returns a new Matrix object where each element is the reciprocal of the\n     * corresponding element in the current matrix. If an element in the current\n     * matrix is zero, the corresponding element in the output matrix will also be\n     * zero.\n     * @returns A new Matrix object representing the reciprocal of the current\n     * matrix.\n     */\n    reciprocal() {\n        const output = Matrix.zero(this.rows, this.columns);\n        for (let i = 0; i < this.rows; i++) {\n            for (let j = 0; j < this.columns; j++) {\n                if ((this.elements[i]?.[j]) !== 0) {\n                    (output.elements[i])[j] = 1 / (this.elements[i]?.[j]);\n                }\n            }\n        }\n        return output;\n    }\n    /**\n     * Transposes the matrix by swapping rows with columns.\n     * @returns A new Matrix object representing the transposed matrix.\n     */\n    transpose() {\n        const result = Matrix.zero(this.columns, this.rows);\n        for (let i = 0; i < this.rows; i++) {\n            for (let j = 0; j < this.columns; j++) {\n                (result.elements[j])[i] = (this.elements[i])[j];\n            }\n        }\n        return result;\n    }\n    /**\n     * Performs the Cholesky decomposition on the matrix.\n     * @returns A new Matrix object representing the Cholesky decomposition of the\n     * original matrix.\n     */\n    cholesky() {\n        const result = Matrix.zero(this.rows, this.rows);\n        for (let i = 0; i < this.rows; i++) {\n            for (let k = 0; k < i + 1; k++) {\n                let total = 0.0;\n                for (let j = 0; j < k; j++) {\n                    total += (result.elements[i]?.[j]) * (result.elements[k]?.[j]);\n                }\n                (result.elements[i])[k] =\n                    i === k\n                        ? Math.sqrt((this.elements[i]?.[i]) - total)\n                        : (1 / (result.elements[k]?.[k])) * ((this.elements[i]?.[k]) - total);\n            }\n        }\n        return result;\n    }\n    /**\n     * Swaps two rows in the matrix.\n     * @param i - The index of the first row.\n     * @param j - The index of the second row.\n     */\n    _swapRows(i, j) {\n        if (i === j) {\n            return;\n        }\n        const tmp = this.elements[i];\n        this.elements[i] = this.elements[j];\n        this.elements[j] = tmp;\n    }\n    /**\n     * Converts the matrix to reduced row echelon form using the Gaussian\n     * elimination method. This method modifies the matrix in-place.\n     */\n    toReducedRowEchelonForm_() {\n        for (let lead = 0, row = 0; row < this.rows && lead < this.columns; ++row, ++lead) {\n            let i = row;\n            while ((this.elements[i]?.[lead]) === 0) {\n                if (++i === this.rows) {\n                    i = row;\n                    if (++lead === this.columns) {\n                        return;\n                    }\n                }\n            }\n            this._swapRows(i, row);\n            if ((this.elements[row]?.[lead]) !== 0) {\n                const f = this.elements[row]?.[lead];\n                for (let column = 0; column < this.columns; ++column) {\n                    (this.elements[row])[column] /= f;\n                }\n            }\n            for (let j = 0; j < this.rows; ++j) {\n                if (j === row) {\n                    continue;\n                }\n                const f = (this.elements[j]?.[lead]);\n                for (let column = 0; column < this.columns; ++column) {\n                    ((this.elements[j])[column]) -= f * (this.elements[row]?.[column]);\n                }\n            }\n        }\n    }\n    /**\n     * Calculates the inverse of the matrix.\n     * @returns The inverse of the matrix.\n     */\n    inverse() {\n        const tmp = Matrix.zero(this.rows, this.columns * 2);\n        for (let row = 0; row < this.rows; ++row) {\n            for (let column = 0; column < this.columns; ++column) {\n                (tmp.elements[row])[column] = (this.elements[row])[column];\n            }\n            (tmp.elements[row])[row + this.columns] = 1.0;\n        }\n        tmp.toReducedRowEchelonForm_();\n        const inv = Matrix.zero(this.rows, this.columns);\n        for (let row = 0; row < this.rows; ++row) {\n            for (let column = 0; column < this.columns; ++column) {\n                ((inv.elements[row])[column]) = (tmp.elements[row]?.[column + this.columns]);\n            }\n        }\n        return inv;\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { Matrix, Vector, Vector3D, wrapAngle } from '../main.js';\nexport class Quaternion {\n    x;\n    y;\n    z;\n    w;\n    constructor(x, y, z, w) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n    }\n    static zero = new Quaternion(0, 0, 0, 0);\n    static one = new Quaternion(0, 0, 0, 1);\n    static xAxis = new Quaternion(1, 0, 0, 0);\n    static yAxis = new Quaternion(0, 1, 0, 0);\n    static zAxis = new Quaternion(0, 0, 1, 0);\n    toString(precision = 8) {\n        const xStr = this.x.toFixed(precision);\n        const yStr = this.y.toFixed(precision);\n        const zStr = this.z.toFixed(precision);\n        const wStr = this.w.toFixed(precision);\n        return `Q(x: ${xStr}, y: ${yStr}, z: ${zStr}, w: ${wStr})`;\n    }\n    positivePolar() {\n        return this.w >= 0 ? this.normalize() : this.negate().normalize();\n    }\n    magnitudeSquared() {\n        return this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z;\n    }\n    magnitude() {\n        return Math.sqrt(this.magnitudeSquared());\n    }\n    scale(n) {\n        return new Quaternion(n * this.x, n * this.y, n * this.z, n * this.w);\n    }\n    negate() {\n        return this.scale(-1);\n    }\n    normalize() {\n        const m = this.magnitude();\n        if (m === 0) {\n            return Quaternion.zero;\n        }\n        return this.scale(1 / m);\n    }\n    conjugate() {\n        return new Quaternion(-this.x, -this.y, -this.z, this.w);\n    }\n    inverse() {\n        return this.conjugate().scale(1 / this.magnitudeSquared());\n    }\n    add(q) {\n        return new Quaternion(this.x + q.x, this.y + q.y, this.z + q.z, this.w + q.w);\n    }\n    subtract(q) {\n        return new Quaternion(this.x - q.x, this.y - q.y, this.z - q.z, this.w - q.w);\n    }\n    addReal(n) {\n        return new Quaternion(this.x, this.y, this.z, this.w + n);\n    }\n    multiply(q) {\n        const mx = this.w * q.x + this.x * q.w + this.y * q.z - this.z * q.y;\n        const my = this.w * q.y - this.x * q.z + this.y * q.w + this.z * q.x;\n        const mz = this.w * q.z + this.x * q.y - this.y * q.x + this.z * q.w;\n        const mw = this.w * q.w - this.x * q.x - this.y * q.y - this.z * q.z;\n        return new Quaternion(mx, my, mz, mw);\n    }\n    dot(q) {\n        return this.x * q.x + this.y * q.y + this.z * q.z + this.w * q.w;\n    }\n    rotateVector(v) {\n        const q = this.multiply(new Quaternion(v.x, v.y, v.z, 0)).multiply(this.conjugate());\n        return new Vector([q.x, q.y, q.z]);\n    }\n    rotateVector3D(v) {\n        const q = this.multiply(new Quaternion(v.x, v.y, v.z, 0)).multiply(this.conjugate());\n        return new Vector3D(q.x, q.y, q.z);\n    }\n    lerp(q, t) {\n        const f = 1.0 - t;\n        return new Quaternion(f * this.x + t * q.x, f * this.y + t * q.y, f * this.z + t * q.z, f * this.w + t * q.w).positivePolar();\n    }\n    slerp(q, t) {\n        let qp = q;\n        let dotP = this.dot(qp);\n        if (dotP < 0) {\n            dotP = -dotP;\n            qp = qp.negate();\n        }\n        if (dotP > 0.9995) {\n            return this.lerp(qp, t);\n        }\n        const theta = Math.acos(dotP);\n        const sinTheta = Math.sin(theta);\n        const f1 = Math.sin((1.0 - t) * theta) / sinTheta;\n        const f2 = Math.sin(t * theta) / sinTheta;\n        return new Quaternion(f1 * this.x + f2 * qp.x, f1 * this.y + f2 * qp.y, f1 * this.z + f2 * qp.z, f1 * this.w + f2 * qp.w).positivePolar();\n    }\n    toVector3D() {\n        return new Vector3D(this.x, this.y, this.z);\n    }\n    angle(q) {\n        const c = this.multiply(q.conjugate()).normalize();\n        return 2 * Math.atan2(c.toVector3D().magnitude(), c.w);\n    }\n    geodesicAngle(q) {\n        const p = this.dot(q);\n        return wrapAngle(Math.acos(2 * p * p - 1.0));\n    }\n    distance(q) {\n        const m01 = this.subtract(q).magnitude();\n        const p01 = this.add(q).magnitude();\n        return m01 < p01 ? m01 : p01;\n    }\n    delta(qTo) {\n        return this.inverse().multiply(qTo);\n    }\n    toDirectionCosineMatrix() {\n        const w2 = this.w * this.w;\n        const x2 = this.x * this.x;\n        const y2 = this.y * this.y;\n        const z2 = this.z * this.z;\n        const m = [\n            [w2 + x2 - y2 - z2, 2.0 * (this.x * this.y + this.z * this.w), 2.0 * (this.x * this.z - this.y * this.w)],\n            [2.0 * (this.x * this.y - this.z * this.w), w2 - x2 + y2 - z2, 2.0 * (this.y * this.z + this.x * this.w)],\n            [2.0 * (this.x * this.z + this.y * this.w), 2.0 * (this.y * this.z - this.x * this.w), w2 - x2 - y2 + z2],\n        ];\n        return new Matrix(m);\n    }\n    toRotationMatrix() {\n        return this.toDirectionCosineMatrix().transpose();\n    }\n    vectorAngle(observer, target, forward) {\n        const delta = target.subtract(observer);\n        const transform = this.toDirectionCosineMatrix().multiplyVector3D(delta);\n        return forward.angle(transform);\n    }\n    kinematics(angularVelocity) {\n        const wPrime = new Vector([0, angularVelocity.x, angularVelocity.y, angularVelocity.z]);\n        const qMat = new Matrix([\n            [this.x, this.w, -this.z, this.y],\n            [this.y, this.z, this.w, -this.x],\n            [this.z, -this.y, this.x, this.w],\n            [this.w, -this.x, -this.y, -this.z],\n        ]);\n        const result = qMat.multiplyVector(wPrime).scale(0.5).elements;\n        return new Quaternion(result[0], result[1], result[2], result[3]);\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * A generator of random bool, int, or double values.\n *\n * The default implementation supplies a stream of pseudo-random bits that are not suitable for cryptographic purposes.\n */\nexport class Random {\n    _seed;\n    constructor(seed = 0) {\n        this._seed = seed;\n    }\n    nextFloat(max = 1) {\n        this._seed = (this._seed * 9301 + 49297) % 233280;\n        return (this._seed / 233280) * max;\n    }\n    /**\n     * To create a non-negative random integer uniformly distributed in the range from 0,\n     * inclusive, to max, exclusive, use nextInt(int max).\n     * @param max The bound on the random number to be returned. Must be positive.\n     * @returns A pseudorandom, uniformly distributed int value between 0 (inclusive) and the specified value (exclusive).\n     */\n    nextInt(max = 1) {\n        return Math.round(this.nextFloat(max) * max);\n    }\n    nextBool() {\n        return this.nextFloat() > 0.5;\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { Vector } from '../main.js';\nimport { BoxMuller } from './BoxMuller.js';\nexport class RandomGaussianSource {\n    boxMuller_;\n    constructor(seed = 0) {\n        this.boxMuller_ = new BoxMuller(0, 1, seed);\n    }\n    nextGauss() {\n        return this.boxMuller_.nextGauss();\n    }\n    gaussVector(n) {\n        if (n < 1) {\n            throw new Error('n must be greater than 0');\n        }\n        const result = new Vector([this.nextGauss()]);\n        for (let i = 0; i < n; i++) {\n            if (i > 0) {\n                result.add(new Vector([this.nextGauss()]));\n            }\n        }\n        return result;\n    }\n    gaussSphere(radius = 1.0) {\n        return this.gaussVector(3).toVector3D(0).normalize().scale(radius);\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { Matrix, Vector3D } from '../main.js';\n/**\n * A Vector is a mathematical object that has both magnitude and direction.\n */\nexport class Vector {\n    elements;\n    /**\n     * The length of the vector.\n     */\n    length;\n    /**\n     * Represents a 3-dimensional vector.\n     */\n    static origin3 = new Vector([0, 0, 0]);\n    /**\n     * Represents a vector with all elements set to zero.\n     */\n    static origin6 = new Vector([0, 0, 0, 0, 0, 0]);\n    /**\n     * Represents the x-axis vector.\n     */\n    static xAxis = new Vector([1, 0, 0]);\n    /**\n     * Represents the y-axis vector.\n     */\n    static yAxis = new Vector([0, 1, 0]);\n    /**\n     * Represents the z-axis vector.\n     */\n    static zAxis = new Vector([0, 0, 1]);\n    /**\n     * Represents a vector pointing along the negative x-axis.\n     */\n    static xAxisNeg = new Vector([-1, 0, 0]);\n    /**\n     * Represents a vector pointing along the negative y-axis.\n     */\n    static yAxisNeg = new Vector([0, -1, 0]);\n    /**\n     * Represents a vector pointing along the negative z-axis.\n     */\n    static zAxisNeg = new Vector([0, 0, -1]);\n    constructor(elements) {\n        this.elements = elements;\n        this.length = elements.length;\n    }\n    /**\n     * Creates a zero vector of the specified length.\n     * @param length The length of the vector.\n     * @returns A new Vector object representing the zero vector.\n     */\n    static zero(length) {\n        return new Vector(new Array(length).fill(0));\n    }\n    /**\n     * Creates a new Vector with the specified length, filled with the specified\n     * value.\n     * @param length The length of the new Vector.\n     * @param value The value to fill the Vector with.\n     * @returns A new Vector filled with the specified value.\n     */\n    static filled(length, value) {\n        return new Vector(new Array(length).fill(value));\n    }\n    /**\n     * Creates a new Vector instance from an array of elements.\n     * @param elements - The array of elements to create the Vector from.\n     * @returns A new Vector instance.\n     */\n    static fromList(elements) {\n        return new Vector(elements);\n    }\n    /**\n     * Returns a string representation of the vector.\n     * @param fixed - The number of digits to appear after the decimal point.\n     * Defaults to -1.\n     * @returns A string representation of the vector.\n     */\n    toString(fixed = -1) {\n        if (fixed < 0) {\n            return `[${this.elements.join(', ')}]`;\n        }\n        const output = this.elements.map((e) => e.toFixed(fixed));\n        return `[${output.join(', ')}]`;\n    }\n    /**\n     * Returns a string representation of the x value of the vector.\n     * @returns A string representation of the x value of the vector.\n     */\n    get x() {\n        return this.elements[0];\n    }\n    /**\n     * Returns a string representation of the y value of the vector.\n     * @returns A string representation of the y value of the vector.\n     */\n    get y() {\n        return this.elements[1];\n    }\n    /**\n     * Returns a string representation of the z value of the vector.\n     * @returns A string representation of the z value of the vector.\n     */\n    get z() {\n        return this.elements[2];\n    }\n    /**\n     * Converts the vector elements to an array.\n     * @returns An array containing the vector elements.\n     */\n    toList() {\n        return Array.from(this.elements);\n    }\n    /**\n     * Converts the vector to a Float64Array.\n     * @returns The vector as a Float64Array.\n     */\n    toArray() {\n        return new Float64Array(this.elements);\n    }\n    /**\n     * Calculates the magnitude of the vector.\n     * @returns The magnitude of the vector.\n     */\n    magnitude() {\n        let total = 0;\n        for (const x of this.elements) {\n            total += x * x;\n        }\n        return Math.sqrt(total);\n    }\n    /**\n     * Adds the elements of another vector to this vector and returns a new\n     * vector.\n     * @param v - The vector to add.\n     * @returns A new vector containing the sum of the elements.\n     */\n    add(v) {\n        const output = new Array(this.length);\n        for (let i = 0; i < this.length; i++) {\n            output[i] = this.elements[i] + (v.elements[i]);\n        }\n        return new Vector(output);\n    }\n    /**\n     * Subtracts a vector from the current vector.\n     * @param v The vector to subtract.\n     * @returns A new vector representing the result of the subtraction.\n     */\n    subtract(v) {\n        const output = new Array(this.length);\n        for (let i = 0; i < this.length; i++) {\n            output[i] = this.elements[i] - (v.elements[i]);\n        }\n        return new Vector(output);\n    }\n    /**\n     * Scales the vector by a given factor.\n     * @param n The scaling factor.\n     * @returns A new Vector object representing the scaled vector.\n     */\n    scale(n) {\n        const output = new Array(this.length);\n        for (let i = 0; i < this.length; i++) {\n            output[i] = this.elements[i] * n;\n        }\n        return new Vector(output);\n    }\n    /**\n     * Negates the vector by scaling it by -1.\n     * @returns A new Vector object representing the negated vector.\n     */\n    negate() {\n        return this.scale(-1);\n    }\n    /**\n     * Return the Euclidean distance between this and another Vector.\n     * @param v The vector to calculate the distance to.\n     * @returns The distance between the two vectors.\n     */\n    distance(v) {\n        return this.subtract(v).magnitude();\n    }\n    /**\n     * Normalizes the vector, making it a unit vector with the same direction but\n     * a magnitude of 1. If the vector has a magnitude of 0, it returns a zero\n     * vector of the same length.\n     * @returns The normalized vector.\n     */\n    normalize() {\n        const m = this.magnitude();\n        if (m === 0) {\n            return Vector.zero(this.length);\n        }\n        return this.scale(1.0 / m);\n    }\n    /**\n     * Calculates the dot product of this vector and another vector.\n     * @param v - The vector to calculate the dot product with.\n     * @returns The dot product of the two vectors.\n     */\n    dot(v) {\n        let total = 0;\n        for (let i = 0; i < this.length; i++) {\n            total += this.elements[i] * (v.elements[i]);\n        }\n        return total;\n    }\n    /**\n     * Calculates the outer product of this vector with another vector.\n     * @param v The vector to calculate the outer product with.\n     * @returns A matrix representing the outer product of the two vectors.\n     */\n    outer(v) {\n        const result = [];\n        for (let i = 0; i < this.length; i++) {\n            result[i] = [];\n            for (let j = 0; j < v.length; j++) {\n                (result[i])[j] = this.elements[i] * (v.elements[j]);\n            }\n        }\n        return new Matrix(result);\n    }\n    /**\n     * Calculates the cross product of this vector and the given vector.\n     * @param v - The vector to calculate the cross product with.\n     * @returns The resulting vector.\n     */\n    cross(v) {\n        const output = new Array(this.length);\n        for (let i = 0; i < this.length; i++) {\n            output[i] =\n                this.elements[(i + 1) % this.length] * (v.elements[(i + 2) % this.length]) -\n                    this.elements[(i + 2) % this.length] * (v.elements[(i + 1) % this.length]);\n        }\n        return new Vector(output);\n    }\n    /**\n     * Calculate the skew-symmetric matrix for this [Vector].\n     * @returns The skew-symmetric matrix.\n     * @throws [Error] if the vector is not of length 3.\n     */\n    skewSymmetric() {\n        if (this.length !== 3) {\n            throw new Error('Skew-symmetric matrix requires a vector of length 3.');\n        }\n        return new Matrix([\n            [0, -this.elements[2], this.elements[1]],\n            [this.elements[2], 0, -this.elements[0]],\n            [-this.elements[1], this.elements[0], 0],\n        ]);\n    }\n    /**\n     * Rotates the vector around the X-axis by the specified angle.\n     * @param theta The angle in radians.\n     * @returns The rotated vector.\n     */\n    rotX(theta) {\n        const cosT = Math.cos(theta);\n        const sinT = Math.sin(theta);\n        const output = new Array(3);\n        output[0] = this.elements[0];\n        output[1] = cosT * this.elements[1] + sinT * this.elements[2];\n        output[2] = -sinT * this.elements[1] + cosT * this.elements[2];\n        return new Vector(output);\n    }\n    /**\n     * Rotates the vector around the Y-axis by the specified angle.\n     * @param theta The angle of rotation in radians.\n     * @returns A new Vector representing the rotated vector.\n     */\n    rotY(theta) {\n        const cosT = Math.cos(theta);\n        const sinT = Math.sin(theta);\n        const output = new Array(3);\n        output[0] = cosT * this.elements[0] + -sinT * this.elements[2];\n        output[1] = this.elements[1];\n        output[2] = sinT * this.elements[0] + cosT * this.elements[2];\n        return new Vector(output);\n    }\n    /**\n     * Rotates the vector around the Z-axis by the specified angle.\n     * @param theta The angle of rotation in radians.\n     * @returns A new Vector representing the rotated vector.\n     */\n    rotZ(theta) {\n        const cosT = Math.cos(theta);\n        const sinT = Math.sin(theta);\n        const output = new Array(3);\n        output[0] = cosT * this.elements[0] + sinT * this.elements[1];\n        output[1] = -sinT * this.elements[0] + cosT * this.elements[1];\n        output[2] = this.elements[2];\n        return new Vector(output);\n    }\n    /**\n     * Calculates the angle between this vector and another vector.\n     * @param v The other vector.\n     * @returns The angle between the two vectors in radians.\n     */\n    angle(v) {\n        // better than acos for small angles\n        const theta = Math.atan2(this.cross(v).magnitude(), this.dot(v));\n        if (isNaN(theta)) {\n            return 0.0;\n        }\n        return theta;\n    }\n    /**\n     * Calculates the angle between this vector and another vector in degrees.\n     * @param v The other vector.\n     * @returns The angle between the two vectors in degrees.\n     */\n    angleDegrees(v) {\n        return (this.angle(v) * (180 / Math.PI));\n    }\n    /**\n     * Determines if there is line of sight between this vector and another vector\n     * within a given radius.\n     * @param v - The vector to check line of sight with.\n     * @param radius - The radius within which line of sight is considered.\n     * @returns True if there is line of sight, false otherwise.\n     */\n    sight(v, radius) {\n        const r1Mag2 = this.magnitude() ** 2;\n        const r2Mag2 = v.magnitude() ** 2;\n        const rDot = this.dot(v);\n        const tMin = (r1Mag2 - rDot) / (r1Mag2 + r2Mag2 - 2.0 * rDot);\n        let los = false;\n        if (tMin < 0 || tMin > 1) {\n            los = true;\n        }\n        else {\n            const c = (1.0 - tMin) * r1Mag2 + rDot * tMin;\n            if (c >= radius * radius) {\n                los = true;\n            }\n        }\n        return los;\n    }\n    /**\n     * Returns the bisect vector between this vector and the given vector. The\n     * bisect vector is calculated by scaling this vector's magnitude by the\n     * magnitude of the given vector, adding the result to the product of scaling\n     * the given vector's magnitude by this vector's magnitude, and then\n     * normalizing the resulting vector.\n     * @param v - The vector to calculate the bisect with.\n     * @returns The bisect vector.\n     */\n    bisect(v) {\n        return this.scale(v.magnitude()).add(v.scale(this.magnitude())).normalize();\n    }\n    /**\n     * Joins the current vector with another vector.\n     * @param v The vector to join with.\n     * @returns A new vector that contains the elements of both vectors.\n     */\n    join(v) {\n        return new Vector(this.toList().concat(v.toList()));\n    }\n    /**\n     * Returns a new Vector containing a portion of the elements from the\n     * specified start index to the specified end index\n     * @param start The start index of the slice (inclusive).\n     * @param end The end index of the slice (exclusive).\n     * @returns A new Vector containing the sliced elements.\n     */\n    slice(start, end) {\n        return new Vector(this.elements.slice(start, end));\n    }\n    /**\n     * Returns a new Matrix object representing the row vector.\n     * @returns The row vector as a Matrix object.\n     */\n    row() {\n        return new Matrix([this.toList()]);\n    }\n    /**\n     * Returns a new Matrix object representing the column vector of this Vector.\n     * @returns The column vector as a Matrix object.\n     */\n    column() {\n        return new Matrix(this.toList().map((e) => [e]));\n    }\n    /**\n     * Converts the elements at the specified index to a Vector3D object.\n     * @param index - The index of the elements to convert.\n     * @returns A new Vector3D object containing the converted elements.\n     */\n    toVector3D(index) {\n        return new Vector3D(this.elements[index], this.elements[index + 1], this.elements[index + 2]);\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { linearDistance } from '../main.js';\nimport { Matrix } from './Matrix.js';\nimport { Vector } from './Vector.js';\n// / 3-dimensional vector.\nexport class Vector3D {\n    x;\n    y;\n    z;\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        // Nothing to do here.\n    }\n    /**\n     * Create a new Vector3D object from the first three elements of a Vector\n     * object.\n     * @param v The Vector object to convert.\n     * @returns A new Vector3D object.\n     */\n    static fromVector(v) {\n        return new Vector3D(v.x, v.y, v.z);\n    }\n    // / Origin vector.\n    static origin = new Vector3D(0, 0, 0);\n    // / X-axis unit vector.\n    static xAxis = new Vector3D(1, 0, 0);\n    // / Y-axis unit vector.\n    static yAxis = new Vector3D(0, 1, 0);\n    // / Z-axis unit vector.\n    static zAxis = new Vector3D(0, 0, 1);\n    // / Negative x-axis unit vector.\n    static xAxisNeg = new Vector3D(-1, 0, 0);\n    // / Negative y-axis unit vector.\n    static yAxisNeg = new Vector3D(0, -1, 0);\n    // / Negative z-axis unit vector.\n    static zAxisNeg = new Vector3D(0, 0, -1);\n    // / Convert this to a [List] of doubles.\n    toList() {\n        return [this.x, this.y, this.z];\n    }\n    // / Convert this to a [Float64List] object.\n    toArray() {\n        return new Float64Array([this.x, this.y, this.z]);\n    }\n    /**\n     * Return the Vector3D element at the provided index.\n     * @deprecated don't do this\n     * @param index The index of the element to return.\n     * @returns The element at the provided index.\n     */\n    getElement(index) {\n        switch (index) {\n            case 0:\n                return this.x;\n            case 1:\n                return this.y;\n            case 2:\n                return this.z;\n            default:\n                throw new Error(`Index ${index} outside 3D vector bounds.`);\n        }\n    }\n    // / Convert this to a [Vector] object.\n    toVector() {\n        return new Vector(this.toList());\n    }\n    toString(fixed = -1) {\n        if (fixed < 0) {\n            return `[${this.toList().join(', ')}]`;\n        }\n        const output = this.toList().map((e) => e.toFixed(fixed));\n        return `[${output.join(', ')}]`;\n    }\n    // / Return the magnitude of this vector.\n    magnitude() {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n    }\n    // / Return the result of adding this to another [Vector3D].\n    add(v) {\n        return new Vector3D((this.x + v.x), (this.y + v.y), (this.z + v.z));\n    }\n    // / Return the result of subtracting this and another [Vector3D].\n    subtract(v) {\n        return new Vector3D((this.x - v.x), (this.y - v.y), (this.z - v.z));\n    }\n    // / Return a copy of this [Vector3D] scaled by [n];\n    scale(n) {\n        return new Vector3D(this.x * n, this.y * n, this.z * n);\n    }\n    // / Return a copy of this [Vector3D] with the elements negated.\n    negate() {\n        return this.scale(-1);\n    }\n    /**\n     * Return the Euclidean distance between this and another Vector3D.\n     * @param v The other Vector3D.\n     * @returns The distance between this and the other Vector3D.\n     */\n    distance(v) {\n        return linearDistance(this, v);\n    }\n    /**\n     * Convert this to a unit Vector3D.\n     * @returns A unit Vector3D.\n     */\n    normalize() {\n        const m = this.magnitude();\n        if (m === 0) {\n            return Vector3D.origin;\n        }\n        return new Vector3D(this.x / m, this.y / m, this.z / m);\n    }\n    // Calculate the dot product of this and another [Vector3D].\n    dot(v) {\n        return this.x * v.x + this.y * v.y + this.z * v.z;\n    }\n    // Calculate the outer product between this and another [Vector3D].\n    outer(v) {\n        return new Matrix([\n            [this.x * v.x, this.x * v.y, this.x * v.z],\n            [this.y * v.x, this.y * v.y, this.y * v.z],\n            [this.z * v.x, this.z * v.y, this.z * v.z],\n        ]);\n    }\n    // Calculate the cross product of this and another [Vector3D].\n    cross(v) {\n        return new Vector3D((this.y * v.z - this.z * v.y), (this.z * v.x - this.x * v.z), (this.x * v.y - this.y * v.x));\n    }\n    // Calculate the skew-symmetric matrix for this [Vector3D].\n    skewSymmetric() {\n        return new Matrix([\n            [0, -this.z, this.y],\n            [this.z, 0, -this.x],\n            [-this.y, this.x, 0],\n        ]);\n    }\n    /*\n     * Create a copy of this [Vector3D] rotated in the x-axis by angle [theta]\n     * _(rad)_.\n     */\n    rotX(theta) {\n        const cosT = Math.cos(theta);\n        const sinT = Math.sin(theta);\n        return new Vector3D(this.x, cosT * this.y + sinT * this.z, -sinT * this.y + cosT * this.z);\n    }\n    /*\n     * Create a copy of this [Vector3D] rotated in the y-axis by angle [theta]\n     * _(rad)_.\n     */\n    rotY(theta) {\n        const cosT = Math.cos(theta);\n        const sinT = Math.sin(theta);\n        return new Vector3D((cosT * this.x + -sinT * this.z), this.y, (sinT * this.x + cosT * this.z));\n    }\n    /*\n     * Create a copy of this [Vector3D] rotated in the z-axis by angle [theta]\n     * _(rad)_.\n     */\n    rotZ(theta) {\n        const cosT = Math.cos(theta);\n        const sinT = Math.sin(theta);\n        return new Vector3D((cosT * this.x + sinT * this.y), (-sinT * this.x + cosT * this.y), this.z);\n    }\n    // Calculate the angle _(rad)_ between this and another [Vector3D].\n    angle(v) {\n        const theta = Math.atan2(this.cross(v).magnitude(), this.dot(v));\n        return isNaN(theta) ? 0 : theta;\n    }\n    // Calculate the angle _(Â°)_ between this and another [Vector3D].\n    angleDegrees(v) {\n        return this.angle(v) * (180 / Math.PI);\n    }\n    /*\n     * Return `true` if line-of-sight exists between this and another [Vector3D]\n     * with a central body of the given [radius].\n     */\n    sight(v, radius) {\n        const r1Mag2 = this.magnitude() ** 2;\n        const r2Mag2 = v.magnitude() ** 2;\n        const rDot = this.dot(v);\n        const tMin = (r1Mag2 - rDot) / (r1Mag2 + r2Mag2 - 2 * rDot);\n        let los = false;\n        if (tMin < 0 || tMin > 1) {\n            los = true;\n        }\n        else {\n            const c = (1 - tMin) * r1Mag2 + rDot * tMin;\n            if (c >= radius * radius) {\n                los = true;\n            }\n        }\n        return los;\n    }\n    // / Return the unit vector that bisects this and another [Vector3D].\n    bisect(v) {\n        return this.scale(v.magnitude()).add(v.scale(this.magnitude())).normalize();\n    }\n    // / Convert this [Vector3D] into a row [Matrix].\n    row() {\n        return new Matrix([[this.x, this.y, this.z]]);\n    }\n    // / Convert this [Vector3D] into a column [Matrix].\n    column() {\n        return new Matrix([[this.x], [this.y], [this.z]]);\n    }\n    // / Join this and another [Vector3D] into a new [Vector] object.\n    join(v) {\n        const output = new Float64Array(6);\n        output[0] = this.x;\n        output[1] = this.y;\n        output[2] = this.z;\n        output[3] = v.x;\n        output[4] = v.y;\n        output[5] = v.z;\n        return new Vector(output);\n    }\n}\n","export { BoxMuller } from './BoxMuller.js';\nexport { EulerAngles } from './EulerAngles.js';\nexport { Quaternion } from './Quaternion.js';\nexport { RandomGaussianSource } from './RandomGaussianSource.js';\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nexport { Matrix } from './Matrix.js';\nexport { Random } from './Random.js';\nexport { Vector } from './Vector.js';\nexport { Vector3D } from './Vector3D.js';\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { SimplexEntry } from './SimplexEntry.js';\n// / Derivative-free Nelder-Mead simplex optimizer.\nexport class DownhillSimplex {\n    constructor() {\n        // disable constructor\n    }\n    /**\n     * Compute the centroid from a list of [SimplexEntry] objects, using cost\n     * function [f].\n     * @param f Cost function\n     * @param xss Simplex entries\n     * @returns The centroid.\n     */\n    static _centroid(f, xss) {\n        const n = xss[0].points.length;\n        const m = xss.length - 1;\n        const output = new Float64Array(n);\n        for (let i = 0; i < m; i++) {\n            for (let j = 0; j < n; j++) {\n                output[j] += xss[i].points[j];\n            }\n        }\n        for (let i = 0; i < n; i++) {\n            output[i] /= m;\n        }\n        return new SimplexEntry(f, output);\n    }\n    static _shrink(s, xss) {\n        const x1 = xss[0];\n        for (let i = 1; i < xss.length; i++) {\n            const xi = xss[i];\n            xss[i] = x1.modify(s, xi, x1);\n        }\n    }\n    /**\n     * Generate a new simplex from initial guess [x0], and an optional\n     * simplex [step] value.\n     * @param x0 Initial guess\n     * @param step Simplex step\n     * @returns The simplex.\n     */\n    static generateSimplex(x0, step = 0.01) {\n        const output = [x0.slice(0)];\n        for (let i = 0; i < x0.length; i++) {\n            const tmp = x0.slice(0);\n            tmp[i] += tmp[i] * step;\n            output.push(tmp);\n        }\n        return output;\n    }\n    /**\n     * Perform derivative-free Nelder-Mead simplex optimization to minimize the\n     * cost function [f] for the initial simplex [xs].\n     *\n     * Optional arguments:\n     *  - `xTolerance`: centroid delta termination criteria\n     * - `fTolerance`: cost function delta termination criteria\n     * - `maxIter`: maximum number of optimization iterations\n     * - `adaptive`: use adaptive coefficients if possible\n     * - `printIter`: print a debug statement after each iteration\n     * @param f Cost function\n     * @param xs Initial simplex\n     * @param root0 Root0\n     * @param root0.xTolerance Root0.xTolerance\n     * @param root0.fTolerance Root0.fTolerance\n     * @param root0.maxIter Root0.maxIter\n     * @param root0.adaptive Root0.adaptive\n     * @param root0.printIter Root0.printIter\n     * @returns The optimal input value.\n     */\n    static solveSimplex(f, xs, { xTolerance = 1e-12, fTolerance = 1e-12, maxIter = 10000, adaptive = false, printIter = false, }) {\n        let a;\n        let g;\n        let p;\n        let s;\n        const n = xs.length - 1;\n        if (adaptive && n >= 2) {\n            a = 1.0;\n            g = 1.0 + 2.0 / n;\n            p = 0.75 - 1.0 / (2.0 * n);\n            s = 1.0 - 1.0 / n;\n        }\n        else {\n            a = 1.0;\n            g = 2.0;\n            p = 0.5;\n            s = 0.5;\n        }\n        let iter = 0;\n        let action = 'init';\n        const ordered = [];\n        for (const x of xs) {\n            ordered.push(new SimplexEntry(f, x));\n        }\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            ordered.sort((x, y) => x.score - y.score);\n            const x0 = DownhillSimplex._centroid(f, ordered);\n            // update exit criterea\n            let xd = 0.0;\n            let fd = 0.0;\n            for (let i = 1; i < ordered.length; i++) {\n                xd = Math.max(xd, x0.distance(ordered[i]));\n                fd = Math.max(fd, Math.abs(x0.score - ordered[i].score));\n            }\n            if (printIter) {\n                // eslint-disable-next-line no-console\n                console.log(`${iter}: score=${x0.score} xd=${xd} fd=${fd} [${action}]`);\n            }\n            if (iter !== 0 && (xd < xTolerance || fd < fTolerance)) {\n                return ordered[0].points;\n            }\n            if (iter >= maxIter) {\n                return ordered[0].points;\n            }\n            iter++;\n            // reflection\n            const xr = x0.modify(a, x0, ordered[ordered.length - 1]);\n            if (ordered[0].score <= xr.score && xr.score < ordered[ordered.length - 2].score) {\n                ordered[ordered.length - 1] = xr;\n                action = 'reflect';\n                continue;\n            }\n            // expansion\n            if (xr.score < ordered[0].score) {\n                const xe = x0.modify(g, xr, x0);\n                if (xe.score < xr.score) {\n                    ordered[ordered.length - 1] = xe;\n                }\n                else {\n                    ordered[ordered.length - 1] = xr;\n                }\n                action = 'expand';\n                continue;\n            }\n            // contraction\n            if (xr.score < ordered[ordered.length - 1].score) {\n                const xc = x0.modify(p, xr, x0);\n                if (xc.score < xr.score) {\n                    ordered[ordered.length - 1] = xc;\n                    action = 'contract';\n                    continue;\n                }\n                else {\n                    DownhillSimplex._shrink(s, ordered);\n                    action = 'shrink';\n                    continue;\n                }\n            }\n            else if (xr.score >= ordered[ordered.length - 1].score) {\n                const xc = x0.modify(p, ordered[ordered.length - 1], x0);\n                if (xc.score < ordered[ordered.length - 1].score) {\n                    ordered[ordered.length - 1] = xc;\n                    action = 'contract';\n                    continue;\n                }\n                else {\n                    DownhillSimplex._shrink(s, ordered);\n                    action = 'shrink';\n                    continue;\n                }\n            }\n        }\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\n// / Golden Section bounded single value optimizer.\nexport class GoldenSection {\n    static _grInv = 1.0 / (0.5 * (Math.sqrt(5) + 1));\n    static check_(fc, fd, solveMax) {\n        return solveMax ? fc > fd : fc < fd;\n    }\n    /**\n     * Search for an optimal input value for function [f] that minimizes the\n     * output value.\n     *\n     * Takes [lower] and [upper] input search bounds, and an optional\n     * search [tolerance].\n     * @param f Function to optimize\n     * @param lower Lower bound\n     * @param upper Upper bound\n     * @param root0 Root0\n     * @param root0.tolerance Root0.tolerance\n     * @param root0.solveMax Root0.solveMax\n     * @returns The optimal input value.\n     */\n    static search(f, lower, upper, { tolerance = 1e-5, solveMax = false, }) {\n        let a = lower;\n        let b = upper;\n        let c = b - (b - a) * GoldenSection._grInv;\n        let d = a + (b - a) * GoldenSection._grInv;\n        while (Math.abs(b - a) > tolerance) {\n            if (GoldenSection.check_(f(c), f(d), solveMax)) {\n                b = d;\n            }\n            else {\n                a = c;\n            }\n            c = b - (b - a) * GoldenSection._grInv;\n            d = a + (b - a) * GoldenSection._grInv;\n        }\n        return 0.5 * (b + a);\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { Vector } from '../main.js';\nexport class SimplexEntry {\n    f_;\n    points;\n    score;\n    x_;\n    constructor(f_, points) {\n        this.f_ = f_;\n        this.points = points;\n        this.x_ = new Vector(points);\n        this.score = this.f_(points);\n    }\n    getPoints() {\n        return this.x_.toArray();\n    }\n    getScore() {\n        return this.score;\n    }\n    modify(n, xa, xb) {\n        return new SimplexEntry(this.f_, this.x_.add(xa.x_.subtract(xb.x_).scale(n)).toArray());\n    }\n    distance(se) {\n        return this.x_.distance(se.x_);\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { concat, J2000, Matrix, Vector, Vector3D } from '../main.js';\nimport { PropagatorPairs } from '../observation/PropagatorPairs.js';\nimport { CovarianceFrame, StateCovariance } from './../covariance/StateCovariance.js';\nimport { ForceModel } from './../force/ForceModel.js';\nimport { KeplerPropagator } from './../propagator/KeplerPropagator.js';\nimport { RungeKutta89Propagator } from './../propagator/RungeKutta89Propagator.js';\nimport { BatchLeastSquaresResult } from './BatchLeastSquaresResult.js';\n/**\n * Batch least squares orbit determination.\n */\nexport class BatchLeastSquaresOD {\n    observations_;\n    apriori_;\n    forceModel_;\n    posStep_;\n    velStep_;\n    fastDerivatives_;\n    /** Propagator pair cache, for generating observation Jacobians. */\n    propPairs_;\n    /**  Nominal state propagator. */\n    propagator_;\n    /**  State estimate during solve. */\n    nominal_;\n    /**  Solve start epoch. */\n    start_;\n    /**\n     * Create a new [BatchLeastSquaresOD] object from a list of [Observation]\n     * objects, an [apriori] state estimate, and an optional\n     * spacecraft [forceModel].\n     * @param observations_ List of observations.\n     * @param apriori_ Apriori state estimate.\n     * @param forceModel_ Spacecraft force model.\n     * @param posStep_ Position step size.\n     * @param velStep_ Velocity step size.\n     * @param fastDerivatives_ Use fast derivatives.\n     * @returns [BatchLeastSquaresOD] object.\n     */\n    constructor(observations_, apriori_, forceModel_, posStep_ = 1e-5, velStep_ = 1e-5, fastDerivatives_ = false) {\n        this.observations_ = observations_;\n        this.apriori_ = apriori_;\n        this.forceModel_ = forceModel_;\n        this.posStep_ = posStep_;\n        this.velStep_ = velStep_;\n        this.fastDerivatives_ = fastDerivatives_;\n        this.observations_.sort((a, b) => a.epoch.posix - b.epoch.posix);\n        this.start_ = this.observations_[0].epoch;\n        this.propPairs_ = new PropagatorPairs(this.posStep_, this.velStep_);\n        this.forceModel_ ??= new ForceModel().setGravity();\n        this.propagator_ = new RungeKutta89Propagator(this.apriori_, this.forceModel_);\n        this.nominal_ = this.propagator_.propagate(this.start_);\n    }\n    buildPropagator_(x0, simple) {\n        const state = new J2000(this.nominal_.epoch, new Vector3D(x0[0], x0[1], x0[2]), new Vector3D(x0[3], x0[4], x0[5]));\n        if (simple) {\n            return new KeplerPropagator(state.toClassicalElements());\n        }\n        return new RungeKutta89Propagator(state, this.forceModel_);\n    }\n    static stateToX0_(state) {\n        return concat(state.position.toArray(), state.velocity.toArray());\n    }\n    setPropagatorPairs_(x0) {\n        const pl = this.buildPropagator_(x0, this.fastDerivatives_);\n        for (let i = 0; i < 6; i++) {\n            const step = this.propPairs_.step(i);\n            const xh = x0.slice();\n            xh[i] += step;\n            const ph = this.buildPropagator_(xh, this.fastDerivatives_);\n            this.propPairs_.set(i, ph, pl);\n        }\n    }\n    /**\n     * Attempt to solve a state estimate with the given root-mean-squared delta\n     * [tolerance].\n     * @param root0 Root initial guess.\n     * @param root0.tolerance Root-mean-squared delta tolerance.\n     * @param root0.maxIter Maximum number of iterations.\n     * @param root0.printIter Print iterations.\n     * @returns [BatchLeastSquaresResult] object.\n     */\n    solve({ tolerance = 1e-3, maxIter = 250, printIter = false, } = {}) {\n        let breakFlag = false;\n        const xNom = BatchLeastSquaresOD.stateToX0_(this.nominal_);\n        let weightedRms = Infinity;\n        const atwaMatInit = Matrix.zero(6, 6);\n        const atwbMatInit = Matrix.zero(6, 1);\n        let atwaMat = atwaMatInit;\n        for (let iter = 0; iter < maxIter; iter++) {\n            atwaMat = atwaMatInit;\n            let atwbMat = atwbMatInit;\n            this.propagator_ = this.buildPropagator_(xNom, false);\n            this.setPropagatorPairs_(xNom);\n            let rmsTotal = 0.0;\n            let measCount = 0;\n            for (const ob of this.observations_) {\n                const noise = ob.noise;\n                const aMat = ob.jacobian(this.propPairs_);\n                const aMatTN = aMat.transpose().multiply(noise);\n                const bMat = ob.residual(this.propagator_);\n                atwaMat = atwaMat.add(aMatTN.multiply(aMat));\n                atwbMat = atwbMat.add(aMatTN.multiply(bMat));\n                rmsTotal += bMat.transpose().multiply(noise).multiply(bMat).elements[0][0];\n                measCount += noise.rows;\n            }\n            const newWeightedRms = Math.sqrt(rmsTotal / measCount);\n            if (printIter) {\n                // eslint-disable-next-line no-console\n                console.log(`${iter + 1}: rms=${newWeightedRms} x=${new Vector(xNom)}`);\n            }\n            if (Math.abs((weightedRms - newWeightedRms) / weightedRms) <= tolerance) {\n                breakFlag = true;\n            }\n            weightedRms = newWeightedRms;\n            const dX = atwaMat.inverse().multiply(atwbMat);\n            for (let i = 0; i < 6; i++) {\n                xNom[i] += dX.elements[i][0];\n            }\n            if (breakFlag) {\n                break;\n            }\n        }\n        const p = atwaMat.inverse();\n        const covariance = new StateCovariance(p, CovarianceFrame.ECI);\n        return new BatchLeastSquaresResult(this.buildPropagator_(xNom, false).propagate(this.start_), covariance, weightedRms);\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\n// / Batch least squares orbit determination result.\nexport class BatchLeastSquaresResult {\n    state;\n    covariance;\n    rms;\n    /**\n     * Create a new [BatchLeastSquaresResult] object, containing the solved\n     * [state], [covariance], and root-mean-squared error [rms].\n     * @param state The solved state.\n     * @param covariance The solved covariance.\n     * @param rms The root-mean-squared error.\n     */\n    constructor(state, covariance, rms) {\n        this.state = state;\n        this.covariance = covariance;\n        this.rms = rms;\n        // Nothing to do here.\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { DEG2RAD, Earth, halfPi, J2000, } from '../main.js';\nimport { ForceModel } from './../force/ForceModel.js';\nimport { RungeKutta89Propagator } from './../propagator/RungeKutta89Propagator.js';\n/**\n * Gibbs 3-position inital orbit determination.\n */\nexport class GibbsIOD {\n    mu;\n    constructor(mu = Earth.mu) {\n        this.mu = mu;\n        // Nothing to do here.\n    }\n    /** Abort solve if position plane exceeds this value. */\n    static coplanarThreshold_ = (5.0 * DEG2RAD);\n    /**\n     * Attempt to create a state estimate from three inertial position vectors.\n     *\n     * Throws an error if the positions are not coplanar.\n     * @param r1 Position vector 1.\n     * @param r2 Position vector 2.\n     * @param r3 Position vector 3.\n     * @param t2 Time of position 2.\n     * @param t3 Time of position 3.\n     * @returns State estimate at time t2.\n     */\n    solve(r1, r2, r3, t2, t3) {\n        const num = r1.normalize().dot(r2.normalize().cross(r3.normalize()));\n        const alpha = halfPi - Math.acos(num);\n        if (Math.abs(alpha) > GibbsIOD.coplanarThreshold_) {\n            throw new Error('Orbits are not coplanar.');\n        }\n        const r1m = r1.magnitude();\n        const r2m = r2.magnitude();\n        const r3m = r3.magnitude();\n        const d = r1.cross(r2).add(r2.cross(r3).add(r3.cross(r1)));\n        const n = r2.cross(r3).scale(r1m).add(r3.cross(r1).scale(r2m)).add(r1.cross(r2).scale(r3m));\n        const b = d.cross(r2);\n        const s = r1.scale(r2m - r3m).add(r2.scale(r3m - r1m).add(r3.scale(r1m - r2m)));\n        const nm = n.magnitude();\n        const dm = d.magnitude();\n        const vm = Math.sqrt(this.mu / (nm * dm));\n        const vlEci = b.scale((vm / r2m)).add(s.scale(vm));\n        const pv = new J2000(t2, r2, vlEci);\n        const forceModel = new ForceModel().setGravity(this.mu);\n        const orbit = new RungeKutta89Propagator(pv, forceModel);\n        const pv2 = new J2000(t2, r2, vlEci.negate());\n        const orbit2 = new RungeKutta89Propagator(pv2, forceModel);\n        const estP3 = orbit.propagate(t3).position;\n        const dist = estP3.subtract(r3).magnitude();\n        const estP3b = orbit2.propagate(t3).position;\n        const dist2 = estP3b.subtract(r3).magnitude();\n        if (dist <= dist2) {\n            orbit.reset();\n            return orbit.propagate(t2);\n        }\n        orbit2.reset();\n        return orbit2.propagate(t2);\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { ForceModel } from '../force/ForceModel.js';\nimport { Earth, J2000, TAU, Vector3D } from '../main.js';\nimport { RungeKutta89Propagator } from '../propagator/RungeKutta89Propagator.js';\nimport { GibbsIOD } from './GibbsIOD.js';\nimport { LambertIOD } from './LambertIOD.js';\n/**\n * Gooding angles-only initial orbit determination.\n *\n * Used for orbit determination from three optical observations.\n */\nexport class GoodingIOD {\n    _mu;\n    o1_;\n    o2_;\n    o3_;\n    vObserverPosition1_ = Vector3D.origin;\n    vObserverPosition2_ = Vector3D.origin;\n    vObserverPosition3_ = Vector3D.origin;\n    r_ = 0.0;\n    v_ = 0.0;\n    t_ = 0.0;\n    r1_ = 0.0;\n    r2_ = 0.0;\n    r3_ = 0.0;\n    rho1_ = 0.0;\n    rho2_ = 0.0;\n    rho3_ = 0.0;\n    d1_ = 0.0;\n    d3_ = 0.0;\n    facFiniteDiff_ = 0.0;\n    _forceModel = new ForceModel().setGravity(1.0);\n    constructor(o1, o2, o3, mu = Earth.mu) {\n        this._mu = mu;\n        this.o1_ = o1;\n        this.o2_ = o2;\n        this.o3_ = o3;\n    }\n    _getPositionOnLoS2({ e1, r01, e3, r03, t13, t12, nRev, posigrade, }) {\n        const p1 = this.vObserverPosition1_.add(e1.scale(r01));\n        this.r1_ = p1.magnitude();\n        const p3 = this.vObserverPosition3_.add(e3.scale(r03));\n        this.r3_ = p3.magnitude();\n        const p13 = p1.cross(p3);\n        let th = Math.atan2(p13.magnitude(), p1.dot(p3));\n        if (!posigrade) {\n            th = TAU - th;\n        }\n        const v1 = new Float64Array(2);\n        const exitflag = LambertIOD.solve(this.r1_, this.r3_, th, t13, nRev, v1);\n        if (exitflag) {\n            const pn = p1.cross(p3);\n            const pt = pn.cross(p1);\n            let rt = pt.magnitude();\n            if (!posigrade) {\n                rt = -rt;\n            }\n            const vel1 = p1.scale(v1[0] / this.r1_).add(pt.scale(v1[1] / rt));\n            const p2 = new RungeKutta89Propagator(new J2000(this.o1_.epoch, p1, vel1), this._forceModel).propagate(this.o1_.epoch.roll(t12)).position;\n            return p2;\n        }\n        return null;\n    }\n    _modifyIterate(lineOfSight1, lineOfSight3) {\n        const r13 = this.vObserverPosition3_.subtract(this.vObserverPosition1_);\n        this.d1_ = r13.dot(lineOfSight1);\n        this.d3_ = r13.dot(lineOfSight3);\n        const d2 = lineOfSight1.dot(lineOfSight3);\n        const d4 = 1.0 - d2 * d2;\n        this.rho1_ = Math.max((this.d1_ - this.d3_ * d2) / d4, 0.0);\n        this.rho3_ = Math.max((this.d1_ * d2 - this.d3_) / d4, 0.0);\n    }\n    _computeDerivatives({ x, y, lineOfSight1, lineOfSight3, pin, ein, t13, t12, nrev, direction, fd, gd, }) {\n        const p = pin.normalize();\n        const en = ein.normalize();\n        const dx = this.facFiniteDiff_ * x;\n        const dy = this.facFiniteDiff_ * y;\n        const cm1 = this._getPositionOnLoS2({\n            e1: lineOfSight1,\n            r01: x - dx,\n            e3: lineOfSight3,\n            r03: y,\n            t13,\n            t12,\n            nRev: nrev,\n            posigrade: direction,\n        }).subtract(this.vObserverPosition2_);\n        const fm1 = p.dot(cm1);\n        const gm1 = en.dot(cm1);\n        const cp1 = this._getPositionOnLoS2({\n            e1: lineOfSight1,\n            r01: x + dx,\n            e3: lineOfSight3,\n            r03: y,\n            t13,\n            t12,\n            nRev: nrev,\n            posigrade: direction,\n        }).subtract(this.vObserverPosition2_);\n        const fp1 = p.dot(cp1);\n        const gp1 = en.dot(cp1);\n        const fx = (fp1 - fm1) / (2.0 * dx);\n        const gx = (gp1 - gm1) / (2.0 * dx);\n        const cm3 = this._getPositionOnLoS2({\n            e1: lineOfSight1,\n            r01: x,\n            e3: lineOfSight3,\n            r03: y - dy,\n            t13,\n            t12,\n            nRev: nrev,\n            posigrade: direction,\n        }).subtract(this.vObserverPosition2_);\n        const fm3 = p.dot(cm3);\n        const gm3 = en.dot(cm3);\n        const cp3 = this._getPositionOnLoS2({\n            e1: lineOfSight1,\n            r01: x,\n            e3: lineOfSight3,\n            r03: y + dy,\n            t13,\n            t12,\n            nRev: nrev,\n            posigrade: direction,\n        }).subtract(this.vObserverPosition2_);\n        const fp3 = p.dot(cp3);\n        const gp3 = en.dot(cp3);\n        const fy = (fp3 - fm3) / (2.0 * dy);\n        const gy = (gp3 - gm3) / (2.0 * dy);\n        fd[0] = fx;\n        fd[1] = fy;\n        gd[0] = gx;\n        gd[1] = gy;\n    }\n    solve(r1Init, r3Init, nRev = 0, direction = true) {\n        const lineOfSight1 = this.o1_.observation.lineOfSight();\n        const lineOfSight2 = this.o2_.observation.lineOfSight();\n        const lineOfSight3 = this.o3_.observation.lineOfSight();\n        this.r_ = Math.max(r1Init, r3Init);\n        this.v_ = Math.sqrt(this._mu / this.r_);\n        this.t_ = this.r_ / this.v_;\n        this.vObserverPosition1_ = this.o1_.site.position.scale(1.0 / this.r_);\n        this.vObserverPosition2_ = this.o2_.site.position.scale(1.0 / this.r_);\n        this.vObserverPosition3_ = this.o3_.site.position.scale(1.0 / this.r_);\n        const maxiter = 100;\n        this._solveRangeProblem({\n            rho1init: r1Init / this.r_,\n            rho3init: r3Init / this.r_,\n            t13: this.o3_.epoch.difference(this.o1_.epoch) / this.t_,\n            t12: this.o2_.epoch.difference(this.o1_.epoch) / this.t_,\n            nrev: nRev,\n            direction,\n            lineOfSight1,\n            lineOfSight2,\n            lineOfSight3,\n            maxIterations: maxiter,\n        });\n        const gibbs = new GibbsIOD(this._mu);\n        const p1 = this.vObserverPosition1_.add(lineOfSight1.scale(this.rho1_)).scale(this.r_);\n        const p2 = this.vObserverPosition2_.add(lineOfSight2.scale(this.rho2_)).scale(this.r_);\n        const p3 = this.vObserverPosition3_.add(lineOfSight3.scale(this.rho3_)).scale(this.r_);\n        return gibbs.solve(p1, p2, p3, this.o2_.epoch, this.o3_.epoch);\n    }\n    _solveRangeProblem({ rho1init, rho3init, t13, t12, nrev, direction, lineOfSight1, lineOfSight2, lineOfSight3, maxIterations, }) {\n        const arbf = 1e-6;\n        const cvtol = 1e-14;\n        this.rho1_ = rho1init;\n        this.rho3_ = rho3init;\n        let iter = 0;\n        let stoppingCriterion = 10.0 * cvtol;\n        while (iter < maxIterations && Math.abs(stoppingCriterion) > cvtol) {\n            this.facFiniteDiff_ = arbf;\n            const p2 = this._getPositionOnLoS2({\n                e1: lineOfSight1,\n                r01: this.rho1_,\n                e3: lineOfSight3,\n                r03: this.rho3_,\n                t13,\n                t12,\n                nRev: nrev,\n                posigrade: direction,\n            });\n            if (p2 === null) {\n                this._modifyIterate(lineOfSight1, lineOfSight3);\n            }\n            else {\n                this.r2_ = p2.magnitude();\n                const c = p2.subtract(this.vObserverPosition2_);\n                this.rho2_ = c.magnitude();\n                const cr = lineOfSight2.dot(c);\n                const u = lineOfSight2.cross(c);\n                const p = u.cross(lineOfSight2).normalize();\n                const ent = lineOfSight2.cross(p);\n                const enr = ent.magnitude();\n                if (enr === 0.0) {\n                    return;\n                }\n                const en = ent.normalize();\n                const fc = p.dot(c);\n                const fd = new Float64Array(2);\n                const gd = new Float64Array(2);\n                this._computeDerivatives({\n                    x: this.rho1_,\n                    y: this.rho3_,\n                    lineOfSight1,\n                    lineOfSight3,\n                    pin: p,\n                    ein: en,\n                    t13,\n                    t12,\n                    nrev,\n                    direction,\n                    fd,\n                    gd,\n                });\n                const fr1 = fd[0];\n                const fr3 = fd[1];\n                const gr1 = gd[0];\n                const gr3 = gd[1];\n                const detj = fr1 * gr3 - fr3 * gr1;\n                this.d3_ = (-gr3 * fc) / detj;\n                this.d1_ = (gr1 * fc) / detj;\n                this.rho1_ = this.rho1_ + this.d3_;\n                this.rho3_ = this.rho3_ + this.d1_;\n                const den = Math.max(cr, this.r2_);\n                stoppingCriterion = fc / den;\n            }\n            ++iter;\n        }\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { Earth, J2000 } from '../main.js';\n/**\n * Herrik-Gibbs 3-position initial orbit determination.\n *\n * Possibly better than regular Gibbs IOD for closely spaced position\n * vectors (less than 5Â°).\n */\nexport class HerrickGibbsIOD {\n    mu;\n    /**\n     * Create a new [HerrickGibbsIOD] object with optional\n     * gravitational parameter [mu].\n     * @param mu Gravitational parameter (default: Earth.mu)\n     */\n    constructor(mu = Earth.mu) {\n        this.mu = mu;\n        // Nothing to do here.\n    }\n    // / Attempt to create a state estimate from three inertial position vectors.\n    solve(r1, t1, r2, t2, r3, t3) {\n        const dt31 = t3.difference(t1);\n        const dt32 = t3.difference(t2);\n        const dt21 = t2.difference(t1);\n        const r1m = r1.magnitude();\n        const r2m = r2.magnitude();\n        const r3m = r3.magnitude();\n        const vA = r1.scale(-dt32 * (1.0 / (dt21 * dt31) + this.mu / (12.0 * r1m * r1m * r1m)));\n        const vB = r2.scale((dt32 - dt21) * (1.0 / (dt21 * dt32) + this.mu / (12.0 * r2m * r2m * r2m)));\n        const vC = r3.scale(dt21 * (1.0 / (dt32 * dt31) + this.mu / (12.0 * r3m * r3m * r3m)));\n        const v2 = vA.add(vB).add(vC);\n        return new J2000(t2, r2, v2);\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { Earth, J2000 } from '../main.js';\n// / Lambert two-position and time initial orbit determination.\nexport class LambertIOD {\n    mu;\n    constructor(mu = Earth.mu) {\n        this.mu = mu;\n        // Nothing to do here.\n    }\n    /**\n     * Try to guess the short path argument given an [interceptor] and\n     * [target] state.\n     * @param interceptor Interceptor\n     * @param target Target\n     * @returns True if the short path should be used, false otherwise.\n     */\n    static useShortPath(interceptor, target) {\n        const transN = interceptor.position.cross(target.position);\n        const h = interceptor.position.cross(interceptor.velocity);\n        return h.dot(transN) >= 0;\n    }\n    static timeOfFlight_(x, longway, mrev, minSma, speri, chord) {\n        const a = minSma / (1.0 - x * x);\n        let tof;\n        if (Math.abs(x) < 1) {\n            const beta = longway * 2.0 * Math.asin(Math.sqrt((speri - chord) / (2.0 * a)));\n            const alpha = 2.0 * Math.acos(x);\n            tof = a * Math.sqrt(a) * (alpha - Math.sin(alpha) - (beta - Math.sin(beta)) + 2.0 * Math.PI * mrev);\n        }\n        else {\n            const alpha = 2.0 * Math.acosh(x);\n            const beta = longway * 2.0 * Math.asinh(Math.sqrt((speri - chord) / (-2.0 * a)));\n            tof = -a * Math.sqrt(-a) * (Math.sinh(alpha) - alpha - (Math.sinh(beta) - beta));\n        }\n        return tof;\n    }\n    /**\n     * Attempt to solve output velocity [v1] _(km/s)_ given radii [r1] and\n     * [r2] _(canonical)_, sweep angle [dth] _(rad)_, time of flight [tau]\n     * _(canonical)_, and number of revolutions _(mRev)_.\n     * @param r1 Radius 1\n     * @param r2 Radius 2\n     * @param dth Sweep angle\n     * @param tau Time of flight\n     * @param mRev Number of revolutions\n     * @param v1 Output velocity\n     * @returns True if successful, false otherwise.\n     */\n    static solve(r1, r2, dth, tau, mRev, v1) {\n        const leftBranch = dth < Math.PI;\n        let longway = 1;\n        if (dth > Math.PI) {\n            longway = -1;\n        }\n        const m = Math.abs(mRev);\n        const rtof = Math.abs(tau);\n        const theta = dth;\n        const chord = Math.sqrt(r1 * r1 + r2 * r2 - 2.0 * r1 * r2 * Math.cos(theta));\n        const speri = 0.5 * (r1 + r2 + chord);\n        const minSma = 0.5 * speri;\n        const lambda = longway * Math.sqrt(1.0 - chord / speri);\n        const logt = Math.log(rtof);\n        let in1;\n        let in2;\n        let x1;\n        let x2;\n        if (m === 0) {\n            in1 = -0.6523333;\n            in2 = 0.6523333;\n            x1 = Math.log(1.0 + in1);\n            x2 = Math.log(1.0 + in2);\n        }\n        else {\n            if (!leftBranch) {\n                in1 = -0.523334;\n                in2 = -0.223334;\n            }\n            else {\n                in1 = 0.723334;\n                in2 = 0.523334;\n            }\n            x1 = Math.tan((in1 * Math.PI) / 2);\n            x2 = Math.tan((in2 * Math.PI) / 2);\n        }\n        const tof1 = LambertIOD.timeOfFlight_(in1, longway, m, minSma, speri, chord);\n        const tof2 = LambertIOD.timeOfFlight_(in2, longway, m, minSma, speri, chord);\n        let y1;\n        let y2;\n        if (m === 0) {\n            y1 = Math.log(tof1) - logt;\n            y2 = Math.log(tof2) - logt;\n        }\n        else {\n            y1 = tof1 - rtof;\n            y2 = tof2 - rtof;\n        }\n        let err = 1e20;\n        let iterations = 0;\n        const tol = 1e-13;\n        const maxiter = 50;\n        let xnew = 0.0;\n        while (err > tol && iterations < maxiter) {\n            xnew = (x1 * y2 - y1 * x2) / (y2 - y1);\n            let xt;\n            if (m === 0) {\n                xt = Math.exp(xnew) - 1.0;\n            }\n            else {\n                xt = (Math.atan(xnew) * 2.0) / Math.PI;\n            }\n            const tof = LambertIOD.timeOfFlight_(xt, longway, m, minSma, speri, chord);\n            let ynew;\n            if (m === 0) {\n                ynew = Math.log(tof) - logt;\n            }\n            else {\n                ynew = tof - rtof;\n            }\n            x1 = x2;\n            x2 = xnew;\n            y1 = y2;\n            y2 = ynew;\n            err = Math.abs(x1 - xnew);\n            ++iterations;\n        }\n        if (err > tol) {\n            return false;\n        }\n        let x;\n        if (m === 0) {\n            x = Math.exp(xnew) - 1.0;\n        }\n        else {\n            x = (Math.atan(xnew) * 2.0) / Math.PI;\n        }\n        const sma = minSma / (1.0 - x * x);\n        let eta;\n        if (x < 1) {\n            const alfa = 2.0 * Math.acos(x);\n            const beta = longway * 2.0 * Math.asin(Math.sqrt((speri - chord) / (2.0 * sma)));\n            const psi = (alfa - beta) / 2.0;\n            const sinPsi = Math.sin(psi);\n            const etaSq = (2.0 * sma * sinPsi * sinPsi) / speri;\n            eta = Math.sqrt(etaSq);\n        }\n        else {\n            const gamma = 2.0 * Math.acosh(x);\n            const delta = longway * 2.0 * Math.asinh(Math.sqrt((chord - speri) / (2.0 * sma)));\n            const psi = (gamma - delta) / 2.0;\n            const sinhPsi = Math.sinh(psi);\n            const etaSq = (-2.0 * sma * sinhPsi * sinhPsi) / speri;\n            eta = Math.sqrt(etaSq);\n        }\n        const vr1 = (1.0 / eta) * Math.sqrt(1.0 / minSma) * ((2.0 * lambda * minSma) / r1 - (lambda + x * eta));\n        const vt1 = (1.0 / eta) * Math.sqrt(1.0 / minSma) * Math.sqrt(r2 / r1) * Math.sin(dth / 2.0);\n        v1[0] = vr1;\n        v1[1] = vt1;\n        return true;\n    }\n    /**\n     * Estimate a state vector for inertial position [p1] _(km)_ given the\n     * two epoch and positions.\n     * @param p1 Position vector 1\n     * @param p2 Position vector 2\n     * @param t1 Epoch 1\n     * @param t2 Epoch 2\n     * @param root0 Optional parameters\n     * @param root0.posigrade If true, use the positive root (default: true)\n     * @param root0.nRev Number of revolutions (default: 0)\n     * @returns A [J2000] object with the estimated state vector.\n     */\n    estimate(p1, p2, t1, t2, { posigrade = true, nRev = 0 } = {}) {\n        const r1 = p1.magnitude();\n        const r2 = p2.magnitude();\n        const tof = t2.difference(t1);\n        const r = Math.max(r1, r2);\n        const v = Math.sqrt(this.mu / r);\n        const t = r / v;\n        let dth = p1.angle(p2);\n        if (!posigrade) {\n            dth = 2 * Math.PI - dth;\n        }\n        const vDep = new Float64Array(2);\n        const exitFlag = LambertIOD.solve(r1 / r, r2 / r, dth, tof / t, nRev, vDep);\n        if (exitFlag) {\n            const pn = p1.cross(p2);\n            const pt = pn.cross(p1);\n            let rt = pt.magnitude();\n            if (!posigrade) {\n                rt = -rt;\n            }\n            const vel1 = p1.scale((v * vDep[0]) / r1).add(pt.scale((v * vDep[1]) / rt));\n            return new J2000(t1, p1, vel1);\n        }\n        return null;\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { ForceModel } from '../force/ForceModel.js';\nimport { Earth, J2000, RadecTopocentric, Vector3D } from '../main.js';\nimport { RungeKutta89Propagator } from '../propagator/RungeKutta89Propagator.js';\nimport { DownhillSimplex } from './../optimize/DownhillSimplex.js';\nimport { GoodingIOD } from './GoodingIOD.js';\n/**\n * Gooding angles-only initial orbit determination.\n *\n * Used for orbit determination from multiple optical observations.\n */\nexport class ModifiedGoodingIOD {\n    observations_;\n    mu_;\n    constructor(observations, mu = Earth.mu) {\n        this.observations_ = observations;\n        this.mu_ = mu;\n    }\n    createInitial_(r0, rN, nRev, direction) {\n        const iod = new GoodingIOD(this.observations_[0], this.observations_[Math.floor(this.observations_.length / 2)], this.observations_[this.observations_.length - 1], this.mu_);\n        return iod.solve(r0, rN, nRev, direction);\n    }\n    _createErrorFunction(aprioriEpoch) {\n        const forceModel = new ForceModel().setGravity(this.mu_);\n        const scoreFn = (x) => {\n            const position = new Vector3D(x[0], x[1], x[2]);\n            const velocity = new Vector3D(x[3], x[4], x[5]);\n            const state = new J2000(aprioriEpoch, position, velocity);\n            const propagator = new RungeKutta89Propagator(state, forceModel);\n            let total = 0;\n            for (const oC of this.observations_) {\n                const sC = propagator.propagate(oC.epoch);\n                const pC = oC.site;\n                const expected = oC.observation.lineOfSight();\n                const actual = RadecTopocentric.fromStateVector(sC, pC).lineOfSight();\n                const error = expected.angle(actual);\n                total += error;\n            }\n            return total;\n        };\n        return scoreFn;\n    }\n    solve(r0, rN, { nRev = 0, direction = true, posSearch = 10.0, velSearch = 0.1, tolerance = 1e-6, printIter = false, }) {\n        if (this.observations_.length < 3) {\n            throw new Error('At least 3 observations required for Gooding IOD.');\n        }\n        const init = this.createInitial_(r0, rN, nRev, direction);\n        const guess = Float64Array.from([...init.position.toArray(), ...init.velocity.toArray()]);\n        const solveFn = this._createErrorFunction(init.epoch);\n        const simplex = [\n            Float64Array.from(guess),\n            Float64Array.from([guess[0] + posSearch, guess[1], guess[2], guess[3], guess[4], guess[5]]),\n            Float64Array.from([guess[0], guess[1] + posSearch, guess[2], guess[3], guess[4], guess[5]]),\n            Float64Array.from([guess[0], guess[1], guess[2] + posSearch, guess[3], guess[4], guess[5]]),\n            Float64Array.from([guess[0], guess[1], guess[2], guess[3] + velSearch, guess[4], guess[5]]),\n            Float64Array.from([guess[0], guess[1], guess[2], guess[3], guess[4] + velSearch, guess[5]]),\n            Float64Array.from([guess[0], guess[1], guess[2], guess[3], guess[4], guess[5] + velSearch]),\n        ];\n        const result = DownhillSimplex.solveSimplex(solveFn, simplex, {\n            adaptive: true,\n            xTolerance: tolerance,\n            fTolerance: tolerance,\n            printIter,\n        });\n        return new J2000(init.epoch, new Vector3D(result[0], result[1], result[2]), new Vector3D(result[3], result[4], result[5]));\n    }\n}\n","export { BatchLeastSquaresOD } from './BatchLeastSquaresOD.js';\nexport { BatchLeastSquaresResult } from './BatchLeastSquaresResult.js';\nexport { GibbsIOD } from './GibbsIOD.js';\nexport { GoodingIOD } from './GoodingIOD.js';\nexport { HerrickGibbsIOD } from './HerrickGibbsIOD.js';\nexport { LambertIOD } from './LambertIOD.js';\nexport { ModifiedGoodingIOD } from './ModifiedGoodingIOD.js';\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { VerletBlendInterpolator } from '../interpolator/VerletBlendInterpolator.js';\nimport { J2000 } from '../main.js';\nimport { Propagator } from './Propagator.js';\n// / Kepler analytical two-body propagator.\nexport class KeplerPropagator extends Propagator {\n    initElements_;\n    elements_;\n    cacheState_;\n    checkpoints_;\n    constructor(initElements) {\n        super();\n        this.initElements_ = initElements;\n        this.elements_ = initElements;\n        this.cacheState_ = J2000.fromClassicalElements(initElements);\n        this.checkpoints_ = [];\n    }\n    get state() {\n        return this.cacheState_;\n    }\n    propagate(epoch) {\n        this.cacheState_ = J2000.fromClassicalElements(this.elements_.propagate(epoch));\n        return this.cacheState_;\n    }\n    reset() {\n        this.elements_ = this.initElements_;\n        this.cacheState_ = J2000.fromClassicalElements(this.elements_);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    maneuver(maneuver, interval = 60) {\n        this.cacheState_ = maneuver.apply(this.propagate(maneuver.center));\n        this.elements_ = this.cacheState_.toClassicalElements();\n        return [this.cacheState_];\n    }\n    ephemerisManeuver(start, finish, maneuvers, interval = 60.0) {\n        const tMvr = maneuvers.slice(0).filter((mvr) => mvr.center >= start || mvr.center <= finish);\n        const ephemeris = [];\n        if (tMvr[0].start > start) {\n            ephemeris.push(this.propagate(start));\n        }\n        for (const mvr of tMvr) {\n            while (this.cacheState_.epoch < mvr.center) {\n                const step = Math.min(mvr.center.difference(this.cacheState_.epoch), interval);\n                this.propagate(this.cacheState_.epoch.roll(step));\n                if (this.cacheState_.epoch.posix !== mvr.center.posix) {\n                    ephemeris.push(this.cacheState_);\n                }\n            }\n            ephemeris.push(...this.maneuver(mvr, interval));\n        }\n        while (this.cacheState_.epoch < finish) {\n            const step = Math.min(finish.difference(this.cacheState_.epoch), interval);\n            this.propagate(this.cacheState_.epoch.roll(step));\n            ephemeris.push(this.cacheState_);\n        }\n        return new VerletBlendInterpolator(ephemeris);\n    }\n    checkpoint() {\n        this.checkpoints_.push(this.cacheState_);\n        return this.checkpoints_.length - 1;\n    }\n    clearCheckpoints() {\n        this.checkpoints_ = [];\n    }\n    restore(index) {\n        this.cacheState_ = this.checkpoints_[index];\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { VerletBlendInterpolator } from '../interpolator/VerletBlendInterpolator.js';\nimport { EpochUTC } from '../main.js';\nimport { GoldenSection } from './../optimize/GoldenSection.js';\n// Propagator base class.\nexport class Propagator {\n    /*\n     * Generate a [VerletBlendInterpolator] containing ephemeris over the\n     * [start] and [stop] propagation period, with an optional\n     * ephemeris [interval].\n     */\n    ephemeris(start, stop, interval = 60.0) {\n        const output = [this.propagate(start)];\n        let tempEpoch = start;\n        while (tempEpoch <= stop) {\n            tempEpoch = tempEpoch.roll(interval);\n            output.push(this.propagate(tempEpoch));\n        }\n        return new VerletBlendInterpolator(output);\n    }\n    /*\n     * Generate a list of [J2000] states integrating over a maneuver.\n     *\n     * If the maneuver is impulsive, the list will only contain a single state.\n     */\n    maneuver(maneuver, interval = 60.0) {\n        const output = [];\n        const tempEpoch = maneuver.start;\n        const stop = maneuver.stop;\n        output.push(this.propagate(tempEpoch));\n        let current = tempEpoch;\n        while (current <= stop) {\n            current = current.roll(interval);\n            output.push(this.propagate(current));\n        }\n        return output;\n    }\n    /*\n     * Generate a [VerletBlendInterpolator] containing maneuver ephemeris over\n     * the [start] and [finish] interval, with an optional ephemeris [interval].\n     */\n    ephemerisManeuver(start, finish, maneuvers, interval = 60.0) {\n        const output = [];\n        const tempEpoch = start;\n        output.push(this.propagate(tempEpoch));\n        const stop = finish;\n        let current = tempEpoch;\n        while (current <= stop) {\n            current = current.roll(interval);\n            output.push(this.propagate(current));\n        }\n        return new VerletBlendInterpolator(output);\n    }\n    // Return the epoch of the ascending node after the [start] epoch.\n    ascendingNodeEpoch(start) {\n        const period = this.state.period / 60;\n        const step = period / 8;\n        let current = start;\n        const stop = current.roll(period);\n        this.propagate(current);\n        let previous = this.state.position.z;\n        while (current <= stop) {\n            current = current.roll(step);\n            this.propagate(current);\n            if (Math.sign(this.state.position.z) === Math.sign(-previous) && this.state.velocity.z > 0) {\n                break;\n            }\n            previous = this.state.position.z;\n        }\n        const t = GoldenSection.search((x) => {\n            this.propagate(new EpochUTC(x));\n            return Math.abs(this.state.position.z);\n        }, current.posix - step, current.posix, { tolerance: 1e-3 });\n        return new EpochUTC(t);\n    }\n    // Return the epoch of the descending node after the [start] epoch.\n    descendingNodeEpoch(start) {\n        const period = this.state.period / 60;\n        const step = period / 8;\n        let current = start;\n        const stop = current.roll(period);\n        this.propagate(current);\n        let previous = this.state.position.z;\n        while (current <= stop) {\n            current = current.roll(step);\n            this.propagate(current);\n            if (Math.sign(this.state.position.z) === Math.sign(-previous) && this.state.velocity.z < 0) {\n                break;\n            }\n            previous = this.state.position.z;\n        }\n        const t = GoldenSection.search((x) => {\n            this.propagate(new EpochUTC(x));\n            return Math.abs(this.state.position.z);\n        }, current.posix - step, current.posix, { tolerance: 1e-3 });\n        return new EpochUTC(t);\n    }\n    // Return the epoch of apogee after the [start] epoch.\n    apogeeEpoch(start) {\n        const slice = 8;\n        const period = this.state.period / 60;\n        const step = period / slice;\n        let current = start;\n        this.propagate(current);\n        let tCache = current;\n        let rCache = this.state.position.magnitude();\n        for (let i = 0; i < slice; i++) {\n            current = current.roll(step);\n            const t = new EpochUTC(GoldenSection.search((x) => {\n                this.propagate(new EpochUTC(x));\n                return this.state.position.magnitude();\n            }, current.posix - step, current.posix, { tolerance: 1e-3, solveMax: true }));\n            this.propagate(t);\n            const r = this.state.position.magnitude();\n            if (r > rCache) {\n                tCache = t;\n                rCache = r;\n            }\n        }\n        return tCache;\n    }\n    // Return the epoch of perigee after the [start] epoch.\n    perigeeEpoch(start) {\n        const slice = 8;\n        const period = this.state.period / 60;\n        const step = period / slice;\n        let current = start;\n        this.propagate(current);\n        let tCache = current;\n        let rCache = this.state.position.magnitude();\n        for (let i = 0; i < slice; i++) {\n            current = current.roll(step);\n            const t = new EpochUTC(GoldenSection.search((x) => {\n                this.propagate(new EpochUTC(x));\n                return this.state.position.magnitude();\n            }, current.posix - step, current.posix, { tolerance: 1e-3, solveMax: false }));\n            this.propagate(t);\n            const r = this.state.position.magnitude();\n            if (r < rCache) {\n                tCache = t;\n                rCache = r;\n            }\n        }\n        return tCache;\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\n// / Runge-Kutta adaptive state checkpoint.\nexport class RkCheckpoint {\n    cacheState;\n    stepSize;\n    constructor(cacheState, stepSize) {\n        this.cacheState = cacheState;\n        this.stepSize = stepSize;\n        // Nothing to do here.\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\n// / Result of adaptive numerical integration.\nexport class RkResult {\n    state;\n    error;\n    newStep;\n    // / Create a new [RkResult] object.\n    constructor(state, error, newStep) {\n        this.state = state;\n        this.error = error;\n        this.newStep = newStep;\n        // Nothing to do here.\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { ForceModel } from '../force/ForceModel.js';\nimport { VerletBlendInterpolator } from '../interpolator/VerletBlendInterpolator.js';\nimport { J2000, Vector } from '../main.js';\nimport { Propagator } from './Propagator.js';\n// / Runge-Kutta 4 fixed numerical propagator.\nexport class RungeKutta4Propagator extends Propagator {\n    initState_;\n    forceModel_;\n    stepSize_;\n    cacheState_;\n    checkpoints_;\n    /**\n     * Create a new [RungeKutta4Propagator] object from an initial state vector and\n     * along with an optional [ForceModel] and [stepSize] in seconds.\n     * @param initState_ Initial state vector.\n     * @param forceModel_ Numerical integration force model.\n     * @param stepSize_ Integration step size _(seconds)_.\n     * @param cacheState_ Cached state vector.\n     * @param checkpoints_ Cached state vector checkpoints.\n     */\n    constructor(initState_, forceModel_ = new ForceModel().setGravity(), stepSize_ = 15.0, cacheState_ = initState_, checkpoints_ = []) {\n        super();\n        this.initState_ = initState_;\n        this.forceModel_ = forceModel_;\n        this.stepSize_ = stepSize_;\n        this.cacheState_ = cacheState_;\n        this.checkpoints_ = checkpoints_;\n        this.stepSize_ = Math.abs(stepSize_);\n    }\n    // / Set the integrator step size to the provided number of [seconds].\n    setStepSize(seconds) {\n        this.stepSize_ = Math.abs(seconds);\n    }\n    // / Set numerical integration force model.\n    setForceModel(forceModel) {\n        this.forceModel_ = forceModel;\n    }\n    ephemerisManeuver(start, finish, maneuvers, interval = 60.0) {\n        const tMvr = maneuvers.slice(0).filter((mvr) => mvr.start >= start || mvr.stop <= finish);\n        const ephemeris = [];\n        if (tMvr[0].start > start) {\n            ephemeris.push(this.propagate(start));\n        }\n        for (const mvr of tMvr) {\n            while (this.cacheState_.epoch < mvr.start) {\n                const step = Math.min(mvr.start.difference(this.cacheState_.epoch), interval);\n                this.propagate(this.cacheState_.epoch.roll(step));\n                if (this.cacheState_.epoch.posix !== mvr.start.posix) {\n                    ephemeris.push(this.cacheState_);\n                }\n            }\n            ephemeris.push(...this.maneuver(mvr, interval));\n        }\n        while (this.cacheState_.epoch.posix < finish.posix) {\n            const step = Math.min(finish.difference(this.cacheState_.epoch), interval);\n            this.propagate(this.cacheState_.epoch.roll(step));\n            ephemeris.push(this.cacheState_);\n        }\n        return new VerletBlendInterpolator(ephemeris);\n    }\n    maneuver(maneuver, interval = 60.0) {\n        if (maneuver.isImpulsive) {\n            this.cacheState_ = maneuver.apply(this.propagate(maneuver.center));\n            return [this.cacheState_];\n        }\n        let tState = this.propagate(maneuver.start);\n        this.forceModel_.loadManeuver(maneuver);\n        const ephemeris = [tState];\n        while (tState.epoch < maneuver.stop) {\n            const step = Math.min(maneuver.stop.difference(tState.epoch), interval);\n            tState = this.propagate(tState.epoch.roll(step));\n            ephemeris.push(tState);\n        }\n        this.forceModel_.clearManeuver();\n        return ephemeris;\n    }\n    _kFn(state, hArg, kArg) {\n        const epoch = state.epoch.roll(hArg);\n        const posvel = state.position.join(state.velocity);\n        const result = posvel.add(kArg);\n        const sample = new J2000(epoch, result.toVector3D(0), result.toVector3D(3));\n        return this.forceModel_.derivative(sample);\n    }\n    _integrate(state, step) {\n        const k1 = this._kFn(state, 0, Vector.zero(6)).scale(step);\n        const k2 = this._kFn(state, 0.5 * step, k1.scale(0.5)).scale(step);\n        const k3 = this._kFn(state, 0.5 * step, k2.scale(0.5)).scale(step);\n        const k4 = this._kFn(state, step, k3).scale(step);\n        const v1 = k1;\n        const v2 = v1.add(k2.scale(2));\n        const v3 = v2.add(k3.scale(2));\n        const v4 = v3.add(k4);\n        const tNext = state.epoch.roll(step);\n        const posvel = state.position.join(state.velocity);\n        const result = posvel.add(v4.scale(1 / 6));\n        return new J2000(tNext, result.toVector3D(0), result.toVector3D(3));\n    }\n    propagate(epoch) {\n        let delta = epoch.difference(this.cacheState_.epoch);\n        while (delta !== 0) {\n            const direction = delta >= 0 ? 1 : -1;\n            const dt = Math.min(Math.abs(delta), this.stepSize_) * direction;\n            this.cacheState_ = this._integrate(this.cacheState_, dt);\n            delta = epoch.difference(this.cacheState_.epoch);\n        }\n        return this.cacheState_;\n    }\n    reset() {\n        this.cacheState_ = this.initState_;\n    }\n    get state() {\n        return this.cacheState_;\n    }\n    checkpoint() {\n        this.checkpoints_.push(this.cacheState_);\n        return this.checkpoints_.length - 1;\n    }\n    clearCheckpoints() {\n        this.checkpoints_ = [];\n    }\n    restore(index) {\n        this.cacheState_ = this.checkpoints_[index];\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\n/* eslint-disable @typescript-eslint/no-loss-of-precision */\n/* eslint-disable class-methods-use-this */\nimport { RungeKuttaAdaptive } from './RungeKuttaAdaptive.js';\n// / Runge-Kutta 8(9) adaptive numerical propagator.\nexport class RungeKutta89Propagator extends RungeKuttaAdaptive {\n    a_ = Float64Array.from([\n        0.0, 0.3462e-1, 0.9702435063878044594828361677100617517633e-1, 0.1455365259581706689224254251565092627645, 0.561,\n        0.2290079115904850126662751771814700052182, 0.5449920884095149873337248228185299947818, 0.645, 0.48375, 0.6757e-1,\n        0.25, 0.6590650618730998549405331618649220295334, 0.8206, 0.9012, 1.0, 1.0,\n    ]);\n    b_ = [\n        new Float64Array(0),\n        Float64Array.from([0.3462e-1]),\n        Float64Array.from([-0.389335438857287327017042687229284478532e-1, 0.1359578945245091786499878854939346230295]),\n        Float64Array.from([0.3638413148954266723060635628912731569111e-1, 0.0, 0.1091523944686280016918190688673819470733]),\n        Float64Array.from([\n            2.025763914393969636805657604282571047511, 0.0, -7.638023836496292020387602153091964592952,\n            6.173259922102322383581944548809393545442,\n        ]),\n        Float64Array.from([\n            0.5112275589406060872792270881648288397197e-1, 0.0, 0.0, 0.1770823794555021537929910813839068684087,\n            0.80277624092225014536138698108025283759e-3,\n        ]),\n        Float64Array.from([\n            0.1316006357975216279279871693164256985334, 0.0, 0.0, -0.2957276252669636417685183174672273730699,\n            0.878137803564295237421124704053886667082e-1, 0.62130529752252747743214350056394300261,\n        ]),\n        Float64Array.from([\n            0.7166666666666666666666666666666666666667e-1, 0.0, 0.0, 0.0, 0.0, 0.3305533578915319409260346730051472207728,\n            0.2427799754418013924072986603281861125606,\n        ]),\n        Float64Array.from([\n            0.71806640625e-1, 0.0, 0.0, 0.0, 0.0, 0.3294380283228177160744825466257672816401,\n            0.1165190029271822839255174533742327183599, -0.34013671875e-1,\n        ]),\n        Float64Array.from([\n            0.4836757646340646986611287718844085773549e-1, 0.0, 0.0, 0.0, 0.0, 0.3928989925676163974333190042057047002852e-1,\n            0.1054740945890344608263649267140088017604, -0.2143865284648312665982642293830533996214e-1,\n            -0.1041229174627194437759832813847147895623,\n        ]),\n        Float64Array.from([\n            -0.2664561487201478635337289243849737340534e-1, 0.0, 0.0, 0.0, 0.0, 0.3333333333333333333333333333333333333333e-1,\n            -0.1631072244872467239162704487554706387141, 0.3396081684127761199487954930015522928244e-1,\n            0.1572319413814626097110769806810024118077, 0.215226747803187955230353477879477037696,\n        ]),\n        Float64Array.from([\n            0.3689009248708622334786359863227633989718e-1, 0.0, 0.0, 0.0, 0.0, -0.1465181576725542928653609891758501156785,\n            0.2242577768172024345345469822625833796001, 0.2294405717066072637090897902753790803034e-1,\n            -0.35850052905728761357394424889330334334e-2, 0.8669223316444385506869203619044453906053e-1,\n            0.4383840651968337846196219974168630120572,\n        ]),\n        Float64Array.from([\n            -0.4866012215113340846662212357570395295088, 0.0, 0.0, 0.0, 0.0, -6.304602650282852990657772792012007122988,\n            -0.281245618289472564778284183790118418111, -2.679019236219849057687906597489223155566,\n            0.518815663924157511565311164615012522024, 1.365353187603341710683633635235238678626,\n            5.885091088503946585721274891680604830712, 2.802808786272062889819965117517532194812,\n        ]),\n        Float64Array.from([\n            0.4185367457753471441471025246471931649633, 0.0, 0.0, 0.0, 0.0, 6.724547581906459363100870806514855026676,\n            -0.425444280164611790606983409697113064616, 3.343279153001265577811816947557982637749,\n            0.617081663117537759528421117507709784737, -0.929966123939932833937749523988800852013,\n            -6.099948804751010722472962837945508844846, -3.002206187889399044804158084895173690015,\n            0.2553202529443445472336424602988558373637,\n        ]),\n        Float64Array.from([\n            -0.779374086122884664644623040843840506343, 0.0, 0.0, 0.0, 0.0, -13.93734253810777678786523664804936051203,\n            1.252048853379357320949735183924200895136, -14.69150040801686878191527989293072091588,\n            -0.494705058533141685655191992136962873577, 2.242974909146236657906984549543692874755,\n            13.36789380382864375813864978592679139881, 14.39665048665068644512236935340272139005,\n            -0.7975813331776800379127866056663258667437, 0.4409353709534277758753793068298041158235,\n        ]),\n        Float64Array.from([\n            2.058051337466886442151242368989994043993, 0.0, 0.0, 0.0, 0.0, 22.35793772796803295519317565842520212899,\n            0.90949810997556332745009198137971890783, 35.89110098240264104710550686568482456493,\n            -3.442515027624453437985000403608480262211, -4.865481358036368826566013387928704014496,\n            -18.90980381354342625688427480879773032857, -34.26354448030451782929251177395134170515,\n            1.264756521695642578827783499806516664686, 0.0, 0.0,\n        ]),\n    ];\n    ch_ = Float64Array.from([\n        0.1996996514886773085518508418098868756464e-1, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n        2.191499304949330054530747099310837524864, 0.8857071848208438030833722031786358862953e-1,\n        0.1140560234865965622484956605091432032674, 0.2533163805345107065564577734569651977347,\n        -2.056564386240941011158999594595981300493, 0.340809679901311993516009489422454381283, 0.0, 0.0,\n        0.4834231373823958314376726739772871714902e-1,\n    ]);\n    c_ = Float64Array.from([\n        0.1461197685842315252051541915018784713459e-1, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n        -0.391521186233133908941022826728824203081, 0.2310932500289506415909675644868993669908,\n        0.1274766769992852382560589467488989175618, 0.2246434176204157731566981937082069688984,\n        0.5684352689748512932705226972873692126743, 0.5825871557215827200814768021863420902155e-1,\n        0.1364317403482215641609022744494239843327, 0.3057013983082797397721005067920369646664e-1, 0.0,\n    ]);\n    get a() {\n        return this.a_;\n    }\n    get b() {\n        return this.b_;\n    }\n    get ch() {\n        return this.ch_;\n    }\n    get c() {\n        return this.c_;\n    }\n    get order() {\n        return 8;\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { ForceModel } from '../force/ForceModel.js';\nimport { J2000, Vector } from '../main.js';\nimport { VerletBlendInterpolator } from './../interpolator/VerletBlendInterpolator.js';\nimport { Propagator } from './Propagator.js';\nimport { RkCheckpoint } from './RkCheckpoint.js';\nimport { RkResult } from './RkResult.js';\n// / Adaptive Runge-Kutta propagator base class.\nexport class RungeKuttaAdaptive extends Propagator {\n    initState_;\n    forceModel_;\n    tolerance_;\n    /**\n     * Create a new [RungeKuttaAdaptive] object from an initial state vector\n     * along with an optional [ForceModel] and [tolerance].\n     * @param initState_ Initial state vector.\n     * @param forceModel_ Numerical integration force model.\n     * @param tolerance_ Minimum allowable local error tolerance.\n     */\n    constructor(initState_, forceModel_ = new ForceModel().setGravity(), tolerance_ = 1e-9) {\n        super();\n        this.initState_ = initState_;\n        this.forceModel_ = forceModel_;\n        this.tolerance_ = tolerance_;\n        this._cacheState = this.initState_;\n        this.tolerance_ = Math.max(RungeKuttaAdaptive._minTolerance, Math.abs(tolerance_));\n    }\n    // / Initial state vector.\n    _cacheState;\n    _checkpoints = [];\n    // / Integration step size _(seconds)_.\n    _stepSize = 60.0;\n    // / Minimum allowable local error tolerance.\n    static _minTolerance = 1e-15;\n    get state() {\n        return this._cacheState;\n    }\n    reset() {\n        this._cacheState = this.initState_;\n        this._stepSize = 60.0;\n    }\n    // / Set numerical integration force model.\n    setForceModel(forceModel) {\n        this.forceModel_ = forceModel;\n    }\n    kfn_(epoch, rv, hArg, kArg, step) {\n        const t = epoch.roll(hArg * step);\n        const rvNew = rv.add(kArg);\n        const sample = new J2000(t, rvNew.toVector3D(0), rvNew.toVector3D(3));\n        return this.forceModel_.derivative(sample).scale(step);\n    }\n    integrate_(state, step) {\n        const k = new Array(this.a.length).fill(Vector.origin3);\n        const y = state.position.join(state.velocity);\n        for (let i = 0; i < this.a.length; i++) {\n            let kArg = Vector.origin6;\n            if (i !== 0) {\n                for (let j = 0; j < i; j++) {\n                    kArg = kArg.add(k[j].scale(this.b[i][j]));\n                }\n            }\n            k[i] = this.kfn_(state.epoch, y, this.a[i], kArg, step);\n        }\n        let y1 = y;\n        let y2 = y;\n        for (let i = 0; i < k.length; i++) {\n            y1 = y1.add(k[i].scale(this.ch[i]));\n            y2 = y2.add(k[i].scale(this.c[i]));\n        }\n        const teVal = y1.distance(y2);\n        let hNew = 0.9 * step * (this.tolerance_ / teVal) ** (1.0 / this.order);\n        const hOld = Math.abs(step);\n        hNew = Math.max(0.2 * hOld, Math.min(5.0 * hOld, hNew));\n        hNew = Math.max(1e-5, Math.min(1000.0, hNew));\n        return new RkResult(new J2000(state.epoch.roll(step), y1.toVector3D(0), y1.toVector3D(3)), teVal, hNew);\n    }\n    propagate(epoch) {\n        let delta = epoch.difference(this._cacheState.epoch);\n        while (delta !== 0) {\n            const direction = delta >= 0 ? 1 : -1;\n            const dt = Math.min(Math.abs(delta), this._stepSize) * direction;\n            const result = this.integrate_(this._cacheState, dt);\n            this._stepSize = result.newStep;\n            if (result.error > this.tolerance_) {\n                continue;\n            }\n            this._cacheState = result.state;\n            delta = epoch.difference(this._cacheState.epoch);\n        }\n        return this._cacheState;\n    }\n    maneuver(maneuver, interval = 60.0) {\n        if (maneuver.isImpulsive) {\n            this._cacheState = maneuver.apply(this.propagate(maneuver.center));\n            return [this._cacheState];\n        }\n        let tState = this.propagate(maneuver.start);\n        this.forceModel_.loadManeuver(maneuver);\n        const ephemeris = [tState];\n        while (tState.epoch < maneuver.stop) {\n            const step = Math.min(maneuver.stop.difference(tState.epoch), interval);\n            tState = this.propagate(tState.epoch.roll(step));\n            ephemeris.push(tState);\n        }\n        this.forceModel_.clearManeuver();\n        return ephemeris;\n    }\n    ephemerisManeuver(start, finish, maneuvers, interval = 60.0) {\n        const tMvr = maneuvers.filter((mvr) => mvr.start >= start || mvr.stop <= finish);\n        const ephemeris = [];\n        if (tMvr[0].start > start) {\n            ephemeris.push(this.propagate(start));\n        }\n        for (const mvr of tMvr) {\n            while (this._cacheState.epoch < mvr.start) {\n                const step = Math.min(mvr.start.difference(this._cacheState.epoch), interval);\n                this.propagate(this._cacheState.epoch.roll(step));\n                if (this._cacheState.epoch.posix !== mvr.start.posix) {\n                    ephemeris.push(this._cacheState);\n                }\n            }\n            ephemeris.push(...this.maneuver(mvr, interval));\n        }\n        while (this._cacheState.epoch.posix < finish.posix) {\n            const step = Math.min(finish.difference(this._cacheState.epoch), interval);\n            this.propagate(this._cacheState.epoch.roll(step));\n            ephemeris.push(this._cacheState);\n        }\n        return new VerletBlendInterpolator(ephemeris);\n    }\n    checkpoint() {\n        this._checkpoints.push(new RkCheckpoint(this._cacheState, this._stepSize));\n        return this._checkpoints.length - 1;\n    }\n    clearCheckpoints() {\n        this._checkpoints.length = 0;\n    }\n    restore(index) {\n        const checkpoint = this._checkpoints[index];\n        this._cacheState = checkpoint.cacheState;\n        this._stepSize = checkpoint.stepSize;\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { Propagator } from './Propagator.js';\n/**\n * Sgp4Propagator is a propagator that uses the SGP4 model to propagate the state of an object.\n * This class is useful for propagating multiple states with the same TLE, since it caches the\n * state of the TLE at different epochs.\n */\nexport class Sgp4Propagator extends Propagator {\n    tle_;\n    constructor(tle_) {\n        super();\n        this.tle_ = tle_;\n        this.cacheState_ = tle_.state.toJ2000();\n    }\n    cacheState_;\n    checkpoints_ = [];\n    /**\n     * Gets the state of the propagator in the J2000 coordinate system.\n     * @returns The J2000 state of the propagator.\n     */\n    get state() {\n        return this.cacheState_;\n    }\n    /**\n     * Calculates the ephemeris maneuver using the SGP4 propagator.\n     * @param start The start epoch in UTC.\n     * @param finish The finish epoch in UTC.\n     * @param maneuvers The array of thrust maneuvers.\n     * @param interval The time interval in seconds.\n     */\n    ephemerisManeuver(start, finish, maneuvers, interval = 60.0) {\n        throw new Error('Maneuvers cannot be modelled with SGP4.');\n    }\n    /**\n     * Performs a maneuver with the given thrust.\n     * @param maneuver - The thrust maneuver to perform.\n     * @param interval - The time interval for the maneuver (default: 60.0 seconds).\n     * @throws Error if maneuvers cannot be modeled with SGP4.\n     */\n    maneuver(maneuver, interval = 60.0) {\n        throw new Error('Maneuvers cannot be modelled with SGP4.');\n    }\n    /**\n     * Propagates the state of the Sgp4Propagator to a specified epoch in J2000 coordinates.\n     * @param epoch - The epoch in UTC format.\n     * @returns The propagated state in J2000 coordinates.\n     */\n    propagate(epoch) {\n        this.cacheState_ = this.tle_.propagate(epoch).toJ2000();\n        return this.cacheState_;\n    }\n    /**\n     * Resets the state of the Sgp4Propagator by updating the cache state\n     * to the current J2000 state of the TLE.\n     */\n    reset() {\n        this.cacheState_ = this.tle_.state.toJ2000();\n    }\n    /**\n     * Saves the current state of the propagator and returns the index of the checkpoint.\n     * @returns The index of the checkpoint.\n     */\n    checkpoint() {\n        this.checkpoints_.push(this.cacheState_);\n        return this.checkpoints_.length - 1;\n    }\n    /**\n     * Clears all the checkpoints in the propagator.\n     */\n    clearCheckpoints() {\n        this.checkpoints_ = [];\n    }\n    /**\n     * Restores the state of the propagator to a previously saved checkpoint.\n     * @param index - The index of the checkpoint to restore.\n     */\n    restore(index) {\n        this.cacheState_ = this.checkpoints_[index];\n    }\n}\n","export { RungeKutta4Propagator } from './RungeKutta4Propagator.js';\nexport { RungeKutta89Propagator } from './RungeKutta89Propagator.js';\nexport { Sgp4Propagator } from './Sgp4Propagator.js';\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nexport { Sgp4 } from './sgp4.js';\n","/**\n * Improved error handling for SGP4\n */\n// Define specific error types\nexport var Sgp4ErrorCode;\n(function (Sgp4ErrorCode) {\n    Sgp4ErrorCode[Sgp4ErrorCode[\"NO_ERROR\"] = 0] = \"NO_ERROR\";\n    Sgp4ErrorCode[Sgp4ErrorCode[\"MEAN_ELEMENTS_INVALID\"] = 1] = \"MEAN_ELEMENTS_INVALID\";\n    Sgp4ErrorCode[Sgp4ErrorCode[\"MEAN_MOTION_NEGATIVE\"] = 2] = \"MEAN_MOTION_NEGATIVE\";\n    Sgp4ErrorCode[Sgp4ErrorCode[\"PERT_ELEMENTS_INVALID\"] = 3] = \"PERT_ELEMENTS_INVALID\";\n    Sgp4ErrorCode[Sgp4ErrorCode[\"SEMI_LATUS_RECTUM_NEGATIVE\"] = 4] = \"SEMI_LATUS_RECTUM_NEGATIVE\";\n    Sgp4ErrorCode[Sgp4ErrorCode[\"EPOCH_ELEMENTS_SUBORBITAL\"] = 5] = \"EPOCH_ELEMENTS_SUBORBITAL\";\n    Sgp4ErrorCode[Sgp4ErrorCode[\"SATELLITE_DECAYED\"] = 6] = \"SATELLITE_DECAYED\"; // satellite has decayed\n})(Sgp4ErrorCode || (Sgp4ErrorCode = {}));\n// Error class for SGP4 errors\nexport class Sgp4Error extends Error {\n    code;\n    constructor(code, message) {\n        super(message ?? Sgp4Error.getDefaultMessage(code));\n        this.name = 'Sgp4Error';\n        this.code = code;\n    }\n    static getDefaultMessage(code) {\n        switch (code) {\n            case Sgp4ErrorCode.NO_ERROR:\n                return 'No error';\n            case Sgp4ErrorCode.MEAN_ELEMENTS_INVALID:\n                return 'Mean elements invalid: eccentricity out of range or semi-major axis too small';\n            case Sgp4ErrorCode.MEAN_MOTION_NEGATIVE:\n                return 'Mean motion is negative';\n            case Sgp4ErrorCode.PERT_ELEMENTS_INVALID:\n                return 'Perturbed elements invalid: eccentricity out of range';\n            case Sgp4ErrorCode.SEMI_LATUS_RECTUM_NEGATIVE:\n                return 'Semi-latus rectum is negative';\n            case Sgp4ErrorCode.EPOCH_ELEMENTS_SUBORBITAL:\n                return 'Epoch elements are sub-orbital';\n            case Sgp4ErrorCode.SATELLITE_DECAYED:\n                return 'Satellite has decayed';\n            default:\n                return `Unknown error code: ${code}`;\n        }\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * This class was ported from the python-sgp4 library by Brandon Rhodes. That library\n * is licensed under the MIT license and he maintains the copyright for that work.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\n// NOTE: This file is meant to maintain as much of the original format as possible.\n/* eslint-disable complexity */\n/* eslint-disable max-statements */\n/* eslint-disable max-lines-per-function */\n/* eslint-disable max-lines */\n/* eslint-disable @typescript-eslint/no-loss-of-precision */\nimport { Sgp4OpsMode } from '../enums/Sgp4OpsMode.js';\nimport { Tle } from '../main.js';\nimport { DEG2RAD, PI, TAU, temp4, x2o3 } from '../utils/constants.js';\nimport { Sgp4ErrorCode } from './sgp4-error.js';\nexport var Sgp4GravConstants;\n(function (Sgp4GravConstants) {\n    Sgp4GravConstants[\"wgs72old\"] = \"wgs72old\";\n    Sgp4GravConstants[\"wgs72\"] = \"wgs72\";\n    Sgp4GravConstants[\"wgs84\"] = \"wgs84\";\n})(Sgp4GravConstants || (Sgp4GravConstants = {}));\nexport var Sgp4Methods;\n(function (Sgp4Methods) {\n    Sgp4Methods[\"NEAR_EARTH\"] = \"n\";\n    Sgp4Methods[\"DEEP_SPACE\"] = \"d\";\n})(Sgp4Methods || (Sgp4Methods = {}));\n/** Ootk -- Some variables imported from outside the class at the top */\nconst fasx2 = 0.13130908;\nconst fasx4 = 2.8843198;\nconst fasx6 = 0.37448087;\nconst g22 = 5.7686396;\nconst g32 = 0.95240898;\nconst g44 = 1.8014998;\nconst g52 = 1.050833;\nconst g54 = 4.4108898;\nconst rptim = 4.37526908801129966e-3; // Equates to 7.29211514668855e-5 rad/sec\nconst stepp = 720.0;\nconst stepn = -720.0;\nconst step2 = 259200.0;\n/*\n *     ----------------------------------------------------------------\n *\n *                               sgp4unit.cpp\n *\n *    this file contains the sgp4 procedures for analytical propagation\n *    of a satellite. the code was originally released in the 1980 and 1986\n *    spacetrack papers. a detailed discussion of the theory and history\n *    may be found in the 2006 aiaa paper by vallado, crawford, hujsak,\n *    and kelso.\n *\n *                            companion code for\n *               fundamentals of astrodynamics and applications\n *                                    2013\n *                              by david vallado\n *\n *     (w) 719-573-2600, email dvallado@agi.com, davallado@gmail.com\n *\n *    current :\n *              12 mar 20  david vallado\n *                           chg satnum to string for alpha 5 or 9-digit\n *    changes :\n *               7 dec 15  david vallado\n *                           fix jd, jdfrac\n *               3 nov 14  david vallado\n *                           update to msvs2013 c++\n *              30 aug 10  david vallado\n *                           delete unused variables in initl\n *                           replace pow integer 2, 3 with multiplies for speed\n *               3 nov 08  david vallado\n *                           put returns in for error codes\n *              29 sep 08  david vallado\n *                           fix atime for faster operation in dspace\n *                           add operationmode for afspc (a) or improved (i)\n *                           performance mode\n *              16 jun 08  david vallado\n *                           update small eccentricity check\n *              16 nov 07  david vallado\n *                           misc fixes for better compliance\n *              20 apr 07  david vallado\n *                           misc fixes for constants\n *              11 aug 06  david vallado\n *                           chg lyddane choice back to strn3, constants, misc doc\n *              15 dec 05  david vallado\n *                           misc fixes\n *              26 jul 05  david vallado\n *                           fixes for paper\n *                           note that each fix is preceded by a\n *                           comment with \"sgp4fix\" and an explanation of\n *                           what was changed\n *              10 aug 04  david vallado\n *                           2nd printing baseline working\n *              14 may 01  david vallado\n *                           2nd edition baseline\n *                     80  norad\n *                           original baseline\n *       ----------------------------------------------------------------\n */\nexport class Sgp4 {\n    /*\n     * -----------------------------------------------------------------------------\n     *\n     *                           procedure angle_SGP4\n     *\n     *  this procedure calculates the angle between two vectors.  the output is\n     *    set to 999999.1 to indicate an undefined value.  be sure to check for\n     *    this at the output phase.\n     *\n     *  author        : david vallado                  719-573-2600    1 mar 2001\n     *\n     *  inputs          description                    range / units\n     *    vec1        - vector number 1\n     *    vec2        - vector number 2\n     *\n     *  outputs       :\n     *    theta       - angle between the two vectors  -pi to pi\n     *\n     *  locals        :\n     *    temp        - temporary real variable\n     *\n     *  coupling      :\n     *    dot           dot product of two vectors\n     * ---------------------------------------------------------------------------\n     */\n    static angle_(vec1, vec2) {\n        const small = 0.00000001;\n        const unknown = 999999.1; /** Ootk -- original 'undefined' is protected in JS */\n        const magv1 = Sgp4.mag_(vec1);\n        const magv2 = Sgp4.mag_(vec2);\n        const magnitudeProduct = magv1 * magv2;\n        if (magnitudeProduct > small * small) {\n            let temp = Sgp4.dot_(vec1, vec2) / (magnitudeProduct);\n            // Clamp to [-1, 1] to avoid NaN from floating point errors\n            if (temp > 1.0) {\n                temp = 1.0;\n            }\n            if (temp < -1.0) {\n                temp = -1.0;\n            }\n            return Math.acos(temp);\n        }\n        return unknown;\n    }\n    /*\n     * -----------------------------------------------------------------------------\n     *\n     *                           function asinh_SGP4\n     *\n     *  this function evaluates the inverse hyperbolic sine function.\n     *\n     *  author        : david vallado                  719-573-2600    1 mar 2001\n     *\n     *  inputs          description                    range / units\n     *    xval        - angle value                                  any real\n     *\n     *  outputs       :\n     *    arcsinh     - result                                       any real\n     *\n     *  locals        :\n     *    none.\n     *\n     *  coupling      :\n     *    none.\n     * ---------------------------------------------------------------------------\n     */\n    static asinh_(xval) {\n        return Math.log(xval + Math.sqrt(xval * xval + 1.0));\n    }\n    /*\n     * -----------------------------------------------------------------------------\n     *\n     *                           function twoline2rv\n     *\n     *  this function converts the two line element set character string data to\n     *    variables and initializes the sgp4 variables. several intermediate varaibles\n     *    and quantities are determined. note that the result is a structure so multiple\n     *    satellites can be processed simultaneously without having to reinitialize. the\n     *    verification mode is an important option that permits quick checks of any\n     *    changes to the underlying technical theory. this option works using a\n     *    modified tle file in which the start, stop, and delta time values are\n     *    included at the end of the second line of data. this only works with the\n     *    verification mode. the catalog mode simply propagates from -1440 to 1440 min\n     *    from epoch and is useful when performing entire catalog runs.\n     *\n     *  author        : david vallado                  719-573-2600    1 mar 2001\n     *\n     *  inputs        :\n     *    longstr1    - first line of the tle\n     *    longstr2    - second line of the tle\n     *    typerun     - type of run                    verification 'v', catalog 'c',\n     *                                                 manual 'm'\n     *    typeinput   - type of manual input           mfe 'm', epoch 'e', dayofyr 'd'\n     *    opsmode     - mode of operation afspc or improved 'a', 'i'\n     *    whichconst  - which set of constants to use  72, 84\n     *\n     *  outputs       :\n     *    satrec      - structure containing all the sgp4 satellite information\n     *\n     *  coupling      :\n     *    getgravconst-\n     *    days2mdhms  - conversion of days to month, day, hour, minute, second\n     *    jday        - convert day month year hour minute second into julian date\n     *    sgp4init    - initialize the sgp4 variables\n     *\n     *  references    :\n     *    norad spacetrack report #3\n     *    vallado, crawford, hujsak, kelso  2006\n     * ---------------------------------------------------------------------------\n     */\n    static createSatrec(tleLine1, tleLine2, whichconst = Sgp4GravConstants.wgs72, opsmode = Sgp4OpsMode.IMPROVED) {\n        let year = 0;\n        const satrec = {\n            error: Sgp4ErrorCode.NO_ERROR,\n        };\n        /*\n         * Sgp4fix no longer needed\n         * getgravconst( whichconst, tumin, mu, radiusearthkm, xke, j2, j3, j4, j3oj2 );\n         */\n        const xpdotp = 1440.0 / (2.0 * PI); // 229.1831180523293;\n        satrec.satnum = tleLine1.substring(2, 7);\n        satrec.epochyr = parseInt(tleLine1.substring(18, 20));\n        satrec.epochdays = parseFloat(tleLine1.substring(20, 32));\n        satrec.ndot = parseFloat(tleLine1.substring(33, 43));\n        satrec.nddot = parseFloat(`${tleLine1.substring(44, 45)}.${tleLine1.substring(45, 50)}E${tleLine1.substring(50, 52)}`);\n        satrec.bstar = parseFloat(`${tleLine1.substring(53, 54)}.${tleLine1.substring(54, 59)}E${tleLine1.substring(59, 61)}`);\n        satrec.inclo = parseFloat(tleLine2.substring(8, 16));\n        satrec.nodeo = parseFloat(tleLine2.substring(17, 25));\n        satrec.ecco = parseFloat(`.${tleLine2.substring(26, 33)}`);\n        satrec.argpo = parseFloat(tleLine2.substring(34, 42));\n        satrec.mo = parseFloat(tleLine2.substring(43, 51));\n        satrec.no = parseFloat(tleLine2.substring(52, 63));\n        // ---- find no, ndot, nddot ----\n        satrec.no /= xpdotp; //   Rad/min\n        /** Ootk -- nexp and ibexp are calculated above using template literals */\n        /*\n         * Satrec.nddot = satrec.nddot * Math.pow(10.0, nexp);\n         * satrec.bstar = satrec.bstar * Math.pow(10.0, ibexp);\n         */\n        /*\n         * ---- convert to sgp4 units ----\n         * satrec.a = (satrec.no * tumin) ** (-2.0 / 3.0);\n         */\n        /** Ootk -- Not sure why the following two lines are added. 1st and 2nd derivatives aren't even used anymore */\n        /*\n         * Satrec.ndot /= xpdotp * 1440.0; // ? * minperday\n         * satrec.nddot /= xpdotp * 1440.0 * 1440;\n         */\n        // ---- find standard orbital elements ----\n        satrec.inclo *= DEG2RAD;\n        satrec.nodeo *= DEG2RAD;\n        satrec.argpo *= DEG2RAD;\n        satrec.mo *= DEG2RAD;\n        /*\n         * Sgp4fix not needed here\n         * satrec.alta = satrec.a * (1.0 + satrec.ecco) - 1.0;\n         * satrec.altp = satrec.a * (1.0 - satrec.ecco) - 1.0;\n         */\n        /*\n         * ----------------------------------------------------------------\n         * find sgp4epoch time of element set\n         * remember that sgp4 uses units of days from 0 jan 1950 (sgp4epoch)\n         * and minutes from the epoch (time)\n         * ----------------------------------------------------------------\n         */\n        /*\n         * ---------------- temp fix for years from 1957-2056 -------------------\n         * --------- correct fix will occur when year is 4-digit in tle ---------\n         */\n        if (satrec.epochyr < 57) {\n            year = satrec.epochyr + 2000;\n        }\n        else {\n            year = satrec.epochyr + 1900;\n        }\n        const { mon, day, hr, min, sec } = Sgp4.days2mdhms(year, satrec.epochdays);\n        const jdayRes = Sgp4.jday(year, mon, day, hr, min, sec);\n        satrec.jdsatepoch = jdayRes.jd + jdayRes.jdFrac;\n        //  ---------------- initialize the orbit at sgp4epoch -------------------\n        Sgp4.sgp4init_(satrec, {\n            whichconst,\n            opsmode,\n            satn: satrec.satnum,\n            epoch: satrec.jdsatepoch - 2433281.5,\n            xbstar: satrec.bstar,\n            xecco: satrec.ecco,\n            xargpo: satrec.argpo,\n            xinclo: satrec.inclo,\n            xndot: satrec.ndot,\n            xnddot: satrec.nddot,\n            xmo: satrec.mo,\n            xno: satrec.no,\n            xnodeo: satrec.nodeo,\n        });\n        return satrec;\n    }\n    static createSatrecFromOmm(omm, whichconst = Sgp4GravConstants.wgs72, opsmode = Sgp4OpsMode.IMPROVED) {\n        let year = 0;\n        const satrec = {\n            error: Sgp4ErrorCode.NO_ERROR,\n        };\n        const xpdotp = 1440.0 / (2.0 * PI); // 229.1831180523293;\n        satrec.error = Sgp4ErrorCode.NO_ERROR;\n        satrec.satnum = omm.NORAD_CAT_ID;\n        satrec.epochyr = parseInt(omm.epoch.year.toString().slice(-2));\n        satrec.epochdays = omm.epoch.doy;\n        satrec.ndot = parseFloat(omm.MEAN_MOTION_DOT);\n        satrec.nddot = parseFloat(omm.MEAN_MOTION_DDOT);\n        satrec.bstar = parseFloat(omm.BSTAR);\n        satrec.inclo = parseFloat(omm.INCLINATION);\n        satrec.nodeo = parseFloat(omm.RA_OF_ASC_NODE);\n        satrec.ecco = parseFloat(omm.ECCENTRICITY);\n        satrec.argpo = parseFloat(omm.ARG_OF_PERICENTER);\n        satrec.mo = parseFloat(omm.MEAN_ANOMALY);\n        satrec.no = parseFloat(omm.MEAN_MOTION);\n        // ---- find no, ndot, nddot ----\n        satrec.no /= xpdotp; //   Rad/min\n        /** Ootk -- nexp and ibexp are calculated above using template literals */\n        /*\n         * Satrec.nddot = satrec.nddot * Math.pow(10.0, nexp);\n         * satrec.bstar = satrec.bstar * Math.pow(10.0, ibexp);\n         */\n        /*\n         * ---- convert to sgp4 units ----\n         * satrec.a = (satrec.no * tumin) ** (-2.0 / 3.0);\n         */\n        /** Ootk -- Not sure why the following two lines are added. 1st and 2nd derivatives aren't even used anymore */\n        /*\n         * Satrec.ndot /= xpdotp * 1440.0; // ? * minperday\n         * satrec.nddot /= xpdotp * 1440.0 * 1440;\n         */\n        // ---- find standard orbital elements ----\n        satrec.inclo *= DEG2RAD;\n        satrec.nodeo *= DEG2RAD;\n        satrec.argpo *= DEG2RAD;\n        satrec.mo *= DEG2RAD;\n        /*\n         * Sgp4fix not needed here\n         * satrec.alta = satrec.a * (1.0 + satrec.ecco) - 1.0;\n         * satrec.altp = satrec.a * (1.0 - satrec.ecco) - 1.0;\n         */\n        /*\n         * ----------------------------------------------------------------\n         * find sgp4epoch time of element set\n         * remember that sgp4 uses units of days from 0 jan 1950 (sgp4epoch)\n         * and minutes from the epoch (time)\n         * ----------------------------------------------------------------\n         */\n        /*\n         * ---------------- temp fix for years from 1957-2056 -------------------\n         * --------- correct fix will occur when year is 4-digit in tle ---------\n         */\n        if (satrec.epochyr < 57) {\n            year = satrec.epochyr + 2000;\n        }\n        else {\n            year = satrec.epochyr + 1900;\n        }\n        const { mon, day, hr, min, sec } = Sgp4.days2mdhms(year, satrec.epochdays);\n        const jdayRes = Sgp4.jday(year, mon, day, hr, min, sec);\n        satrec.jdsatepoch = jdayRes.jd + jdayRes.jdFrac;\n        //  ---------------- initialize the orbit at sgp4epoch -------------------\n        Sgp4.sgp4init_(satrec, {\n            whichconst,\n            opsmode,\n            satn: satrec.satnum,\n            epoch: satrec.jdsatepoch - 2433281.5,\n            xbstar: satrec.bstar,\n            xecco: satrec.ecco,\n            xargpo: satrec.argpo,\n            xinclo: satrec.inclo,\n            xndot: satrec.ndot,\n            xnddot: satrec.nddot,\n            xmo: satrec.mo,\n            xno: satrec.no,\n            xnodeo: satrec.nodeo,\n        });\n        return satrec;\n    }\n    /*\n     * -----------------------------------------------------------------------------\n     *\n     *                           procedure cross_SGP4\n     *\n     *  this procedure crosses two vectors.\n     *\n     *  author        : david vallado                  719-573-2600    1 mar 2001\n     *\n     *  inputs          description                    range / units\n     *    vec1        - vector number 1\n     *    vec2        - vector number 2\n     *\n     *  outputs       :\n     *    outvec      - vector result of a x b\n     *\n     *  locals        :\n     *    none.\n     *\n     *  coupling      :\n     *    mag           magnitude of a vector\n     * ----------------------------------------------------------------------------\n     */\n    static cross_(vec1, vec2) {\n        return [\n            vec1[1] * vec2[2] - vec1[2] * vec2[1],\n            vec1[2] * vec2[0] - vec1[0] * vec2[2],\n            vec1[0] * vec2[1] - vec1[1] * vec2[0],\n        ];\n    }\n    /*\n     * -----------------------------------------------------------------------------\n     *\n     *                           procedure days2mdhms\n     *\n     *  this procedure converts the day of the year, days, to the equivalent month\n     *    day, hour, minute and second.\n     *\n     *  algorithm     : set up array for the number of days per month\n     *                  find leap year - use 1900 because 2000 is a leap year\n     *                  loop through a temp value while the value is < the days\n     *                  perform int conversions to the correct day and month\n     *                  convert remainder into h m s using type conversions\n     *\n     *  author        : david vallado                  719-573-2600    1 mar 2001\n     *\n     *  inputs          description                    range / units\n     *    year        - year                           1900 .. 2100\n     *    days        - julian day of the year         0.0  .. 366.0\n     *\n     *  outputs       :\n     *    mon         - month                          1 .. 12\n     *    day         - day                            1 .. 28,29,30,31\n     *    hr          - hour                           0 .. 23\n     *    min         - minute                         0 .. 59\n     *    sec         - second                         0.0 .. 59.999\n     *\n     *  locals        :\n     *    dayofyr     - day of year\n     *    temp        - temporary extended values\n     *    inttemp     - temporary int value\n     *    i           - index\n     *    lmonth[13]  - int array containing the number of days per month\n     *\n     *  coupling      :\n     *    none.\n     * ---------------------------------------------------------------------------\n     */\n    static days2mdhms(year, days) {\n        const lmonth = [31, year % 4 === 0 ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n        const dayofyr = Math.floor(days);\n        //  ----------------- find month and day of month ----------------\n        /** Ootk -- Incorporated in the above declaration */\n        /*\n         * If ((year % 4) == 0)\n         * lmonth[2] = 29;\n         */\n        let i = 1;\n        let inttemp = 0;\n        while (dayofyr > inttemp + (lmonth[i - 1]) && i < 12) {\n            inttemp += (lmonth[i - 1]);\n            i += 1;\n        }\n        const mon = i;\n        const day = dayofyr - inttemp;\n        //  ----------------- find hours minutes and seconds -------------\n        let temp = (days - dayofyr) * 24.0;\n        const hr = Math.floor(temp);\n        temp = (temp - hr) * 60.0;\n        const min = Math.floor(temp);\n        const sec = (temp - min) * 60.0;\n        return {\n            mon,\n            day,\n            hr,\n            min,\n            sec,\n        };\n    }\n    /*\n     * -----------------------------------------------------------------------------\n     *\n     *                           function dot_SGP4\n     *\n     *  this function finds the dot product of two vectors.\n     *\n     *  author        : david vallado                  719-573-2600    1 mar 2001\n     *\n     *  inputs          description                    range / units\n     *    vec1        - vector number 1\n     *    vec2        - vector number 2\n     *\n     *  outputs       :\n     *    dot         - result\n     *\n     *  locals        :\n     *    none.\n     *\n     *  coupling      :\n     *    none.\n     * ---------------------------------------------------------------------------\n     */\n    static dot_(v1, v2) {\n        return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];\n    }\n    /*\n     * -----------------------------------------------------------------------------\n     *\n     *                           function gstime\n     *\n     *  this function finds the greenwich sidereal time.\n     *\n     *  author        : david vallado                  719-573-2600    1 mar 2001\n     *\n     *  inputs          description                    range / units\n     *    jdut1       - julian date in ut1             days from 4713 bc\n     *\n     *  outputs       :\n     *    gstime      - greenwich sidereal time        0 to 2PI rad\n     *\n     *  locals        :\n     *    temp        - temporary variable for doubles   rad\n     *    tut1        - julian centuries from the\n     *                  jan 1, 2000 12 h epoch (ut1)\n     *\n     *  coupling      :\n     *    none\n     *\n     *  references    :\n     *    vallado       2004, 191, eq 3-45\n     * ---------------------------------------------------------------------------\n     */\n    static gstime(jdut1) {\n        const tut1 = (jdut1 - 2451545.0) / 36525.0;\n        let temp = -6.2e-6 * tut1 * tut1 * tut1 + 0.093104 * tut1 * tut1 +\n            (876600.0 * 3600 + 8640184.812866) * tut1 + 67310.54841; // Sec\n        temp = ((temp * DEG2RAD) / 240.0) % TAU; // 360/86400 = 1/240, to deg, to rad\n        //  ------------------------ check quadrants ---------------------\n        if (temp < 0.0) {\n            temp += TAU;\n        }\n        return temp;\n    }\n    /*\n     * -----------------------------------------------------------------------------\n     *\n     *                           procedure invjday\n     *\n     *  this procedure finds the year, month, day, hour, minute and second\n     *  given the julian date. tu can be ut1, tdt, tdb, etc.\n     *\n     *  algorithm     : set up starting values\n     *                  find leap year - use 1900 because 2000 is a leap year\n     *                  find the elapsed days through the year in a loop\n     *                  call routine to find each individual value\n     *\n     *  author        : david vallado                  719-573-2600    1 mar 2001\n     *\n     *  inputs          description                    range / units\n     *    jd          - julian date                    days from 4713 bc\n     *    jdfrac      - julian date fraction into day  days from 4713 bc\n     *\n     *  outputs       :\n     *    year        - year                           1900 .. 2100\n     *    mon         - month                          1 .. 12\n     *    day         - day                            1 .. 28,29,30,31\n     *    hr          - hour                           0 .. 23\n     *    min         - minute                         0 .. 59\n     *    sec         - second                         0.0 .. 59.999\n     *\n     *  locals        :\n     *    days        - day of year plus fractional\n     *                  portion of a day               days\n     *    tu          - julian centuries from 0 h\n     *                  jan 0, 1900\n     *    temp        - temporary double values\n     *    leapyrs     - number of leap years from 1900\n     *\n     *  coupling      :\n     *    days2mdhms  - finds month, day, hour, minute and second given days and year\n     *\n     *  references    :\n     *    vallado       2013, 203, alg 22, ex 3-13\n     * ---------------------------------------------------------------------------\n     */\n    static invjday(jd, jdfrac) {\n        let leapyrs;\n        let days;\n        // Check jdfrac for multiple days\n        if (Math.abs(jdfrac) >= 1.0) {\n            jd += Math.floor(jdfrac);\n            jdfrac -= Math.floor(jdfrac);\n        }\n        // Check for fraction of a day included in the jd\n        const dt = jd - Math.floor(jd) - 0.5;\n        if (Math.abs(dt) > 0.00000001) {\n            jd -= dt;\n            jdfrac += dt;\n        }\n        /* --------------- find year and days of the year --------------- */\n        const temp = jd - 2415019.5;\n        const tu = temp / 365.25;\n        let year = 1900 + Math.floor(tu);\n        leapyrs = Math.floor((year - 1901) * 0.25);\n        days = Math.floor(temp - ((year - 1900) * 365.0 + leapyrs));\n        /* ------------ check for case of beginning of a year ----------- */\n        if (days + jdfrac < 1.0) {\n            year -= 1;\n            leapyrs = Math.floor((year - 1901) * 0.25);\n            days = Math.floor(temp - ((year - 1900) * 365.0 + leapyrs));\n        }\n        /* ----------------- find remaining data  ------------------------- */\n        const { mon, day, hr, min, sec } = Sgp4.days2mdhms(year, days + jdfrac);\n        return {\n            year,\n            mon,\n            day,\n            hr,\n            min,\n            sec,\n        };\n    }\n    /*\n     * -----------------------------------------------------------------------------\n     *\n     *                           procedure jday\n     *\n     *  this procedure finds the julian date given the year, month, day, and time.\n     *    the julian date is defined by each elapsed day since noon, jan 1, 4713 bc.\n     *\n     *  algorithm     : calculate the answer in one step for efficiency\n     *\n     *  author        : david vallado                  719-573-2600    1 mar 2001\n     *\n     *  inputs          description                    range / units\n     *    year        - year                           1900 .. 2100\n     *    mon         - month                          1 .. 12\n     *    day         - day                            1 .. 28,29,30,31\n     *    hr          - universal time hour            0 .. 23\n     *    min         - universal time min             0 .. 59\n     *    sec         - universal time sec             0.0 .. 59.999\n     *\n     *  outputs       :\n     *    jd          - julian date                    days from 4713 bc\n     *    jdfrac      - julian date fraction into day  days from 4713 bc\n     *\n     *  locals        :\n     *    none.\n     *\n     *  coupling      :\n     *    none.\n     *\n     *  references    :\n     *    vallado       2013, 183, alg 14, ex 3-4\n     *\n     * ---------------------------------------------------------------------------\n     */\n    static jday(year, mon = 0, day = 0, hr = 0, min = 0, sec = 0, ms = 0) {\n        if (year instanceof Date) {\n            mon = year.getUTCMonth() + 1;\n            day = year.getUTCDate();\n            hr = year.getUTCHours();\n            min = year.getUTCMinutes();\n            sec = year.getUTCSeconds();\n            ms = year.getUTCMilliseconds();\n            year = year.getUTCFullYear();\n        }\n        let jd = 367.0 * year -\n            Math.floor(7 * (year + Math.floor((mon + 9) / 12.0)) * 0.25) +\n            Math.floor((275 * mon) / 9.0) +\n            day +\n            1721013.5; // Use - 678987.0 to go to mjd directly\n        let jdFrac = (ms / 1000 + sec + min * 60.0 + hr * 3600.0) / 86400.0;\n        // Check that the day and fractional day are correct\n        if (Math.abs(jdFrac) > 1.0) {\n            const dtt = Math.floor(jdFrac);\n            jd += dtt;\n            jdFrac -= dtt;\n        }\n        // - 0.5*sgn(100.0*year + mon - 190002.5) + 0.5;\n        return { jd, jdFrac };\n    }\n    /*\n     * -----------------------------------------------------------------------------\n     *\n     *                           function mag\n     *\n     *  this procedure finds the magnitude of a vector.\n     *\n     *  author        : david vallado                  719-573-2600    1 mar 2001\n     *\n     *  inputs          description                    range / units\n     *    vec         - vector\n     *\n     *  outputs       :\n     *    mag         - answer\n     *\n     *  locals        :\n     *    none.\n     *\n     *  coupling      :\n     *    none.\n     * ---------------------------------------------------------------------------\n     */\n    static mag_(v) {\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);\n    }\n    /*\n     * -----------------------------------------------------------------------------\n     *\n     *                           function newtonnu_SGP4\n     *\n     *  this function solves keplers equation when the true anomaly is known.\n     *    the mean and eccentric, parabolic, or hyperbolic anomaly is also found.\n     *    the parabolic limit at 168Ã¸ is arbitrary. the hyperbolic anomaly is also\n     *    limited. the hyperbolic sine is used because it's not double valued.\n     *\n     *  author        : david vallado                  719-573-2600   27 may 2002\n     *\n     *  revisions\n     *    vallado     - fix small                                     24 sep 2002\n     *\n     *  inputs          description                    range / units\n     *    ecc         - eccentricity                   0.0  to\n     *    nu          - true anomaly                   -2pi to 2pi rad\n     *\n     *  outputs       :\n     *    e0          - eccentric anomaly              0.0  to 2pi rad       153.02 Ã¸\n     *    m           - mean anomaly                   0.0  to 2pi rad       151.7425 Ã¸\n     *\n     *  locals        :\n     *    e1          - eccentric anomaly, next value  rad\n     *    sine        - sine of e\n     *    cose        - cosine of e\n     *    ktr         - index\n     *\n     *  coupling      :\n     *    asinh       - arc hyperbolic sine\n     *\n     *  references    :\n     *    vallado       2013, 77, alg 5\n     * ---------------------------------------------------------------------------\n     */\n    static newtonnu_(ecc, nu) {\n        // ---------------------  implementation   ---------------------\n        let e0 = 999999.9;\n        let m = 999999.9;\n        const small = 0.00000001;\n        if (Math.abs(ecc) < small) {\n            // --------------------------- circular ------------------------\n            m = nu;\n            e0 = nu;\n        }\n        else if (ecc < 1.0 - small) {\n            // ---------------------- elliptical -----------------------\n            const sine = (Math.sqrt(1.0 - ecc * ecc) * Math.sin(nu)) / (1.0 + ecc * Math.cos(nu));\n            const cose = (ecc + Math.cos(nu)) / (1.0 + ecc * Math.cos(nu));\n            e0 = Math.atan2(sine, cose);\n            m = e0 - ecc * Math.sin(e0);\n        }\n        else if (ecc > 1.0 + small) {\n            // -------------------- hyperbolic  --------------------\n            if (ecc > 1.0 && Math.abs(nu) + 0.00001 < PI - Math.acos(1.0 / ecc)) {\n                const sine = (Math.sqrt(ecc * ecc - 1.0) * Math.sin(nu)) / (1.0 + ecc * Math.cos(nu));\n                e0 = Sgp4.asinh_(sine);\n                m = ecc * Sgp4.sinh_(e0) - e0;\n            }\n        }\n        else if (Math.abs(nu) < (168.0 * PI) / 180.0) {\n            // ----------------- parabolic ---------------------\n            e0 = Math.tan(nu * 0.5);\n            m = e0 + (e0 * e0 * e0) / 3.0;\n        }\n        if (ecc < 1.0) {\n            m %= 2.0 * PI;\n            if (m < 0.0) {\n                m += 2.0 * PI;\n            }\n            e0 %= 2.0 * PI;\n        }\n        return {\n            e0,\n            m,\n        };\n    }\n    /*\n     *----------------------------------------------------------------------------\n     *\n     *                             procedure sgp4\n     *\n     *  this procedure is the sgp4 prediction model from space command. this is an\n     *    updated and combined version of sgp4 and sdp4, which were originally\n     *    published separately in spacetrack report //3. this version follows the\n     *    methodology from the aiaa paper (2006) describing the history and\n     *    development of the code.\n     *\n     *  author        : david vallado                  719-573-2600   28 jun 2005\n     *\n     *  inputs        :\n     *    satrec  - initialised structure from sgp4init() call.\n     *    tsince  - time since epoch (minutes)\n     *\n     *  outputs       :\n     *    r           - position vector                     km\n     *    v           - velocity                            km/sec\n     *  return code - non-zero on error.\n     *                   1 - mean elements, ecc >= 1.0 or ecc < -0.001 or a < 0.95 er\n     *                   2 - mean motion less than 0.0\n     *                   3 - pert elements, ecc < 0.0  or  ecc > 1.0\n     *                   4 - semi-latus rectum < 0.0\n     *                   5 - epoch elements are sub-orbital\n     *                   6 - satellite has decayed\n     *\n     *  locals        :\n     *    am          -\n     *    axnl, aynl        -\n     *    betal       -\n     *    cosim   , sinim   , cosomm  , sinomm  , cnod    , snod    , cos2u   ,\n     *    sin2u   , coseo1  , sineo1  , cosi    , sini    , cosip   , sinip   ,\n     *    cosisq  , cossu   , sinsu   , cosu    , sinu\n     *    delm        -\n     *    delomg      -\n     *    dndt        -\n     *    eccm        -\n     *    emsq        -\n     *    ecose       -\n     *    el2         -\n     *    eo1         -\n     *    eccp        -\n     *    esine       -\n     *    argpm       -\n     *    argpp       -\n     *    omgadf      -\n     *    pl          -\n     *    r           -\n     *    rtemsq      -\n     *    rdotl       -\n     *    rl          -\n     *    rvdot       -\n     *    rvdotl      -\n     *    su          -\n     *    t2  , t3   , t4    , tc\n     *    tem5, temp , temp1 , temp2  , tempa  , tempe  , templ\n     *    u   , ux   , uy    , uz     , vx     , vy     , vz\n     *    inclm       - inclination\n     *    mm          - mean anomaly\n     *    nm          - mean motion\n     *    nodem       - right asc of ascending node\n     *    xinc        -\n     *    xincp       -\n     *    xl          -\n     *    xlm         -\n     *    mp          -\n     *    xmdf        -\n     *    xmx         -\n     *    xmy         -\n     *    nodedf      -\n     *    xnode       -\n     *    nodep       -\n     *    np          -\n     *\n     *  coupling      :\n     *    getgravconst-\n     *    dpper\n     *    dspace\n     *\n     *  references    :\n     *    hoots, roehrich, norad spacetrack report //3 1980\n     *    hoots, norad spacetrack report //6 1986\n     *    hoots, schumacher and glover 2004\n     *    vallado, crawford, hujsak, kelso  2006\n     *----------------------------------------------------------------------------\n     */\n    static propagate(satrec, tsince) {\n        /* ------------------ set mathematical constants --------------- */\n        /*\n         * Sgp4fix divisor for divide by zero check on inclination\n         * the old check used 1.0 + cos(PI-1.0e-9), but then compared it to\n         * 1.5 e-12, so the threshold was changed to 1.5e-12 for consistency\n         */\n        /*\n         * Sgp4fix identify constants and allow alternate values\n         * getgravconst( whichconst, tumin, mu, radiusearthkm, xke, j2, j3, j4, j3oj2 );\n         */\n        const { xke, j2, j3oj2, vkmpersec } = satrec;\n        // --------------------- clear sgp4 error flag -----------------\n        satrec.t = tsince;\n        satrec.error = Sgp4ErrorCode.NO_ERROR;\n        //  ------- update for secular gravity and atmospheric drag -----\n        const xmdf = satrec.mo + satrec.mdot * satrec.t;\n        const argpdf = satrec.argpo + satrec.argpdot * satrec.t;\n        const nodedf = satrec.nodeo + satrec.nodedot * satrec.t;\n        let argpm = argpdf;\n        let mm = xmdf;\n        const t2 = satrec.t * satrec.t;\n        let nodem = nodedf + satrec.nodecf * t2;\n        let tempa = 1.0 - satrec.cc1 * satrec.t;\n        let tempe = satrec.bstar * satrec.cc4 * satrec.t;\n        let templ = satrec.t2cof * t2;\n        if (!satrec.isimp) {\n            const delomg = satrec.omgcof * satrec.t;\n            //  Sgp4fix use mutliply for speed instead of pow\n            const delmtemp = 1.0 + satrec.eta * Math.cos(xmdf);\n            const delm = satrec.xmcof * (delmtemp * delmtemp * delmtemp - satrec.delmo);\n            const temp = delomg + delm;\n            mm = xmdf + temp;\n            argpm = argpdf - temp;\n            const t3 = t2 * satrec.t;\n            const t4 = t3 * satrec.t;\n            tempa = tempa - satrec.d2 * t2 - satrec.d3 * t3 - satrec.d4 * t4;\n            tempe += satrec.bstar * satrec.cc5 * (Math.sin(mm) - satrec.sinmao);\n            templ = templ + satrec.t3cof * t3 + t4 * (satrec.t4cof + satrec.t * satrec.t5cof);\n        }\n        let nm = satrec.no;\n        let em = satrec.ecco;\n        let inclm = satrec.inclo;\n        if (satrec.method === Sgp4Methods.DEEP_SPACE) {\n            [em, argpm, inclm, mm, nodem, nm] = Sgp4.dspace_(em, argpm, inclm, mm, nodem, nm, satrec);\n        }\n        if (nm <= 0.0) {\n            satrec.error = Sgp4ErrorCode.MEAN_MOTION_NEGATIVE;\n            return { position: false, velocity: false };\n        }\n        const am = (xke / nm) ** x2o3 * tempa * tempa;\n        nm = xke / am ** 1.5;\n        em -= tempe;\n        /*\n         * Fix tolerance for error recognition\n         * sgp4fix am is fixed from the previous nm check\n         */\n        /* istanbul ignore next | This is no longer possible*/\n        if (em >= 1.0 || em < -0.001) {\n            satrec.error = Sgp4ErrorCode.MEAN_MOTION_NEGATIVE;\n            return { position: false, velocity: false };\n        }\n        //  Sgp4fix fix tolerance to avoid a divide by zero\n        if (em < 1.0e-6) {\n            em = 1.0e-6;\n        }\n        mm += satrec.no * templ;\n        let xlm = mm + argpm + nodem;\n        nodem %= TAU;\n        argpm %= TAU;\n        xlm %= TAU;\n        mm = (xlm - argpm - nodem) % TAU;\n        /*\n         * Sgp4fix recover singly averaged mean elements\n         * satrec.am = am;\n         * satrec.em = em;\n         * satrec.im = inclm;\n         * satrec.Om = nodem;\n         * satrec.om = argpm;\n         * satrec.mm = mm;\n         * satrec.nm = nm;\n         */\n        // ----------------- compute extra mean quantities -------------\n        const sinim = Math.sin(inclm);\n        const cosim = Math.cos(inclm);\n        // -------------------- add lunar-solar periodics --------------\n        let ep = em;\n        let xincp = inclm;\n        let argpp = argpm;\n        let nodep = nodem;\n        let mp = mm;\n        let sinip = sinim;\n        let cosip = cosim;\n        if (satrec.method === Sgp4Methods.DEEP_SPACE) {\n            const dpperParameters = {\n                inclo: satrec.inclo,\n                init: false,\n                ep,\n                inclp: xincp,\n                nodep,\n                argpp,\n                mp,\n                opsmode: satrec.operationmode,\n                satrec,\n            };\n            ({ ep, nodep, argpp, mp, inclp: xincp } = Sgp4.dpper_(dpperParameters));\n            if (xincp < 0.0) {\n                xincp = -xincp;\n                nodep += PI;\n                argpp -= PI;\n            }\n            if (ep < 0.0 || ep > 1.0) {\n                satrec.error = Sgp4ErrorCode.PERT_ELEMENTS_INVALID;\n                return { position: false, velocity: false };\n            }\n        }\n        //  -------------------- long period periodics ------------------\n        if (satrec.method === Sgp4Methods.DEEP_SPACE) {\n            sinip = Math.sin(xincp);\n            cosip = Math.cos(xincp);\n            satrec.aycof = -0.5 * j3oj2 * sinip;\n            //  Sgp4fix for divide by zero for xincp = 180 deg\n            if (Math.abs(cosip + 1.0) > 1.5e-12) {\n                satrec.xlcof = (-0.25 * j3oj2 * sinip * (3.0 + 5.0 * cosip)) / (1.0 + cosip);\n            }\n            else {\n                satrec.xlcof = (-0.25 * j3oj2 * sinip * (3.0 + 5.0 * cosip)) / temp4;\n            }\n        }\n        const axnl = ep * Math.cos(argpp);\n        let temp = 1.0 / (am * (1.0 - ep * ep));\n        const aynl = ep * Math.sin(argpp) + temp * satrec.aycof;\n        const xl = mp + argpp + nodep + temp * satrec.xlcof * axnl;\n        // --------------------- solve kepler's equation ---------------\n        const u = (xl - nodep) % TAU;\n        let eo1 = u;\n        let tem5 = 9999.9;\n        let ktr = 1;\n        /*\n         *    Sgp4fix for kepler iteration\n         *    the following iteration needs better limits on corrections\n         */\n        let coseo1 = 0;\n        let sineo1 = 0;\n        while (Math.abs(tem5) >= 1.0e-12 && ktr <= 10) {\n            sineo1 = Math.sin(eo1);\n            coseo1 = Math.cos(eo1);\n            tem5 = 1.0 - coseo1 * axnl - sineo1 * aynl;\n            tem5 = (u - aynl * coseo1 + axnl * sineo1 - eo1) / tem5;\n            if (Math.abs(tem5) >= 0.95) {\n                if (tem5 > 0.0) {\n                    tem5 = 0.95;\n                }\n                else {\n                    tem5 = -0.95;\n                }\n            }\n            eo1 += tem5;\n            ktr += 1;\n        }\n        //  ------------- short period preliminary quantities -----------\n        const ecose = axnl * coseo1 + aynl * sineo1;\n        const esine = axnl * sineo1 - aynl * coseo1;\n        const el2 = axnl * axnl + aynl * aynl;\n        const pl = am * (1.0 - el2);\n        if (pl < 0.0) {\n            satrec.error = Sgp4ErrorCode.SEMI_LATUS_RECTUM_NEGATIVE;\n            return { position: false, velocity: false };\n        }\n        const rl = am * (1.0 - ecose);\n        const rdotl = (Math.sqrt(am) * esine) / rl;\n        const rvdotl = Math.sqrt(pl) / rl;\n        const betal = Math.sqrt(1.0 - el2);\n        temp = esine / (1.0 + betal);\n        const sinu = (am / rl) * (sineo1 - aynl - axnl * temp);\n        const cosu = (am / rl) * (coseo1 - axnl + aynl * temp);\n        let su = Math.atan2(sinu, cosu);\n        const sin2u = (cosu + cosu) * sinu;\n        const cos2u = 1.0 - 2.0 * sinu * sinu;\n        temp = 1.0 / pl;\n        const temp1 = 0.5 * j2 * temp;\n        const temp2 = temp1 * temp;\n        // -------------- update for short period periodics ------------\n        if (satrec.method === Sgp4Methods.DEEP_SPACE) {\n            const cosisq = cosip * cosip;\n            satrec.con41 = 3.0 * cosisq - 1.0;\n            satrec.x1mth2 = 1.0 - cosisq;\n            satrec.x7thm1 = 7.0 * cosisq - 1.0;\n        }\n        const mrt = rl * (1.0 - 1.5 * temp2 * betal * satrec.con41) + 0.5 * temp1 * satrec.x1mth2 * cos2u;\n        /** Moved this up to reduce unnecessary computation if you are going to return false anyway */\n        // Sgp4fix for decaying satellites\n        if (mrt < 1.0) {\n            satrec.error = Sgp4ErrorCode.SATELLITE_DECAYED;\n            return {\n                position: false,\n                velocity: false,\n            };\n        }\n        su -= 0.25 * temp2 * satrec.x7thm1 * sin2u;\n        const xnode = nodep + 1.5 * temp2 * cosip * sin2u;\n        const xinc = xincp + 1.5 * temp2 * cosip * sinip * cos2u;\n        const mvt = rdotl - (nm * temp1 * satrec.x1mth2 * sin2u) / xke;\n        const rvdot = rvdotl + (nm * temp1 * (satrec.x1mth2 * cos2u + 1.5 * satrec.con41)) / xke;\n        // --------------------- orientation vectors -------------------\n        const sinsu = Math.sin(su);\n        const cossu = Math.cos(su);\n        const snod = Math.sin(xnode);\n        const cnod = Math.cos(xnode);\n        const sini = Math.sin(xinc);\n        const cosi = Math.cos(xinc);\n        const xmx = -snod * cosi;\n        const xmy = cnod * cosi;\n        const ux = xmx * sinsu + cnod * cossu;\n        const uy = xmy * sinsu + snod * cossu;\n        const uz = sini * sinsu;\n        const vx = xmx * cossu - cnod * sinsu;\n        const vy = xmy * cossu - snod * sinsu;\n        const vz = sini * cossu;\n        // --------- position and velocity (in km and km/sec) ----------\n        const r = {\n            x: mrt * ux * satrec.radiusearthkm,\n            y: mrt * uy * satrec.radiusearthkm,\n            z: mrt * uz * satrec.radiusearthkm,\n        };\n        const v = {\n            x: (mvt * ux + rvdot * vx) * vkmpersec,\n            y: (mvt * uy + rvdot * vy) * vkmpersec,\n            z: (mvt * uz + rvdot * vz) * vkmpersec,\n        };\n        return {\n            position: r,\n            velocity: v,\n        };\n    }\n    /*\n     * -----------------------------------------------------------------------------\n     *\n     *                           function rv2coe_SGP4\n     *\n     *  this function finds the classical orbital elements given the geocentric\n     *    equatorial position and velocity vectors.\n     *\n     *  author        : david vallado                  719-573-2600   21 jun 2002\n     *\n     *  revisions\n     *    vallado     - fix special cases                              5 sep 2002\n     *    vallado     - delete extra check in inclination code        16 oct 2002\n     *    vallado     - add constant file use                         29 jun 2003\n     *    vallado     - add mu                                         2 apr 2007\n     *\n     *  inputs          description                    range / units\n     *    r           - ijk position vector            km\n     *    v           - ijk velocity vector            km / s\n     *    mu          - gravitational parameter        km3 / s2\n     *\n     *  outputs       :\n     *    p           - semilatus rectum               km\n     *    a           - semimajor axis                 km\n     *    ecc         - eccentricity\n     *    incl        - inclination                    0.0  to pi rad\n     *    omega       - right ascension of ascending node    0.0  to 2pi rad\n     *    argp        - argument of perigee            0.0  to 2pi rad\n     *    nu          - true anomaly                   0.0  to 2pi rad\n     *    m           - mean anomaly                   0.0  to 2pi rad\n     *    arglat      - argument of latitude      (ci) 0.0  to 2pi rad\n     *    truelon     - true longitude            (ce) 0.0  to 2pi rad\n     *    lonper      - longitude of periapsis    (ee) 0.0  to 2pi rad\n     *\n     *  locals        :\n     *    hbar        - angular momentum h vector      km2 / s\n     *    ebar        - eccentricity     e vector\n     *    nbar        - line of nodes    n vector\n     *    c1          - v**2 - u/r\n     *    rdotv       - r dot v\n     *    hk          - hk unit vector\n     *    sme         - specfic mechanical energy      km2 / s2\n     *    i           - index\n     *    e           - eccentric, parabolic,\n     *                  hyperbolic anomaly             rad\n     *    temp        - temporary variable\n     *    typeorbit   - type of orbit                  ee, ei, ce, ci\n     *\n     *  coupling      :\n     *    mag         - magnitude of a vector\n     *    cross       - cross product of two vectors\n     *    angle       - find the angle between two vectors\n     *    newtonnu    - find the mean anomaly\n     *\n     *  references    :\n     *    vallado       2013, 113, alg 9, ex 2-5\n     * ---------------------------------------------------------------------------\n     */\n    static rv2coe(r, v, mus) {\n        const nbar = [0, 0, 0];\n        const ebar = [0, 0, 0];\n        let p;\n        let a;\n        let ecc;\n        let incl;\n        let omega;\n        let argp;\n        let nu;\n        let m = 0;\n        let arglat;\n        let truelon;\n        let lonper;\n        let rdotv;\n        let magn;\n        let hk;\n        let sme;\n        let i;\n        /*\n         *  Switch this to an integer msvs seems to have probelms with this and strncpy_s\n         * char typeorbit[2];\n         */\n        let typeorbit;\n        /*\n         * Here\n         * typeorbit = 1 = 'ei'\n         * typeorbit = 2 = 'ce'\n         * typeorbit = 3 = 'ci'\n         * typeorbit = 4 = 'ee'\n         */\n        const halfpi = 0.5 * PI;\n        const small = 0.00000001;\n        const unknown = 999999.1; /** Ootk -- original undefined is illegal in JS */\n        const infinite = 999999.9;\n        // -------------------------  implementation   -----------------\n        const magr = Sgp4.mag_(r);\n        const magv = Sgp4.mag_(v);\n        // ------------------  find h n and e vectors   ----------------\n        const hbar = Sgp4.cross_(r, v);\n        const magh = Sgp4.mag_(hbar);\n        if (magh > small) {\n            nbar[0] = -hbar[1];\n            nbar[1] = hbar[0];\n            nbar[2] = 0.0;\n            magn = Sgp4.mag_(nbar);\n            const c1 = magv * magv - mus / magr;\n            rdotv = Sgp4.dot_(r, v);\n            for (i = 0; i <= 2; i++) {\n                ebar[i] = (c1 * (r[i]) - rdotv * (v[i])) / mus;\n            }\n            ecc = Sgp4.mag_(ebar);\n            // ------------  find a e and semi-latus rectum   ----------\n            sme = magv * magv * 0.5 - mus / magr;\n            if (Math.abs(sme) > small) {\n                a = -mus / (2.0 * sme);\n            }\n            else {\n                a = infinite;\n            }\n            p = (magh * magh) / mus;\n            // -----------------  find inclination   -------------------\n            hk = hbar[2] / magh;\n            incl = Math.acos(hk);\n            /*\n             * --------  determine type of orbit for later use  --------\n             * ------ elliptical, parabolic, hyperbolic inclined -------\n             */\n            typeorbit = 1;\n            if (ecc < small) {\n                // ----------------  circular equatorial ---------------\n                if (incl < small || Math.abs(incl - PI) < small) {\n                    typeorbit = 2;\n                }\n                else {\n                    // --------------  circular inclined ---------------\n                    typeorbit = 3;\n                }\n                // - elliptical, parabolic, hyperbolic equatorial --\n            }\n            else if (incl < small || Math.abs(incl - PI) < small) {\n                typeorbit = 4;\n            }\n            // ----------  find right ascension of the ascending node ------------\n            if (magn > small) {\n                let temp = nbar[0] / magn;\n                if (Math.abs(temp) > 1.0) {\n                    temp = Sgp4.sgn_(temp);\n                }\n                omega = Math.acos(temp);\n                if (nbar[1] < 0.0) {\n                    omega = TAU - omega;\n                }\n            }\n            else {\n                omega = unknown;\n            }\n            // ---------------- find argument of perigee ---------------\n            if (typeorbit === 1) {\n                argp = Sgp4.angle_(nbar, ebar);\n                if (ebar[2] < 0.0) {\n                    argp = TAU - argp;\n                }\n            }\n            else {\n                argp = unknown;\n            }\n            // ------------  find true anomaly at epoch    -------------\n            if (typeorbit === 1 || typeorbit === 4) {\n                nu = Sgp4.angle_(ebar, r);\n                if (rdotv < 0.0) {\n                    nu = TAU - nu;\n                }\n            }\n            else {\n                nu = unknown;\n            }\n            // ----  find argument of latitude - circular inclined -----\n            if (typeorbit === 3) {\n                arglat = Sgp4.angle_(nbar, r);\n                if (r[2] < 0.0) {\n                    arglat = TAU - arglat;\n                }\n                m = arglat;\n            }\n            else {\n                arglat = unknown;\n            }\n            if (ecc > small && typeorbit === 4) {\n                let temp = ebar[0] / ecc;\n                if (Math.abs(temp) > 1.0) {\n                    temp = Sgp4.sgn_(temp);\n                }\n                lonper = Math.acos(temp);\n                if (ebar[1] < 0.0) {\n                    lonper = TAU - lonper;\n                }\n                if (incl > halfpi) {\n                    lonper = TAU - lonper;\n                }\n            }\n            else {\n                lonper = unknown;\n            }\n            // -------- find true longitude - circular equatorial ------\n            if (magr > small && typeorbit === 2) {\n                let temp = r[0] / magr;\n                if (Math.abs(temp) > 1.0) {\n                    temp = Sgp4.sgn_(temp);\n                }\n                truelon = Math.acos(temp);\n                if (r[1] < 0.0) {\n                    truelon = TAU - truelon;\n                }\n                if (incl > halfpi) {\n                    truelon = TAU - truelon;\n                }\n                m = truelon;\n            }\n            else {\n                truelon = unknown;\n            }\n            // ------------ find mean anomaly for all orbits -----------\n            if (typeorbit === 1 || typeorbit === 4) {\n                m = Sgp4.newtonnu_(ecc, nu).m;\n            }\n        }\n        else {\n            p = unknown;\n            a = unknown;\n            ecc = unknown;\n            incl = unknown;\n            omega = unknown;\n            argp = unknown;\n            nu = unknown;\n            m = unknown;\n            arglat = unknown;\n            truelon = unknown;\n            lonper = unknown;\n        }\n        return {\n            p,\n            a,\n            ecc,\n            incl,\n            omega,\n            argp,\n            nu,\n            m,\n            arglat,\n            truelon,\n            lonper,\n        };\n    }\n    /**\n     * Determines the sign of a given number.\n     * @param x - The input number to evaluate.\n     * @returns `-1.0` if the input number is less than `0.0`, otherwise `1.0`.\n     */\n    static sgn_(x) {\n        if (x < 0.0) {\n            return -1.0;\n        }\n        return 1.0;\n    }\n    /**\n     * Computes the hyperbolic sine of a given number.\n     *\n     * The hyperbolic sine is calculated using the formula:\n     * sinh(x) = (e^x - e^(-x)) / 2\n     * @param x - The input number for which to calculate the hyperbolic sine.\n     * @returns The hyperbolic sine of the input number.\n     */\n    static sinh_(x) {\n        return (Math.exp(x) - Math.exp(-x)) / 2;\n    }\n    /*\n     * -----------------------------------------------------------------------------\n     *\n     *                           procedure dpper\n     *\n     *  this procedure provides deep space long period periodic contributions\n     *    to the mean elements.  by design, these periodics are zero at epoch.\n     *    this used to be dscom which included initialization, but it's really a\n     *    recurring function.\n     *\n     *  author        : david vallado                  719-573-2600   28 jun 2005\n     *\n     *  inputs        :\n     *    e3          -\n     *    ee2         -\n     *    peo         -\n     *    pgho        -\n     *    pho         -\n     *    PInco       -\n     *    plo         -\n     *    se2 , se3 , sgh2, sgh3, sgh4, sh2, sh3, si2, si3, sl2, sl3, sl4 -\n     *    t           -\n     *    xh2, xh3, xi2, xi3, xl2, xl3, xl4 -\n     *    zmol        -\n     *    zmos        -\n     *    ep          - eccentricity                           0.0 - 1.0\n     *    inclo       - inclination - needed for lyddane modification\n     *    nodep       - right ascension of ascending node\n     *    argpp       - argument of perigee\n     *    mp          - mean anomaly\n     *\n     *  outputs       :\n     *    ep          - eccentricity                           0.0 - 1.0\n     *    inclp       - inclination\n     *    nodep        - right ascension of ascending node\n     *    argpp       - argument of perigee\n     *    mp          - mean anomaly\n     *\n     *  locals        :\n     *    alfdp       -\n     *    betdp       -\n     *    cosip  , sinip  , cosop  , sinop  ,\n     *    dalf        -\n     *    dbet        -\n     *    dls         -\n     *    f2, f3      -\n     *    pe          -\n     *    pgh         -\n     *    ph          -\n     *    PInc        -\n     *    pl          -\n     *    sel   , ses   , sghl  , sghs  , shl   , shs   , sil   , sinzf , sis   ,\n     *    sll   , sls\n     *    xls         -\n     *    xnoh        -\n     *    zf          -\n     *    zm          -\n     *\n     *  coupling      :\n     *    none.\n     *\n     *  references    :\n     *    hoots, roehrich, norad spacetrack report #3 1980\n     *    hoots, norad spacetrack report #6 1986\n     *    hoots, schumacher and glover 2004\n     *    vallado, crawford, hujsak, kelso  2006\n     * ----------------------------------------------------------------------------\n     */\n    static dpper_(options) {\n        const { e3, ee2, peo, pgho, pho, PInco, plo, se2, se3, sgh2, sgh3, sgh4, sh2, sh3, si2, si3, sl2, sl3, sl4, t, xgh2, xgh3, xgh4, xh2, xh3, xi2, xi3, xl2, xl3, xl4, zmol, zmos, } = options.satrec;\n        let { ep, inclp, nodep, argpp, mp } = options;\n        const { opsmode = Sgp4OpsMode.IMPROVED, init } = options;\n        //  ---------------------- constants -----------------------------\n        /** Ootk -- Some variables imported from outside the class at the top */\n        const zns = 1.19459e-5;\n        const zes = 0.01675;\n        const znl = 1.5835218e-4;\n        const zel = 0.0549;\n        //  --------------- calculate time varying periodics -----------\n        let zm = zmos + zns * t;\n        // Be sure that the initial call has time set to zero\n        if (init) {\n            zm = zmos;\n        }\n        let zf = zm + 2.0 * zes * Math.sin(zm);\n        let sinzf = Math.sin(zf);\n        let f2 = 0.5 * sinzf * sinzf - 0.25;\n        let f3 = -0.5 * sinzf * Math.cos(zf);\n        const ses = se2 * f2 + se3 * f3;\n        const sis = si2 * f2 + si3 * f3;\n        const sls = sl2 * f2 + sl3 * f3 + sl4 * sinzf;\n        const sghs = sgh2 * f2 + sgh3 * f3 + sgh4 * sinzf;\n        const shs = sh2 * f2 + sh3 * f3;\n        zm = zmol + znl * t;\n        if (init) {\n            zm = zmol;\n        }\n        zf = zm + 2.0 * zel * Math.sin(zm);\n        sinzf = Math.sin(zf);\n        f2 = 0.5 * sinzf * sinzf - 0.25;\n        f3 = -0.5 * sinzf * Math.cos(zf);\n        const sel = ee2 * f2 + e3 * f3;\n        const sil = xi2 * f2 + xi3 * f3;\n        const sll = xl2 * f2 + xl3 * f3 + xl4 * sinzf;\n        const sghl = xgh2 * f2 + xgh3 * f3 + xgh4 * sinzf;\n        const shll = xh2 * f2 + xh3 * f3;\n        let pe = ses + sel;\n        let PInc = sis + sil;\n        let pl = sls + sll;\n        let pgh = sghs + sghl;\n        let ph = shs + shll;\n        if (!init) {\n            pe -= peo;\n            PInc -= PInco;\n            pl -= plo;\n            pgh -= pgho;\n            ph -= pho;\n            inclp += PInc;\n            ep += pe;\n            const sinip = Math.sin(inclp);\n            const cosip = Math.cos(inclp);\n            /* ----------------- apply periodics directly ------------ */\n            /*\n             * Sgp4fix for lyddane choice\n             * strn3 used original inclination - this is technically feasible\n             * gsfc used perturbed inclination - also technically feasible\n             * probably best to readjust the 0.2 limit value and limit discontinuity\n             * 0.2 rad = 11.45916 deg\n             * use next line for original strn3 approach and original inclination\n             * if (inclo >= 0.2)\n             * use next line for gsfc version and perturbed inclination\n             */\n            if (inclp >= 0.2) {\n                ph /= sinip;\n                pgh -= cosip * ph;\n                argpp += pgh;\n                nodep += ph;\n                mp += pl;\n            }\n            else {\n                //  ---- apply periodics with lyddane modification ----\n                const sinop = Math.sin(nodep);\n                const cosop = Math.cos(nodep);\n                let alfdp = sinip * sinop;\n                let betdp = sinip * cosop;\n                const dalf = ph * cosop + PInc * cosip * sinop;\n                const dbet = -ph * sinop + PInc * cosip * cosop;\n                alfdp += dalf;\n                betdp += dbet;\n                nodep %= TAU;\n                /*\n                 *  Sgp4fix for afspc written intrinsic functions\n                 *  nodep used without a trigonometric function ahead\n                 */\n                /* istanbul ignore next */\n                if (nodep < 0.0 && opsmode === 'a') {\n                    nodep += TAU;\n                }\n                let xls = mp + argpp + cosip * nodep;\n                const dls = pl + pgh - PInc * nodep * sinip;\n                xls += dls;\n                const xnoh = nodep;\n                nodep = Math.atan2(alfdp, betdp);\n                /*\n                 *  Sgp4fix for afspc written intrinsic functions\n                 *  nodep used without a trigonometric function ahead\n                 */\n                /* istanbul ignore next */\n                if (nodep < 0.0 && opsmode === 'a') {\n                    nodep += TAU;\n                }\n                if (Math.abs(xnoh - nodep) > PI) {\n                    /* istanbul ignore next */\n                    if (nodep < xnoh) {\n                        nodep += TAU;\n                    }\n                    else {\n                        nodep -= TAU;\n                    }\n                }\n                mp += pl;\n                argpp = xls - mp - cosip * nodep;\n            }\n        } // If !init\n        return {\n            ep,\n            inclp,\n            nodep,\n            argpp,\n            mp,\n        };\n    }\n    /*\n     *-----------------------------------------------------------------------------\n     *\n     *                           procedure dscom\n     *\n     *  this procedure provides deep space common items used by both the secular\n     *    and periodics subroutines.  input is provided as shown. this routine\n     *    used to be called dpper, but the functions inside weren't well organized.\n     *\n     *  author        : david vallado                  719-573-2600   28 jun 2005\n     *\n     *  inputs        :\n     *    epoch       -\n     *    ep          - eccentricity\n     *    argpp       - argument of perigee\n     *    tc          -\n     *    inclp       - inclination\n     *    nodep       - right ascension of ascending node\n     *    np          - mean motion\n     *\n     *  outputs       :\n     *    sinim  , cosim  , sinomm , cosomm , snodm  , cnodm\n     *    day         -\n     *    e3          -\n     *    ee2         -\n     *    em          - eccentricity\n     *    emsq        - eccentricity squared\n     *    gam         -\n     *    peo         -\n     *    pgho        -\n     *    pho         -\n     *    PInco       -\n     *    plo         -\n     *    rtemsq      -\n     *    se2, se3         -\n     *    sgh2, sgh3, sgh4        -\n     *    sh2, sh3, si2, si3, sl2, sl3, sl4         -\n     *    s1, s2, s3, s4, s5, s6, s7          -\n     *    ss1, ss2, ss3, ss4, ss5, ss6, ss7, sz1, sz2, sz3         -\n     *    sz11, sz12, sz13, sz21, sz22, sz23, sz31, sz32, sz33        -\n     *    xgh2, xgh3, xgh4, xh2, xh3, xi2, xi3, xl2, xl3, xl4         -\n     *    nm          - mean motion\n     *    z1, z2, z3, z11, z12, z13, z21, z22, z23, z31, z32, z33         -\n     *    zmol        -\n     *    zmos        -\n     *\n     *  locals        :\n     *    a1, a2, a3, a4, a5, a6, a7, a8, a9, a10         -\n     *    betasq      -\n     *    cc          -\n     *    ctem, stem        -\n     *    x1, x2, x3, x4, x5, x6, x7, x8          -\n     *    xnodce      -\n     *    xnoi        -\n     *    zcosg  , zsing  , zcosgl , zsingl , zcosh  , zsinh  , zcoshl , zsinhl ,\n     *    zcosi  , zsini  , zcosil , zsinil ,\n     *    zx          -\n     *    zy          -\n     *\n     *  coupling      :\n     *    none.\n     *\n     *  references    :\n     *    hoots, roehrich, norad spacetrack report #3 1980\n     *    hoots, norad spacetrack report #6 1986\n     *    hoots, schumacher and glover 2004\n     *    vallado, crawford, hujsak, kelso  2006\n     *----------------------------------------------------------------------------\n     */\n    static dscom_(options) {\n        const { epoch, ep, argpp, tc, inclp, nodep, np } = options;\n        // -------------------------- constants -------------------------\n        /** Ootk -- Some variables imported from outside the class at the top */\n        const zes = 0.01675;\n        const zel = 0.0549;\n        const c1ss = 2.9864797e-6;\n        const c1l = 4.7968065e-7;\n        const zsinis = 0.39785416;\n        const zcosis = 0.91744867;\n        const zcosgs = 0.1945905;\n        const zsings = -0.98088458;\n        //  --------------------- local variables ------------------------\n        let s1 = 0, s2 = 0, s3 = 0, s4 = 0, s5 = 0, s6 = 0, s7 = 0, ss1 = 0, ss2 = 0, ss3 = 0, ss4 = 0, ss5 = 0, ss6 = 0, ss7 = 0, sz1 = 0, sz11 = 0, sz12 = 0, sz13 = 0, sz2 = 0, sz21 = 0, sz22 = 0, sz23 = 0, sz3 = 0, sz31 = 0, sz32 = 0, sz33 = 0, z1 = 0, z11 = 0, z12 = 0, z13 = 0, z2 = 0, z21 = 0, z22 = 0, z23 = 0, z3 = 0, z31 = 0, z32 = 0, z33 = 0;\n        const nm = np;\n        const em = ep;\n        const snodm = Math.sin(nodep);\n        const cnodm = Math.cos(nodep);\n        const sinomm = Math.sin(argpp);\n        const cosomm = Math.cos(argpp);\n        const sinim = Math.sin(inclp);\n        const cosim = Math.cos(inclp);\n        const emsq = em * em;\n        const betasq = 1.0 - emsq;\n        const rtemsq = Math.sqrt(betasq);\n        //  ----------------- initialize lunar solar terms ---------------\n        const peo = 0.0;\n        const PInco = 0.0;\n        const plo = 0.0;\n        const pgho = 0.0;\n        const pho = 0.0;\n        const day = epoch + 18261.5 + tc / 1440.0;\n        const xnodce = (4.523602 - 9.2422029e-4 * day) % TAU;\n        const stem = Math.sin(xnodce);\n        const ctem = Math.cos(xnodce);\n        const zcosil = 0.91375164 - 0.03568096 * ctem;\n        const zsinil = Math.sqrt(1.0 - zcosil * zcosil);\n        const zsinhl = (0.089683511 * stem) / zsinil;\n        const zcoshl = Math.sqrt(1.0 - zsinhl * zsinhl);\n        const gam = 5.8351514 + 0.001944368 * day;\n        let zx = (0.39785416 * stem) / zsinil;\n        const zy = zcoshl * ctem + 0.91744867 * zsinhl * stem;\n        zx = Math.atan2(zx, zy);\n        zx += gam - xnodce;\n        const zcosgl = Math.cos(zx);\n        const zsingl = Math.sin(zx);\n        //  ------------------------- do solar terms ---------------------\n        let zcosg = zcosgs;\n        let zsing = zsings;\n        let zcosi = zcosis;\n        let zsini = zsinis;\n        let zcosh = cnodm;\n        let zsinh = snodm;\n        let cc = c1ss;\n        const xnoi = 1.0 / nm;\n        for (let lsflg = 1; lsflg <= 2; lsflg++) {\n            const a1 = zcosg * zcosh + zsing * zcosi * zsinh;\n            const a3 = -zsing * zcosh + zcosg * zcosi * zsinh;\n            const a7 = -zcosg * zsinh + zsing * zcosi * zcosh;\n            const a8 = zsing * zsini;\n            const a9 = zsing * zsinh + zcosg * zcosi * zcosh;\n            const a10 = zcosg * zsini;\n            const a2 = cosim * a7 + sinim * a8;\n            const a4 = cosim * a9 + sinim * a10;\n            const a5 = -sinim * a7 + cosim * a8;\n            const a6 = -sinim * a9 + cosim * a10;\n            const x1 = a1 * cosomm + a2 * sinomm;\n            const x2 = a3 * cosomm + a4 * sinomm;\n            const x3 = -a1 * sinomm + a2 * cosomm;\n            const x4 = -a3 * sinomm + a4 * cosomm;\n            const x5 = a5 * sinomm;\n            const x6 = a6 * sinomm;\n            const x7 = a5 * cosomm;\n            const x8 = a6 * cosomm;\n            z31 = 12.0 * x1 * x1 - 3.0 * x3 * x3;\n            z32 = 24.0 * x1 * x2 - 6.0 * x3 * x4;\n            z33 = 12.0 * x2 * x2 - 3.0 * x4 * x4;\n            z1 = 3.0 * (a1 * a1 + a2 * a2) + z31 * emsq;\n            z2 = 6.0 * (a1 * a3 + a2 * a4) + z32 * emsq;\n            z3 = 3.0 * (a3 * a3 + a4 * a4) + z33 * emsq;\n            z11 = -6.0 * a1 * a5 + emsq * (-24.0 * x1 * x7 - 6.0 * x3 * x5);\n            z12 = -6.0 * (a1 * a6 + a3 * a5) + emsq * (-24.0 * (x2 * x7 + x1 * x8) + -6.0 * (x3 * x6 + x4 * x5));\n            z13 = -6.0 * a3 * a6 + emsq * (-24.0 * x2 * x8 - 6.0 * x4 * x6);\n            z21 = 6.0 * a2 * a5 + emsq * (24.0 * x1 * x5 - 6.0 * x3 * x7);\n            z22 = 6.0 * (a4 * a5 + a2 * a6) + emsq * (24.0 * (x2 * x5 + x1 * x6) - 6.0 * (x4 * x7 + x3 * x8));\n            z23 = 6.0 * a4 * a6 + emsq * (24.0 * x2 * x6 - 6.0 * x4 * x8);\n            z1 = z1 + z1 + betasq * z31;\n            z2 = z2 + z2 + betasq * z32;\n            z3 = z3 + z3 + betasq * z33;\n            s3 = cc * xnoi;\n            s2 = (-0.5 * s3) / rtemsq;\n            s4 = s3 * rtemsq;\n            s1 = -15.0 * em * s4;\n            s5 = x1 * x3 + x2 * x4;\n            s6 = x2 * x3 + x1 * x4;\n            s7 = x2 * x4 - x1 * x3;\n            //  ----------------------- do lunar terms -------------------\n            if (lsflg === 1) {\n                ss1 = s1;\n                ss2 = s2;\n                ss3 = s3;\n                ss4 = s4;\n                ss5 = s5;\n                ss6 = s6;\n                ss7 = s7;\n                sz1 = z1;\n                sz2 = z2;\n                sz3 = z3;\n                sz11 = z11;\n                sz12 = z12;\n                sz13 = z13;\n                sz21 = z21;\n                sz22 = z22;\n                sz23 = z23;\n                sz31 = z31;\n                sz32 = z32;\n                sz33 = z33;\n                zcosg = zcosgl;\n                zsing = zsingl;\n                zcosi = zcosil;\n                zsini = zsinil;\n                zcosh = zcoshl * cnodm + zsinhl * snodm;\n                zsinh = snodm * zcoshl - cnodm * zsinhl;\n                cc = c1l;\n            }\n        }\n        const zmol = (4.7199672 + (0.2299715 * day - gam)) % TAU;\n        const zmos = (6.2565837 + 0.017201977 * day) % TAU;\n        //  ------------------------ do solar terms ----------------------\n        const se2 = 2.0 * ss1 * ss6;\n        const se3 = 2.0 * ss1 * ss7;\n        const si2 = 2.0 * ss2 * sz12;\n        const si3 = 2.0 * ss2 * (sz13 - sz11);\n        const sl2 = -2.0 * ss3 * sz2;\n        const sl3 = -2.0 * ss3 * (sz3 - sz1);\n        const sl4 = -2.0 * ss3 * (-21.0 - 9.0 * emsq) * zes;\n        const sgh2 = 2.0 * ss4 * sz32;\n        const sgh3 = 2.0 * ss4 * (sz33 - sz31);\n        const sgh4 = -18.0 * ss4 * zes;\n        const sh2 = -2.0 * ss2 * sz22;\n        const sh3 = -2.0 * ss2 * (sz23 - sz21);\n        //  ------------------------ do lunar terms ----------------------\n        const ee2 = 2.0 * s1 * s6;\n        const e3 = 2.0 * s1 * s7;\n        const xi2 = 2.0 * s2 * z12;\n        const xi3 = 2.0 * s2 * (z13 - z11);\n        const xl2 = -2.0 * s3 * z2;\n        const xl3 = -2.0 * s3 * (z3 - z1);\n        const xl4 = -2.0 * s3 * (-21.0 - 9.0 * emsq) * zel;\n        const xgh2 = 2.0 * s4 * z32;\n        const xgh3 = 2.0 * s4 * (z33 - z31);\n        const xgh4 = -18.0 * s4 * zel;\n        const xh2 = -2.0 * s2 * z22;\n        const xh3 = -2.0 * s2 * (z23 - z21);\n        return {\n            snodm,\n            cnodm,\n            sinim,\n            cosim,\n            sinomm,\n            cosomm,\n            day,\n            e3,\n            ee2,\n            em,\n            emsq,\n            gam,\n            peo,\n            pgho,\n            pho,\n            PInco,\n            plo,\n            rtemsq,\n            se2,\n            se3,\n            sgh2,\n            sgh3,\n            sgh4,\n            sh2,\n            sh3,\n            si2,\n            si3,\n            sl2,\n            sl3,\n            sl4,\n            s1,\n            s2,\n            s3,\n            s4,\n            s5,\n            s6,\n            s7,\n            ss1,\n            ss2,\n            ss3,\n            ss4,\n            ss5,\n            ss6,\n            ss7,\n            sz1,\n            sz2,\n            sz3,\n            sz11,\n            sz12,\n            sz13,\n            sz21,\n            sz22,\n            sz23,\n            sz31,\n            sz32,\n            sz33,\n            xgh2,\n            xgh3,\n            xgh4,\n            xh2,\n            xh3,\n            xi2,\n            xi3,\n            xl2,\n            xl3,\n            xl4,\n            nm,\n            z1,\n            z2,\n            z3,\n            z11,\n            z12,\n            z13,\n            z21,\n            z22,\n            z23,\n            z31,\n            z32,\n            z33,\n            zmol,\n            zmos,\n        };\n    }\n    /*\n     *-----------------------------------------------------------------------------\n     *\n     *                           procedure dsinit\n     *\n     *  this procedure provides deep space contributions to mean motion dot due\n     *    to geopotential resonance with half day and one day orbits.\n     *\n     *  author        : david vallado                  719-573-2600   28 jun 2005\n     *\n     *  inputs        :\n     *    cosim, sinim-\n     *    emsq        - eccentricity squared\n     *    argpo       - argument of perigee\n     *    s1, s2, s3, s4, s5      -\n     *    ss1, ss2, ss3, ss4, ss5 -\n     *    sz1, sz3, sz11, sz13, sz21, sz23, sz31, sz33 -\n     *    t           - time\n     *    tc          -\n     *    gsto        - greenwich sidereal time                   rad\n     *    mo          - mean anomaly\n     *    mdot        - mean anomaly dot (rate)\n     *    no          - mean motion\n     *    nodeo       - right ascension of ascending node\n     *    nodedot     - right ascension of ascending node dot (rate)\n     *    xPIdot      -\n     *    z1, z3, z11, z13, z21, z23, z31, z33 -\n     *    eccm        - eccentricity\n     *    argpm       - argument of perigee\n     *    inclm       - inclination\n     *    mm          - mean anomaly\n     *    xn          - mean motion\n     *    nodem       - right ascension of ascending node\n     *\n     *  outputs       :\n     *    em          - eccentricity\n     *    argpm       - argument of perigee\n     *    inclm       - inclination\n     *    mm          - mean anomaly\n     *    nm          - mean motion\n     *    nodem       - right ascension of ascending node\n     *    irez        - flag for resonance           0-none, 1-one day, 2-half day\n     *    atime       -\n     *    d2201, d2211, d3210, d3222, d4410, d4422, d5220, d5232, d5421, d5433    -\n     *    dedt        -\n     *    didt        -\n     *    dmdt        -\n     *    dndt        -\n     *    dnodt       -\n     *    domdt       -\n     *    del1, del2, del3        -\n     *    ses  , sghl , sghs , sgs  , shl  , shs  , sis  , sls\n     *    theta       -\n     *    xfact       -\n     *    xlamo       -\n     *    xli         -\n     *    xni\n     *\n     *  locals        :\n     *    ainv2       -\n     *    aonv        -\n     *    cosisq      -\n     *    eoc         -\n     *    f220, f221, f311, f321, f322, f330, f441, f442, f522, f523, f542, f543  -\n     *    g200, g201, g211, g300, g310, g322, g410, g422, g520, g521, g532, g533  -\n     *    sini2       -\n     *    temp        -\n     *    temp1       -\n     *    theta       -\n     *    xno2        -\n     *\n     *  coupling      :\n     *    getgravconst\n     *\n     *  references    :\n     *    hoots, roehrich, norad spacetrack report #3 1980\n     *    hoots, norad spacetrack report #6 1986\n     *    hoots, schumacher and glover 2004\n     *    vallado, crawford, hujsak, kelso  2006\n     *----------------------------------------------------------------------------\n     */\n    static dsinit_(options) {\n        /*\n         * Sgp4fix just send in xke as a constant and eliminate getgravconst call\n         * gravconsttype whichconst,\n         */\n        const { xke, cosim, argpo, s1, s2, s3, s4, s5, sinim, ss1, ss2, ss3, ss4, ss5, sz1, sz3, sz11, sz13, sz21, sz23, sz31, sz33, t, tc, gsto, mo, mdot, no, nodeo, nodedot, xPIdot, z1, z3, z11, z13, z21, z23, z31, z33, ecco, eccsq, } = options;\n        let { emsq, em, argpm, inclm, mm, nm, nodem, atime, d2201, d2211, d3210, d3222, d4410, d4422, d5220, d5232, d5421, d5433, del1, del2, del3, xfact, xlamo, xli, xni, } = options;\n        /* --------------------- local variables ------------------------ */\n        /** Ootk -- Some variables imported from outside the class at the top */\n        const q22 = 1.7891679e-6;\n        const q31 = 2.1460748e-6;\n        const q33 = 2.2123015e-7;\n        const root22 = 1.7891679e-6;\n        const root44 = 7.3636953e-9;\n        const root54 = 2.1765803e-9;\n        const rptim = 4.37526908801129966e-3; // Equates to 7.29211514668855e-5 rad/sec\n        const root32 = 3.7393792e-7;\n        const root52 = 1.1428639e-7;\n        const x2o3 = 2.0 / 3.0;\n        const znl = 1.5835218e-4;\n        const zns = 1.19459e-5;\n        /*\n         * Sgp4fix identify constants and allow alternate values\n         * just xke is used here so pass it in rather than have multiple calls\n         * getgravconst( whichconst, tumin, mu, radiusearthkm, xke, j2, j3, j4, j3oj2 );\n         */\n        // -------------------- deep space initialization ------------\n        let irez = 0;\n        if (nm < 0.0052359877 && nm > 0.0034906585) {\n            irez = 1;\n        }\n        if (nm >= 8.26e-3 && nm <= 9.24e-3 && em >= 0.5) {\n            irez = 2;\n        }\n        // ------------------------ do solar terms -------------------\n        const ses = ss1 * zns * ss5;\n        const sis = ss2 * zns * (sz11 + sz13);\n        const sls = -zns * ss3 * (sz1 + sz3 - 14.0 - 6.0 * emsq);\n        const sghs = ss4 * zns * (sz31 + sz33 - 6.0);\n        let shs = -zns * ss2 * (sz21 + sz23);\n        // Sgp4fix for 180 deg incl\n        if (inclm < 5.2359877e-2 || inclm > PI - 5.2359877e-2) {\n            shs = 0.0;\n        }\n        if (sinim !== 0.0) {\n            shs /= sinim;\n        }\n        const sgs = sghs - cosim * shs;\n        // ------------------------- do lunar terms ------------------\n        const dedt = ses + s1 * znl * s5;\n        const didt = sis + s2 * znl * (z11 + z13);\n        const dmdt = sls - znl * s3 * (z1 + z3 - 14.0 - 6.0 * emsq);\n        const sghl = s4 * znl * (z31 + z33 - 6.0);\n        let shll = -znl * s2 * (z21 + z23);\n        // Sgp4fix for 180 deg incl\n        if (inclm < 5.2359877e-2 || inclm > PI - 5.2359877e-2) {\n            shll = 0.0;\n        }\n        let domdt = sgs + sghl;\n        let dnodt = shs;\n        if (sinim !== 0.0) {\n            domdt -= (cosim / sinim) * shll;\n            dnodt += shll / sinim;\n        }\n        // ----------- calculate deep space resonance effects --------\n        const dndt = 0.0;\n        const theta = (gsto + tc * rptim) % TAU;\n        em += dedt * t;\n        inclm += didt * t;\n        argpm += domdt * t;\n        nodem += dnodt * t;\n        mm += dmdt * t;\n        /*\n         * Sgp4fix for negative inclinations\n         * the following if statement should be commented out\n         * if (inclm < 0.0)\n         * {\n         *   inclm  = -inclm;\n         *   argpm  = argpm - PI;\n         *   nodem = nodem + PI;\n         * }\n         */\n        // -------------- initialize the resonance terms -------------\n        if (irez !== 0) {\n            const aonv = (nm / xke) ** x2o3;\n            // ---------- geopotential resonance for 12 hour orbits ------\n            if (irez === 2) {\n                const cosisq = cosim * cosim;\n                const emo = em;\n                em = ecco;\n                const emsqo = emsq;\n                emsq = eccsq;\n                const eoc = em * emsq;\n                const g201 = -0.306 - (em - 0.64) * 0.44;\n                let g211, g310, g322, g410, g422, g520, g521, g532, g533;\n                if (em <= 0.65) {\n                    g211 = 3.616 - 13.247 * em + 16.29 * emsq;\n                    g310 = -19.302 + 117.39 * em - 228.419 * emsq + 156.591 * eoc;\n                    g322 = -18.9068 + 109.7927 * em - 214.6334 * emsq + 146.5816 * eoc;\n                    g410 = -41.122 + 242.694 * em - 471.094 * emsq + 313.953 * eoc;\n                    g422 = -146.407 + 841.88 * em - 1629.014 * emsq + 1083.435 * eoc;\n                    g520 = -532.114 + 3017.977 * em - 5740.032 * emsq + 3708.276 * eoc;\n                }\n                else {\n                    g211 = -72.099 + 331.819 * em - 508.738 * emsq + 266.724 * eoc;\n                    g310 = -346.844 + 1582.851 * em - 2415.925 * emsq + 1246.113 * eoc;\n                    g322 = -342.585 + 1554.908 * em - 2366.899 * emsq + 1215.972 * eoc;\n                    g410 = -1052.797 + 4758.686 * em - 7193.992 * emsq + 3651.957 * eoc;\n                    g422 = -3581.69 + 16178.11 * em - 24462.77 * emsq + 12422.52 * eoc;\n                    if (em > 0.715) {\n                        g520 = -5149.66 + 29936.92 * em - 54087.36 * emsq + 31324.56 * eoc;\n                    }\n                    else {\n                        g520 = 1464.74 - 4664.75 * em + 3763.64 * emsq;\n                    }\n                }\n                if (em < 0.7) {\n                    g533 = -919.2277 + 4988.61 * em - 9064.77 * emsq + 5542.21 * eoc;\n                    g521 = -822.71072 + 4568.6173 * em - 8491.4146 * emsq + 5337.524 * eoc;\n                    g532 = -853.666 + 4690.25 * em - 8624.77 * emsq + 5341.4 * eoc;\n                }\n                else {\n                    g533 = -37995.78 + 161616.52 * em - 229838.2 * emsq + 109377.94 * eoc;\n                    g521 = -51752.104 + 218913.95 * em - 309468.16 * emsq + 146349.42 * eoc;\n                    g532 = -40023.88 + 170470.89 * em - 242699.48 * emsq + 115605.82 * eoc;\n                }\n                const sini2 = sinim * sinim;\n                const f220 = 0.75 * (1.0 + 2.0 * cosim + cosisq);\n                const f221 = 1.5 * sini2;\n                const f321 = 1.875 * sinim * (1.0 - 2.0 * cosim - 3.0 * cosisq);\n                const f322 = -1.875 * sinim * (1.0 + 2.0 * cosim - 3.0 * cosisq);\n                const f441 = 35.0 * sini2 * f220;\n                const f442 = 39.375 * sini2 * sini2;\n                const f522 = 9.84375 *\n                    sinim *\n                    (sini2 * (1.0 - 2.0 * cosim - 5.0 * cosisq) + 0.33333333 * (-2.0 + 4.0 * cosim + 6.0 * cosisq));\n                const f523 = sinim *\n                    (4.92187512 * sini2 * (-2.0 - 4.0 * cosim + 10.0 * cosisq) + 6.56250012 * (1.0 + 2.0 * cosim - 3.0 * cosisq));\n                const f542 = 29.53125 * sinim * (2.0 - 8.0 * cosim + cosisq * (-12.0 + 8.0 * cosim + 10.0 * cosisq));\n                const f543 = 29.53125 * sinim * (-2.0 - 8.0 * cosim + cosisq * (12.0 + 8.0 * cosim - 10.0 * cosisq));\n                const xno2 = nm * nm;\n                const ainv2 = aonv * aonv;\n                let temp1 = 3.0 * xno2 * ainv2;\n                let temp = temp1 * root22;\n                d2201 = temp * f220 * g201;\n                d2211 = temp * f221 * g211;\n                temp1 *= aonv;\n                temp = temp1 * root32;\n                d3210 = temp * f321 * g310;\n                d3222 = temp * f322 * g322;\n                temp1 *= aonv;\n                temp = 2.0 * temp1 * root44;\n                d4410 = temp * f441 * g410;\n                d4422 = temp * f442 * g422;\n                temp1 *= aonv;\n                temp = temp1 * root52;\n                d5220 = temp * f522 * g520;\n                d5232 = temp * f523 * g532;\n                temp = 2.0 * temp1 * root54;\n                d5421 = temp * f542 * g521;\n                d5433 = temp * f543 * g533;\n                xlamo = (mo + nodeo + nodeo - (theta + theta)) % TAU;\n                xfact = mdot + dmdt + 2.0 * (nodedot + dnodt - rptim) - no;\n                em = emo;\n                emsq = emsqo;\n            }\n            //  ---------------- synchronous resonance terms --------------\n            if (irez === 1) {\n                const g200 = 1.0 + emsq * (-2.5 + 0.8125 * emsq);\n                const g310 = 1.0 + 2.0 * emsq;\n                const g300 = 1.0 + emsq * (-6.0 + 6.60937 * emsq);\n                const f220 = 0.75 * (1.0 + cosim) * (1.0 + cosim);\n                const f311 = 0.9375 * sinim * sinim * (1.0 + 3.0 * cosim) - 0.75 * (1.0 + cosim);\n                let f330 = 1.0 + cosim;\n                f330 *= 1.875 * f330 * f330;\n                del1 = 3.0 * nm * nm * aonv * aonv;\n                del2 = 2.0 * del1 * f220 * g200 * q22;\n                del3 = 3.0 * del1 * f330 * g300 * q33 * aonv;\n                del1 = del1 * f311 * g310 * q31 * aonv;\n                xlamo = (mo + nodeo + argpo - theta) % TAU;\n                xfact = mdot + xPIdot + dmdt + domdt + dnodt - (no + rptim);\n            }\n            //  ------------ for sgp4, initialize the integrator ----------\n            xli = xlamo;\n            xni = no;\n            atime = 0.0;\n            nm = no + dndt;\n        }\n        return {\n            em,\n            argpm,\n            inclm,\n            mm,\n            nm,\n            nodem,\n            irez,\n            atime,\n            d2201,\n            d2211,\n            d3210,\n            d3222,\n            d4410,\n            d4422,\n            d5220,\n            d5232,\n            d5421,\n            d5433,\n            dedt,\n            didt,\n            dmdt,\n            dndt,\n            dnodt,\n            domdt,\n            del1,\n            del2,\n            del3,\n            xfact,\n            xlamo,\n            xli,\n            xni,\n        };\n    }\n    /*\n     *-----------------------------------------------------------------------------\n     *\n     *                           procedure dspace\n     *\n     *  this procedure provides deep space contributions to mean elements for\n     *    perturbing third body.  these effects have been averaged over one\n     *    revolution of the sun and moon.  for earth resonance effects, the\n     *    effects have been averaged over no revolutions of the satellite.\n     *    (mean motion)\n     *\n     *  author        : david vallado                  719-573-2600   28 jun 2005\n     *\n     *  inputs        :\n     *    d2201, d2211, d3210, d3222, d4410, d4422, d5220, d5232, d5421, d5433 -\n     *    dedt        -\n     *    del1, del2, del3  -\n     *    didt        -\n     *    dmdt        -\n     *    dnodt       -\n     *    domdt       -\n     *    irez        - flag for resonance           0-none, 1-one day, 2-half day\n     *    argpo       - argument of perigee\n     *    argpdot     - argument of perigee dot (rate)\n     *    t           - time\n     *    tc          -\n     *    gsto        - gst\n     *    xfact       -\n     *    xlamo       -\n     *    no          - mean motion\n     *    atime       -\n     *    em          - eccentricity\n     *    ft          -\n     *    argpm       - argument of perigee\n     *    inclm       - inclination\n     *    xli         -\n     *    mm          - mean anomaly\n     *    xni         - mean motion\n     *    nodem       - right ascension of ascending node\n     *\n     *  outputs       :\n     *    atime       -\n     *    em          - eccentricity\n     *    argpm       - argument of perigee\n     *    inclm       - inclination\n     *    xli         -\n     *    mm          - mean anomaly\n     *    xni         -\n     *    nodem       - right ascension of ascending node\n     *    dndt        -\n     *    nm          - mean motion\n     *\n     *  locals        :\n     *    delt        -\n     *    ft          -\n     *    theta       -\n     *    x2li        -\n     *    x2omi       -\n     *    xl          -\n     *    xldot       -\n     *    xnddt       -\n     *    xndt        -\n     *    xomi        -\n     *\n     *  coupling      :\n     *    none        -\n     *\n     *  references    :\n     *    hoots, roehrich, norad spacetrack report #3 1980\n     *    hoots, norad spacetrack report #6 1986\n     *    hoots, schumacher and glover 2004\n     *    vallado, crawford, hujsak, kelso  2006\n     *----------------------------------------------------------------------------\n     */\n    static dspace_(em, argpm, inclm, mm, nodem, nm, satrec) {\n        let { atime, xli, xni, } = satrec;\n        const { dedt, didt, dmdt, dnodt, domdt, irez, d2201, d2211, d3210, d3222, d4410, d4422, d5220, d5232, d5421, d5433, xfact, xlamo, gsto, argpo, t, no, argpdot, del1, del2, del3, } = satrec;\n        //  ----------- calculate deep space resonance effects -----------\n        let dndt = 0.0;\n        const theta = (gsto + t * rptim) % TAU;\n        // Apply time-dependent perturbations\n        em += dedt * t;\n        inclm += didt * t;\n        argpm += domdt * t;\n        nodem += dnodt * t;\n        mm += dmdt * t;\n        if (irez !== 0) {\n            // Simplified deep space resonance handling\n            if (atime === 0.0 || t * atime <= 0.0 || Math.abs(t) < Math.abs(atime)) {\n                atime = 0.0;\n                xni = no;\n                xli = xlamo;\n            }\n            const delt = t > 0.0 ? stepp : stepn;\n            let ft = 0;\n            let x2li = 0;\n            let x2omi = 0;\n            let xldot = 0;\n            let xnddt = 0;\n            let xndt = 0;\n            let xomi = 0;\n            let iretn = true; // Added for do loop\n            while (iretn) {\n                /*\n                 *  ------------------- dot terms calculated -------------\n                 *  ----------- near - synchronous resonance terms -------\n                 */\n                if (irez !== 2) {\n                    xndt =\n                        del1 * Math.sin(xli - fasx2) + del2 * Math.sin(2.0 * (xli - fasx4)) + del3 * Math.sin(3.0 * (xli - fasx6));\n                    xldot = xni + xfact;\n                    xnddt =\n                        del1 * Math.cos(xli - fasx2) +\n                            2.0 * del2 * Math.cos(2.0 * (xli - fasx4)) +\n                            3.0 * del3 * Math.cos(3.0 * (xli - fasx6));\n                    xnddt *= xldot;\n                }\n                else {\n                    // --------- near - half-day resonance terms --------\n                    xomi = argpo + argpdot * atime;\n                    x2omi = xomi + xomi;\n                    x2li = xli + xli;\n                    xndt =\n                        d2201 * Math.sin(x2omi + xli - g22) +\n                            d2211 * Math.sin(xli - g22) +\n                            d3210 * Math.sin(xomi + xli - g32) +\n                            d3222 * Math.sin(-xomi + xli - g32) +\n                            d4410 * Math.sin(x2omi + x2li - g44) +\n                            d4422 * Math.sin(x2li - g44) +\n                            d5220 * Math.sin(xomi + xli - g52) +\n                            d5232 * Math.sin(-xomi + xli - g52) +\n                            d5421 * Math.sin(xomi + x2li - g54) +\n                            d5433 * Math.sin(-xomi + x2li - g54);\n                    xldot = xni + xfact;\n                    xnddt =\n                        d2201 * Math.cos(x2omi + xli - g22) +\n                            d2211 * Math.cos(xli - g22) +\n                            d3210 * Math.cos(xomi + xli - g32) +\n                            d3222 * Math.cos(-xomi + xli - g32) +\n                            d5220 * Math.cos(xomi + xli - g52) +\n                            d5232 * Math.cos(-xomi + xli - g52) +\n                            2.0 *\n                                (d4410 * Math.cos(x2omi + x2li - g44) +\n                                    d4422 * Math.cos(x2li - g44) +\n                                    d5421 * Math.cos(xomi + x2li - g54) +\n                                    d5433 * Math.cos(-xomi + x2li - g54));\n                    xnddt *= xldot;\n                }\n                /*\n                 *  ----------------------- integrator -------------------\n                 *  sgp4fix move end checks to end of routine\n                 */\n                if (Math.abs(t - atime) < stepp) {\n                    ft = t - atime;\n                    iretn = false;\n                }\n                else {\n                    xli += xldot * delt + xndt * step2;\n                    xni += xndt * delt + xnddt * step2;\n                    atime += delt;\n                }\n            }\n            nm = xni + xndt * ft + xnddt * ft * ft * 0.5;\n            const xl = xli + xldot * ft + xndt * ft * ft * 0.5;\n            if (irez !== 1) {\n                mm = xl - 2.0 * nodem + 2.0 * theta;\n                dndt = nm - no;\n            }\n            else {\n                mm = xl - nodem - argpm + theta;\n                dndt = nm - no;\n            }\n            nm = no + dndt;\n        }\n        return [em, argpm, inclm, mm, nodem, nm];\n    }\n    /*\n     * -----------------------------------------------------------------------------\n     *\n     *                           function getgravconst\n     *\n     *  this function gets constants for the propagator. note that mu is identified to\n     *    facilitiate comparisons with newer models. the common useage is wgs72.\n     *\n     *  author        : david vallado                  719-573-2600   21 jul 2006\n     *\n     *  inputs        :\n     *    whichconst  - which set of constants to use  wgs72old, wgs72, wgs84\n     *\n     *  outputs       :\n     *    tumin       - minutes in one time unit\n     *    mu          - earth gravitational parameter\n     *    radiusearthkm - radius of the earth in km\n     *    xke         - reciprocal of tumin\n     *    j2, j3, j4  - un-normalized zonal harmonic values\n     *    j3oj2       - j3 divided by j2\n     *\n     *  locals        :\n     *\n     *  coupling      :\n     *    none\n     *\n     *  references    :\n     *    norad spacetrack report #3\n     *    vallado, crawford, hujsak, kelso  2006\n     * ---------------------------------------------------------------------------\n     */\n    static getgravconst_(whichconst) {\n        let j2, j3, j3oj2, j4, mus, radiusearthkm, tumin, xke;\n        switch (whichconst) {\n            // -- wgs-72 low precision str#3 constants --\n            case 'wgs72old':\n                mus = 398600.79964; // In km3 / s2\n                radiusearthkm = 6378.135; // Km\n                xke = 0.0743669161; // Reciprocal of tumin\n                tumin = 1.0 / xke;\n                j2 = 0.001082616;\n                j3 = -0.00000253881;\n                j4 = -0.00000165597;\n                j3oj2 = j3 / j2;\n                break;\n            // ------------ wgs-72 constants ------------\n            case 'wgs72':\n                mus = 398600.8; // In km3 / s2\n                radiusearthkm = 6378.135; // Km\n                xke = 60.0 / Math.sqrt((radiusearthkm * radiusearthkm * radiusearthkm) / mus);\n                tumin = 1.0 / xke;\n                j2 = 0.001082616;\n                j3 = -0.00000253881;\n                j4 = -0.00000165597;\n                j3oj2 = j3 / j2;\n                break;\n            case 'wgs84':\n                // ------------ wgs-84 constants ------------\n                mus = 398600.5; // In km3 / s2\n                radiusearthkm = 6378.137; // Km\n                xke = 60.0 / Math.sqrt((radiusearthkm * radiusearthkm * radiusearthkm) / mus);\n                tumin = 1.0 / xke;\n                j2 = 0.00108262998905;\n                j3 = -0.00000253215306;\n                j4 = -0.00000161098761;\n                j3oj2 = j3 / j2;\n                break;\n            default:\n                throw new Error(`unknown gravity option ${whichconst}`);\n        }\n        return {\n            tumin,\n            mus,\n            radiusearthkm,\n            xke,\n            j2,\n            j3,\n            j4,\n            j3oj2,\n        };\n    }\n    /*\n     *-----------------------------------------------------------------------------\n     *\n     *                           procedure initl\n     *\n     *  this procedure initializes the sgp4 propagator. all the initialization is\n     *    consolidated here instead of having multiple loops inside other routines.\n     *\n     *  author        : david vallado                  719-573-2600   28 jun 2005\n     *\n     *  inputs        :\n     *    satn        - satellite number - not needed, placed in satrec\n     *    xke         - reciprocal of tumin\n     *    j2          - j2 zonal harmonic\n     *    ecco        - eccentricity                           0.0 - 1.0\n     *    epoch       - epoch time in days from jan 0, 1950. 0 hr\n     *    inclo       - inclination of satellite\n     *    no          - mean motion of satellite\n     *\n     *  outputs       :\n     *    ainv        - 1.0 / a\n     *    ao          - semi major axis\n     *    con41       -\n     *    con42       - 1.0 - 5.0 cos(i)\n     *    cosio       - cosine of inclination\n     *    cosio2      - cosio squared\n     *    eccsq       - eccentricity squared\n     *    method      - flag for deep space                    'd', 'n'\n     *    omeosq      - 1.0 - ecco * ecco\n     *    posq        - semi-parameter squared\n     *    rp          - radius of perigee\n     *    rteosq      - square root of (1.0 - ecco*ecco)\n     *    sinio       - sine of inclination\n     *    gsto        - gst at time of observation               rad\n     *    no          - mean motion of satellite\n     *\n     *  locals        :\n     *    ak          -\n     *    d1          -\n     *    del         -\n     *    adel        -\n     *    po          -\n     *\n     *  coupling      :\n     *    getgravconst- no longer used\n     *    gstime      - find greenwich sidereal time from the julian date\n     *\n     *  references    :\n     *    hoots, roehrich, norad spacetrack report #3 1980\n     *    hoots, norad spacetrack report #6 1986\n     *    hoots, schumacher and glover 2004\n     *    vallado, crawford, hujsak, kelso  2006\n     *----------------------------------------------------------------------------\n     */\n    static initl_(satrec, epoch) {\n        /*\n         * Sgp4fix satn not needed. include in satrec in case needed later\n         * int satn,\n         * sgp4fix just pass in xke and j2\n         * gravconsttype whichconst,\n         */\n        const { operationmode, ecco, inclo, xke, j2 } = satrec;\n        let { no } = satrec;\n        /* --------------------- local variables ------------------------ */\n        const x2o3 = 2.0 / 3.0;\n        // Sgp4fix use old way of finding gst\n        /** Ootk -- Some variables imported from outside the class at the top */\n        /*\n         * ----------------------- earth constants ---------------------\n         * sgp4fix identify constants and allow alternate values\n         * only xke and j2 are used here so pass them in directly\n         * getgravconst( whichconst, tumin, mu, radiusearthkm, xke, j2, j3, j4, j3oj2 )\n         */\n        // ------------- calculate auxillary epoch quantities ----------\n        const eccsq = ecco * ecco;\n        const omeosq = 1.0 - eccsq;\n        const rteosq = Math.sqrt(omeosq);\n        const cosio = Math.cos(inclo);\n        const cosio2 = cosio * cosio;\n        // ------------------ un-kozai the mean motion -----------------\n        const ak = (xke / no) ** x2o3;\n        const d1 = (0.75 * j2 * (3.0 * cosio2 - 1.0)) / (rteosq * omeosq);\n        let delPrime = d1 / (ak * ak);\n        const adel = ak * (1.0 - delPrime * delPrime - delPrime * (1.0 / 3.0 + (134.0 * delPrime * delPrime) / 81.0));\n        delPrime = d1 / (adel * adel);\n        no /= 1.0 + delPrime;\n        const ao = (xke / no) ** x2o3;\n        const sinio = Math.sin(inclo);\n        const po = ao * omeosq;\n        const con42 = 1.0 - 5.0 * cosio2;\n        const con41 = -con42 - cosio2 - cosio2;\n        const ainv = 1.0 / ao;\n        const posq = po * po;\n        const rp = ao * (1.0 - ecco);\n        //  Sgp4fix modern approach to finding sidereal time\n        /** Ootk -- Continue allowing AFSPC mode for SGP4 Validation */\n        let gsto;\n        if (operationmode === Sgp4OpsMode.AFSPC) {\n            /*\n             *  Sgp4fix use old way of finding gst\n             *  count integer number of days from 0 jan 1970\n             */\n            const ts70 = epoch - 7305.0;\n            const ds70 = Math.floor(ts70 + 1.0e-8);\n            const tfrac = ts70 - ds70;\n            //  Find greenwich location at epoch\n            const c1 = 1.72027916940703639e-2;\n            const thgr70 = 1.7321343856509374;\n            const fk5r = 5.07551419432269442e-15;\n            const c1p2p = c1 + TAU;\n            gsto = (thgr70 + c1 * ds70 + c1p2p * tfrac + ts70 * ts70 * fk5r) % TAU;\n            /* istanbul ignore next | This is no longer possible*/\n            if (gsto < 0.0) {\n                gsto += TAU;\n            }\n        }\n        else {\n            const jdut1 = epoch + 2433281.5;\n            const tut1 = (jdut1 - 2451545.0) / 36525.0;\n            gsto = -6.2e-6 * tut1 * tut1 * tut1 + 0.093104 * tut1 * tut1 +\n                (876600.0 * 3600 + 8640184.812866) * tut1 + 67310.54841; // Sec\n            gsto = ((gsto * DEG2RAD) / 240.0) % TAU; // 360/86400 = 1/240, to deg, to rad\n            //  ------------------------ check quadrants ---------------------\n            if (gsto < 0.0) {\n                gsto += TAU;\n            }\n        }\n        return {\n            no,\n            ainv,\n            ao,\n            con41,\n            con42,\n            cosio,\n            cosio2,\n            eccsq,\n            omeosq,\n            posq,\n            rp,\n            rteosq,\n            sinio,\n            gsto,\n        };\n    }\n    /*\n     *-----------------------------------------------------------------------------\n     *\n     *                             procedure sgp4init\n     *\n     *  this procedure initializes variables for sgp4.\n     *\n     *  author        : david vallado                  719-573-2600   28 jun 2005\n     *\n     *  inputs        :\n     *    opsmode     - mode of operation afspc or improved 'a', 'i'\n     *    whichconst  - which set of constants to use  72, 84\n     *    satn        - satellite number\n     *    bstar       - sgp4 type drag coefficient              kg/m2er\n     *    ecco        - eccentricity\n     *    epoch       - epoch time in days from jan 0, 1950. 0 hr\n     *    argpo       - argument of perigee (output if ds)\n     *    inclo       - inclination\n     *    mo          - mean anomaly (output if ds)\n     *    no          - mean motion\n     *    nodeo       - right ascension of ascending node\n     *\n     *  outputs       :\n     *    rec      - common values for subsequent calls\n     *    return code - non-zero on error.\n     *                   1 - mean elements, ecc >= 1.0 or ecc < -0.001 or a < 0.95 er\n     *                   2 - mean motion less than 0.0\n     *                   3 - pert elements, ecc < 0.0  or  ecc > 1.0\n     *                   4 - semi-latus rectum < 0.0\n     *                   5 - epoch elements are sub-orbital\n     *                   6 - satellite has decayed\n     *\n     *  locals        :\n     *    cnodm  , snodm  , cosim  , sinim  , cosomm , sinomm\n     *    cc1sq  , cc2    , cc3\n     *    coef   , coef1\n     *    cosio4      -\n     *    day         -\n     *    dndt        -\n     *    em          - eccentricity\n     *    emsq        - eccentricity squared\n     *    eeta        -\n     *    etasq       -\n     *    gam         -\n     *    argpm       - argument of perigee\n     *    nodem       -\n     *    inclm       - inclination\n     *    mm          - mean anomaly\n     *    nm          - mean motion\n     *    perige      - perigee\n     *    PInvsq      -\n     *    psisq       -\n     *    qzms24      -\n     *    rtemsq      -\n     *    s1, s2, s3, s4, s5, s6, s7          -\n     *    sfour       -\n     *    ss1, ss2, ss3, ss4, ss5, ss6, ss7         -\n     *    sz1, sz2, sz3\n     *    sz11, sz12, sz13, sz21, sz22, sz23, sz31, sz32, sz33        -\n     *    tc          -\n     *    temp        -\n     *    temp1, temp2, temp3       -\n     *    tsi         -\n     *    xPIdot      -\n     *    xhdot1      -\n     *    z1, z2, z3          -\n     *    z11, z12, z13, z21, z22, z23, z31, z32, z33         -\n     *\n     *  coupling      :\n     *    getgravconst-\n     *    initl       -\n     *    dscom       -\n     *    dpper       -\n     *    dsinit      -\n     *    sgp4        -\n     *\n     *  references    :\n     *    hoots, roehrich, norad spacetrack report #3 1980\n     *    hoots, norad spacetrack report #6 1986\n     *    hoots, schumacher and glover 2004\n     *    vallado, crawford, hujsak, kelso  2006\n     *----------------------------------------------------------------------------\n     */\n    static sgp4init_(satrec, options) {\n        const { whichconst = Sgp4GravConstants.wgs72, opsmode = Sgp4OpsMode.IMPROVED, satn = satrec.satnum, epoch, xbstar, xecco, xargpo, xinclo, xndot, xnddot, xmo, xno, xnodeo, } = options;\n        /* ------------------------ initialization --------------------- */\n        /*\n         * Sgp4fix divisor for divide by zero check on inclination\n         * the old check used 1.0 + Math.cos(PI-1.0e-9), but then compared it to\n         * 1.5 e-12, so the threshold was changed to 1.5e-12 for consistency\n         */\n        // ----------- set all near earth variables to zero ------------\n        satrec.isimp = false;\n        satrec.method = Sgp4Methods.NEAR_EARTH;\n        satrec.aycof = 0.0;\n        satrec.con41 = 0.0;\n        satrec.cc1 = 0.0;\n        satrec.cc4 = 0.0;\n        satrec.cc5 = 0.0;\n        satrec.d2 = 0.0;\n        satrec.d3 = 0.0;\n        satrec.d4 = 0.0;\n        satrec.delmo = 0.0;\n        satrec.eta = 0.0;\n        satrec.argpdot = 0.0;\n        satrec.omgcof = 0.0;\n        satrec.sinmao = 0.0;\n        satrec.t = 0.0;\n        satrec.t2cof = 0.0;\n        satrec.t3cof = 0.0;\n        satrec.t4cof = 0.0;\n        satrec.t5cof = 0.0;\n        satrec.x1mth2 = 0.0;\n        satrec.x7thm1 = 0.0;\n        satrec.mdot = 0.0;\n        satrec.nodedot = 0.0;\n        satrec.xlcof = 0.0;\n        satrec.xmcof = 0.0;\n        satrec.nodecf = 0.0;\n        // ----------- set all deep space variables to zero ------------\n        satrec.irez = 0;\n        satrec.d2201 = 0.0;\n        satrec.d2211 = 0.0;\n        satrec.d3210 = 0.0;\n        satrec.d3222 = 0.0;\n        satrec.d4410 = 0.0;\n        satrec.d4422 = 0.0;\n        satrec.d5220 = 0.0;\n        satrec.d5232 = 0.0;\n        satrec.d5421 = 0.0;\n        satrec.d5433 = 0.0;\n        satrec.dedt = 0.0;\n        satrec.del1 = 0.0;\n        satrec.del2 = 0.0;\n        satrec.del3 = 0.0;\n        satrec.didt = 0.0;\n        satrec.dmdt = 0.0;\n        satrec.dnodt = 0.0;\n        satrec.domdt = 0.0;\n        satrec.e3 = 0.0;\n        satrec.ee2 = 0.0;\n        satrec.peo = 0.0;\n        satrec.pgho = 0.0;\n        satrec.pho = 0.0;\n        satrec.PInco = 0.0;\n        satrec.plo = 0.0;\n        satrec.se2 = 0.0;\n        satrec.se3 = 0.0;\n        satrec.sgh2 = 0.0;\n        satrec.sgh3 = 0.0;\n        satrec.sgh4 = 0.0;\n        satrec.sh2 = 0.0;\n        satrec.sh3 = 0.0;\n        satrec.si2 = 0.0;\n        satrec.si3 = 0.0;\n        satrec.sl2 = 0.0;\n        satrec.sl3 = 0.0;\n        satrec.sl4 = 0.0;\n        satrec.gsto = 0.0;\n        satrec.xfact = 0.0;\n        satrec.xgh2 = 0.0;\n        satrec.xgh3 = 0.0;\n        satrec.xgh4 = 0.0;\n        satrec.xh2 = 0.0;\n        satrec.xh3 = 0.0;\n        satrec.xi2 = 0.0;\n        satrec.xi3 = 0.0;\n        satrec.xl2 = 0.0;\n        satrec.xl3 = 0.0;\n        satrec.xl4 = 0.0;\n        satrec.xlamo = 0.0;\n        satrec.zmol = 0.0;\n        satrec.zmos = 0.0;\n        satrec.atime = 0.0;\n        satrec.xli = 0.0;\n        satrec.xni = 0.0;\n        /* ------------------------ earth constants ----------------------- */\n        /*\n         * Sgp4fix identify constants and allow alternate values\n         * this is now the only call for the constants\n         */\n        const gravResults = Sgp4.getgravconst_(whichconst);\n        satrec.tumin = gravResults.tumin;\n        satrec.mus = gravResults.mus;\n        satrec.radiusearthkm = gravResults.radiusearthkm;\n        satrec.xke = gravResults.xke;\n        satrec.j2 = gravResults.j2;\n        satrec.j3 = gravResults.j3;\n        satrec.j4 = gravResults.j4;\n        satrec.j3oj2 = gravResults.j3oj2;\n        satrec.vkmpersec = (satrec.radiusearthkm * satrec.xke) / 60.0;\n        const { j2 } = gravResults;\n        const { j4 } = gravResults;\n        const { xke } = gravResults;\n        const { j3oj2 } = gravResults;\n        // -------------------------------------------------------------------------\n        satrec.error = Sgp4ErrorCode.NO_ERROR;\n        satrec.operationmode = opsmode;\n        // New alpha5 or 9-digit number\n        /**\n         * Ootk -- Using JS code for string manipulation but same effect\n         * Ex. A2525 = 102525\n         * Ex. Z1234 = 351234\n         */\n        satrec.satnum = Tle.convertA5to6Digit(satn);\n        /*\n         * Sgp4fix - note the following variables are also passed directly via satrec.\n         * it is possible to streamline the sgp4init call by deleting the \"x\"\n         * variables, but the user would need to set the satrec.* values first. we\n         * include the additional assignments in case twoline2rv is not used.\n         */\n        satrec.bstar = xbstar;\n        // Sgp4fix allow additional parameters in the struct\n        satrec.ndot = xndot;\n        satrec.nddot = xnddot;\n        satrec.ecco = xecco;\n        satrec.argpo = xargpo;\n        satrec.inclo = xinclo;\n        satrec.mo = xmo;\n        // Sgp4fix rename variables to clarify which mean motion is intended\n        satrec.no = xno;\n        satrec.nodeo = xnodeo;\n        /*\n         * Single averaged mean elements\n         * satrec.am = satrec.em = satrec.im = satrec.Om = satrec.mm = satrec.nm = 0.0;\n         */\n        /*\n         * ------------------------ earth constants -----------------------\n         * sgp4fix identify constants and allow alternate values\n         * getgravconst( whichconst, tumin, mu, radiusearthkm, xke, j2, j3, j4, j3oj2 );\n         */\n        const ss = 78.0 / satrec.radiusearthkm + 1.0;\n        // Sgp4fix use multiply for speed instead of pow\n        const qzms2ttemp = (120.0 - 78.0) / satrec.radiusearthkm;\n        const qzms2t = qzms2ttemp * qzms2ttemp * qzms2ttemp * qzms2ttemp;\n        satrec.init = true;\n        satrec.t = 0.0;\n        // Sgp4fix remove satn as it is not needed in initl\n        const initlResult = Sgp4.initl_(satrec, epoch);\n        const { ao, con42, cosio, cosio2, eccsq, omeosq, posq, rp, rteosq, sinio } = initlResult;\n        satrec.no = initlResult.no;\n        satrec.con41 = initlResult.con41;\n        satrec.gsto = initlResult.gsto;\n        satrec.a = (satrec.no * satrec.tumin) ** (-2.0 / 3.0);\n        satrec.alta = satrec.a * (1.0 + satrec.ecco) - 1.0;\n        satrec.altp = satrec.a * (1.0 - satrec.ecco) - 1.0;\n        satrec.error = Sgp4ErrorCode.NO_ERROR;\n        /*\n         * Sgp4fix remove this check as it is unnecessary\n         * the mrt check in sgp4 handles decaying satellite cases even if the starting\n         * condition is below the surface of te earth\n         * if (rp < 1.0)\n         * {\n         *   printf(\"// *** satn%d epoch elts sub-orbital ***\\n\", satn);\n         *   satrec.error = 5;\n         * }\n         */\n        if (omeosq >= 0.0 || satrec.no >= 0.0) {\n            satrec.isimp = false;\n            if (rp < 220.0 / satrec.radiusearthkm + 1.0) {\n                satrec.isimp = true;\n            }\n            let sfour = ss;\n            let qzms24 = qzms2t;\n            const perigee = (rp - 1.0) * satrec.radiusearthkm;\n            // - for perigees below 156 km, s and qoms2t are altered -\n            if (perigee < 156.0) {\n                sfour = perigee - 78.0;\n                if (perigee < 98.0) {\n                    sfour = 20.0;\n                }\n                // Sgp4fix use multiply for speed instead of pow\n                const qzms24temp = (120.0 - sfour) / satrec.radiusearthkm;\n                qzms24 = qzms24temp * qzms24temp * qzms24temp * qzms24temp;\n                sfour = sfour / satrec.radiusearthkm + 1.0;\n            }\n            const PInvsq = 1.0 / posq;\n            const tsi = 1.0 / (ao - sfour);\n            satrec.eta = ao * satrec.ecco * tsi;\n            const etasq = satrec.eta * satrec.eta;\n            const eeta = satrec.ecco * satrec.eta;\n            const psisq = Math.abs(1.0 - etasq);\n            const coef = qzms24 * tsi ** 4.0;\n            const coef1 = coef / psisq ** 3.5;\n            const cc2 = coef1 *\n                satrec.no *\n                (ao * (1.0 + 1.5 * etasq + eeta * (4.0 + etasq)) +\n                    ((0.375 * j2 * tsi) / psisq) * satrec.con41 * (8.0 + 3.0 * etasq * (8.0 + etasq)));\n            satrec.cc1 = satrec.bstar * cc2;\n            let cc3 = 0.0;\n            if (satrec.ecco > 1.0e-4) {\n                cc3 = (-2.0 * coef * tsi * j3oj2 * satrec.no * sinio) / satrec.ecco;\n            }\n            satrec.x1mth2 = 1.0 - cosio2;\n            satrec.cc4 =\n                2.0 *\n                    satrec.no *\n                    coef1 *\n                    ao *\n                    omeosq *\n                    (satrec.eta * (2.0 + 0.5 * etasq) +\n                        satrec.ecco * (0.5 + 2.0 * etasq) -\n                        ((j2 * tsi) / (ao * psisq)) *\n                            (-3.0 * satrec.con41 * (1.0 - 2.0 * eeta + etasq * (1.5 - 0.5 * eeta)) +\n                                0.75 * satrec.x1mth2 * (2.0 * etasq - eeta * (1.0 + etasq)) * Math.cos(2.0 * satrec.argpo)));\n            satrec.cc5 = 2.0 * coef1 * ao * omeosq * (1.0 + 2.75 * (etasq + eeta) + eeta * etasq);\n            const cosio4 = cosio2 * cosio2;\n            const temp1 = 1.5 * j2 * PInvsq * satrec.no;\n            const temp2 = 0.5 * temp1 * j2 * PInvsq;\n            const temp3 = -0.46875 * j4 * PInvsq * PInvsq * satrec.no;\n            satrec.mdot =\n                satrec.no +\n                    0.5 * temp1 * rteosq * satrec.con41 +\n                    0.0625 * temp2 * rteosq * (13.0 - 78.0 * cosio2 + 137.0 * cosio4);\n            satrec.argpdot =\n                -0.5 * temp1 * con42 +\n                    0.0625 * temp2 * (7.0 - 114.0 * cosio2 + 395.0 * cosio4) +\n                    temp3 * (3.0 - 36.0 * cosio2 + 49.0 * cosio4);\n            const xhdot1 = -temp1 * cosio;\n            satrec.nodedot = xhdot1 + (0.5 * temp2 * (4.0 - 19.0 * cosio2) + 2.0 * temp3 * (3.0 - 7.0 * cosio2)) * cosio;\n            const xPIdot = satrec.argpdot + satrec.nodedot;\n            satrec.omgcof = satrec.bstar * cc3 * Math.cos(satrec.argpo);\n            satrec.xmcof = 0.0;\n            if (satrec.ecco > 1.0e-4) {\n                satrec.xmcof = (-x2o3 * coef * satrec.bstar) / eeta;\n            }\n            satrec.nodecf = 3.5 * omeosq * xhdot1 * satrec.cc1;\n            satrec.t2cof = 1.5 * satrec.cc1;\n            // Sgp4fix for divide by zero with xinco = 180 deg\n            if (Math.abs(cosio + 1.0) > 1.5e-12) {\n                satrec.xlcof = (-0.25 * j3oj2 * sinio * (3.0 + 5.0 * cosio)) / (1.0 + cosio);\n            }\n            else {\n                satrec.xlcof = (-0.25 * j3oj2 * sinio * (3.0 + 5.0 * cosio)) / temp4;\n            }\n            satrec.aycof = -0.5 * j3oj2 * sinio;\n            // Sgp4fix use multiply for speed instead of pow\n            const delmotemp = 1.0 + satrec.eta * Math.cos(satrec.mo);\n            satrec.delmo = delmotemp * delmotemp * delmotemp;\n            satrec.sinmao = Math.sin(satrec.mo);\n            satrec.x7thm1 = 7.0 * cosio2 - 1.0;\n            // --------------- deep space initialization -------------\n            if (TAU / satrec.no >= 225.0) {\n                satrec.method = Sgp4Methods.DEEP_SPACE;\n                satrec.isimp = true;\n                const tc = 0.0;\n                const inclm = satrec.inclo;\n                const dscomOptions = {\n                    epoch,\n                    ep: satrec.ecco,\n                    argpp: satrec.argpo,\n                    tc,\n                    inclp: satrec.inclo,\n                    nodep: satrec.nodeo,\n                    np: satrec.no,\n                    e3: satrec.e3,\n                    ee2: satrec.ee2,\n                    peo: satrec.peo,\n                    pgho: satrec.pgho,\n                    pho: satrec.pho,\n                    PInco: satrec.PInco,\n                    plo: satrec.plo,\n                    se2: satrec.se2,\n                    se3: satrec.se3,\n                    sgh2: satrec.sgh2,\n                    sgh3: satrec.sgh3,\n                    sgh4: satrec.sgh4,\n                    sh2: satrec.sh2,\n                    sh3: satrec.sh3,\n                    si2: satrec.si2,\n                    si3: satrec.si3,\n                    sl2: satrec.sl2,\n                    sl3: satrec.sl3,\n                    sl4: satrec.sl4,\n                    xgh2: satrec.xgh2,\n                    xgh3: satrec.xgh3,\n                    xgh4: satrec.xgh4,\n                    xh2: satrec.xh2,\n                    xh3: satrec.xh3,\n                    xi2: satrec.xi2,\n                    xi3: satrec.xi3,\n                    xl2: satrec.xl2,\n                    xl3: satrec.xl3,\n                    xl4: satrec.xl4,\n                    zmol: satrec.zmol,\n                    zmos: satrec.zmos,\n                };\n                const dscomResult = Sgp4.dscom_(dscomOptions);\n                satrec.e3 = dscomResult.e3;\n                satrec.ee2 = dscomResult.ee2;\n                satrec.peo = dscomResult.peo;\n                satrec.pgho = dscomResult.pgho;\n                satrec.pho = dscomResult.pho;\n                satrec.PInco = dscomResult.PInco;\n                satrec.plo = dscomResult.plo;\n                satrec.se2 = dscomResult.se2;\n                satrec.se3 = dscomResult.se3;\n                satrec.sgh2 = dscomResult.sgh2;\n                satrec.sgh3 = dscomResult.sgh3;\n                satrec.sgh4 = dscomResult.sgh4;\n                satrec.sh2 = dscomResult.sh2;\n                satrec.sh3 = dscomResult.sh3;\n                satrec.si2 = dscomResult.si2;\n                satrec.si3 = dscomResult.si3;\n                satrec.sl2 = dscomResult.sl2;\n                satrec.sl3 = dscomResult.sl3;\n                satrec.sl4 = dscomResult.sl4;\n                const { sinim, cosim, em, emsq, s1, s2, s3, s4, s5, ss1, ss2, ss3, ss4, ss5, sz1, sz3, sz11, sz13, sz21, sz23, sz31, sz33, } = dscomResult;\n                satrec.xgh2 = dscomResult.xgh2;\n                satrec.xgh3 = dscomResult.xgh3;\n                satrec.xgh4 = dscomResult.xgh4;\n                satrec.xh2 = dscomResult.xh2;\n                satrec.xh3 = dscomResult.xh3;\n                satrec.xi2 = dscomResult.xi2;\n                satrec.xi3 = dscomResult.xi3;\n                satrec.xl2 = dscomResult.xl2;\n                satrec.xl3 = dscomResult.xl3;\n                satrec.xl4 = dscomResult.xl4;\n                satrec.zmol = dscomResult.zmol;\n                satrec.zmos = dscomResult.zmos;\n                const { nm, z1, z3, z11, z13, z21, z23, z31, z33 } = dscomResult;\n                const dpperOptions = {\n                    inclo: inclm,\n                    init: satrec.init,\n                    ep: satrec.ecco,\n                    inclp: satrec.inclo,\n                    nodep: satrec.nodeo,\n                    argpp: satrec.argpo,\n                    mp: satrec.mo,\n                    opsmode: satrec.operationmode,\n                    satrec,\n                };\n                const dpperResult = Sgp4.dpper_(dpperOptions);\n                satrec.ecco = dpperResult.ep;\n                satrec.inclo = dpperResult.inclp;\n                satrec.nodeo = dpperResult.nodep;\n                satrec.argpo = dpperResult.argpp;\n                satrec.mo = dpperResult.mp;\n                const argpm = 0.0;\n                const nodem = 0.0;\n                const mm = 0.0;\n                const dsinitOptions = {\n                    xke,\n                    cosim,\n                    emsq,\n                    argpo: satrec.argpo,\n                    s1,\n                    s2,\n                    s3,\n                    s4,\n                    s5,\n                    sinim,\n                    ss1,\n                    ss2,\n                    ss3,\n                    ss4,\n                    ss5,\n                    sz1,\n                    sz3,\n                    sz11,\n                    sz13,\n                    sz21,\n                    sz23,\n                    sz31,\n                    sz33,\n                    t: satrec.t,\n                    tc,\n                    gsto: satrec.gsto,\n                    mo: satrec.mo,\n                    mdot: satrec.mdot,\n                    no: satrec.no,\n                    nodeo: satrec.nodeo,\n                    nodedot: satrec.nodedot,\n                    xPIdot,\n                    z1,\n                    z3,\n                    z11,\n                    z13,\n                    z21,\n                    z23,\n                    z31,\n                    z33,\n                    ecco: satrec.ecco,\n                    eccsq,\n                    em,\n                    argpm,\n                    inclm,\n                    mm,\n                    nm,\n                    nodem,\n                    irez: satrec.irez,\n                    atime: satrec.atime,\n                    d2201: satrec.d2201,\n                    d2211: satrec.d2211,\n                    d3210: satrec.d3210,\n                    d3222: satrec.d3222,\n                    d4410: satrec.d4410,\n                    d4422: satrec.d4422,\n                    d5220: satrec.d5220,\n                    d5232: satrec.d5232,\n                    d5421: satrec.d5421,\n                    d5433: satrec.d5433,\n                    dedt: satrec.dedt,\n                    didt: satrec.didt,\n                    dmdt: satrec.dmdt,\n                    dnodt: satrec.dnodt,\n                    domdt: satrec.domdt,\n                    del1: satrec.del1,\n                    del2: satrec.del2,\n                    del3: satrec.del3,\n                    xfact: satrec.xfact,\n                    xlamo: satrec.xlamo,\n                    xli: satrec.xli,\n                    xni: satrec.xni,\n                };\n                const dsinitResult = Sgp4.dsinit_(dsinitOptions);\n                satrec.irez = dsinitResult.irez;\n                satrec.atime = dsinitResult.atime;\n                satrec.d2201 = dsinitResult.d2201;\n                satrec.d2211 = dsinitResult.d2211;\n                satrec.d3210 = dsinitResult.d3210;\n                satrec.d3222 = dsinitResult.d3222;\n                satrec.d4410 = dsinitResult.d4410;\n                satrec.d4422 = dsinitResult.d4422;\n                satrec.d5220 = dsinitResult.d5220;\n                satrec.d5232 = dsinitResult.d5232;\n                satrec.d5421 = dsinitResult.d5421;\n                satrec.d5433 = dsinitResult.d5433;\n                satrec.dedt = dsinitResult.dedt;\n                satrec.didt = dsinitResult.didt;\n                satrec.dmdt = dsinitResult.dmdt;\n                satrec.dnodt = dsinitResult.dnodt;\n                satrec.domdt = dsinitResult.domdt;\n                satrec.del1 = dsinitResult.del1;\n                satrec.del2 = dsinitResult.del2;\n                satrec.del3 = dsinitResult.del3;\n                satrec.xfact = dsinitResult.xfact;\n                satrec.xlamo = dsinitResult.xlamo;\n                satrec.xli = dsinitResult.xli;\n                satrec.xni = dsinitResult.xni;\n            }\n            // ----------- set variables if not deep space -----------\n            if (!satrec.isimp) {\n                const cc1sq = satrec.cc1 * satrec.cc1;\n                satrec.d2 = 4.0 * ao * tsi * cc1sq;\n                const temp = (satrec.d2 * tsi * satrec.cc1) / 3.0;\n                satrec.d3 = (17.0 * ao + sfour) * temp;\n                satrec.d4 = 0.5 * temp * ao * tsi * (221.0 * ao + 31.0 * sfour) * satrec.cc1;\n                satrec.t3cof = satrec.d2 + 2.0 * cc1sq;\n                satrec.t4cof = 0.25 * (3.0 * satrec.d3 + satrec.cc1 * (12.0 * satrec.d2 + 10.0 * cc1sq));\n                satrec.t5cof =\n                    0.2 *\n                        (3.0 * satrec.d4 +\n                            12.0 * satrec.cc1 * satrec.d3 +\n                            6.0 * satrec.d2 * satrec.d2 +\n                            15.0 * cc1sq * (2.0 * satrec.d2 + cc1sq));\n            } // If omeosq = 0 ...\n            /* Finally propogate to zero epoch to initialize all others. */\n            /*\n             * Sgp4fix take out check to let satellites process until they are actually below earth surface\n             * if(satrec.error == 0)\n             */\n        }\n        Sgp4.propagate(satrec, 0);\n        satrec.init = false;\n        /*\n         * Sgp4fix return boolean. satrec.error contains any error codes\n         *  return satrec; -- no reason to return anything in JS\n         */\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { secondsPerDay } from '../utils/constants.js';\n// / Base class for [Epoch] data.\nexport class Epoch {\n    posix;\n    /*\n     * Create a new [Epoch] object given the number of seconds elapsed since the\n     * [posix] epoch _(`1970-01-01T00:00:00.000`)_ in the [Epoch] time scale.\n     */\n    constructor(posix) {\n        this.posix = posix;\n        if (posix < 0) {\n            throw new Error('Epoch cannot be negative');\n        }\n    }\n    toString() {\n        return this.toDateTime().toISOString();\n    }\n    // / Convert this to an Excel spreadsheet string.\n    toExcelString() {\n        return this.toString().substring(0, 19);\n    }\n    // / Return the difference _(s)_ between this and another [epoch]/\n    difference(epoch) {\n        return this.posix - epoch.posix;\n    }\n    // / Check if this has the same timestamp as the provided [epoch].\n    equals(epoch) {\n        return this.posix === epoch.posix;\n    }\n    // / Convert to a [DateTime] object.\n    toDateTime() {\n        return new Date(this.posix * 1000);\n    }\n    toEpochYearAndDay() {\n        const currentDateObj = this.toDateTime();\n        const epochYear = currentDateObj.getUTCFullYear().toString().slice(2, 4);\n        const epochDay = this.getDayOfYear_(currentDateObj);\n        const timeOfDay = (currentDateObj.getUTCHours() * 60 + currentDateObj.getUTCMinutes()) / 1440;\n        const epochDayStr = (epochDay + timeOfDay).toFixed(8).padStart(12, '0');\n        return {\n            epochYr: epochYear,\n            epochDay: epochDayStr,\n        };\n    }\n    getDayOfYear_(date) {\n        const dayCount = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n        const mn = date.getUTCMonth();\n        const dn = date.getUTCDate();\n        let dayOfYear = dayCount[mn] + dn;\n        if (mn > 1 && this.isLeapYear_(date)) {\n            dayOfYear++;\n        }\n        return dayOfYear;\n    }\n    isLeapYear_(dateIn) {\n        const year = dateIn.getUTCFullYear();\n        if ((year & 3) !== 0) {\n            return false;\n        }\n        return year % 100 !== 0 || year % 400 === 0;\n    }\n    // / Convert to Julian date.\n    toJulianDate() {\n        return this.posix / secondsPerDay + 2440587.5;\n    }\n    // / Convert to Julian centuries.\n    toJulianCenturies() {\n        return (this.toJulianDate() - 2451545) / 36525;\n    }\n    // / Check if this is later than the [other] epoch.\n    operatorGreaterThan(other) {\n        return this.posix > other.posix;\n    }\n    // / Check if this is later or the same as the [other] epoch.\n    operatorGreaterThanOrEqual(other) {\n        return this.posix >= other.posix;\n    }\n    // / Check if this is earlier than the [other] epoch.\n    operatorLessThan(other) {\n        return this.posix < other.posix;\n    }\n    // / Check if this is earlier or the same as the [other] epoch.\n    operatorLessThanOrEqual(other) {\n        return this.posix <= other.posix;\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { DataHandler } from '../data/DataHandler.js';\nimport { secondsPerWeek } from '../utils/constants.js';\n// / Global Positioning System _(GPS)_ formatted epoch.\nexport class EpochGPS {\n    week;\n    seconds;\n    /**\n     * Create a new GPS epoch given the [week] since reference epoch, and number\n     * of [seconds] into the [week].\n     * @param week Number of weeks since the GPS reference epoch.\n     * @param seconds Number of seconds into the week.\n     * @param reference Reference should always be EpochUTC.fromDateTimeString('1980-01-06T00:00:00.000Z').\n     */\n    constructor(week, seconds, reference) {\n        this.week = week;\n        this.seconds = seconds;\n        if (week < 0) {\n            throw new Error('GPS week must be non-negative.');\n        }\n        if (seconds < 0 || seconds >= secondsPerWeek) {\n            throw new Error('GPS seconds must be within a week.');\n        }\n        // TODO: Set EpochGPS.reference statically without circular dependency.\n        EpochGPS.reference = reference;\n    }\n    // / Number of weeks since the GPS reference epoch.\n    static reference;\n    // / GPS leap second difference from TAI/UTC offsets.\n    static offset = 19;\n    // / Get GPS week accounting for 10-bit rollover.\n    get week10Bit() {\n        return this.week % 2 ** 10;\n    }\n    // / Get GPS week accounting for 13-bit rollover.\n    get week13Bit() {\n        return this.week % 2 ** 13;\n    }\n    toString() {\n        return `${this.week}:${this.seconds.toFixed(3)}`;\n    }\n    // / Convert this to a UTC epoch.\n    toUTC() {\n        const init = EpochGPS.reference.roll((this.week * secondsPerWeek + this.seconds));\n        const ls = DataHandler.getInstance().getLeapSeconds(init.toJulianDate());\n        return init.roll(-(ls - EpochGPS.offset));\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { Epoch } from './Epoch.js';\n/** Represents an Epoch in International Atomic Time (TAI). */\nexport class EpochTAI extends Epoch {\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { Epoch } from './Epoch.js';\n/** Represents an Epoch in TDB (Barycentric Dynamical Time). */\nexport class EpochTDB extends Epoch {\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { Epoch } from './Epoch.js';\n/** Represents a Terrestrial Time (TT) epoch. */\nexport class EpochTT extends Epoch {\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { DEG2RAD, MS_PER_DAY, RAD2DEG, secondsPerWeek, TAU } from '../utils/constants.js';\nimport { evalPoly } from '../utils/functions.js';\nimport { DataHandler } from './../data/DataHandler.js';\nimport { Epoch } from './Epoch.js';\nimport { EpochGPS } from './EpochGPS.js';\nimport { EpochTAI } from './EpochTAI.js';\nimport { EpochTDB } from './EpochTDB.js';\nimport { EpochTT } from './EpochTT.js';\nexport class EpochUTC extends Epoch {\n    static now() {\n        return new EpochUTC(new Date().getTime() / 1000);\n    }\n    static fromDate({ year, month, day, hour = 0, minute = 0, second = 0 }) {\n        return new EpochUTC(EpochUTC.dateToPosix_({ year, month, day, hour, minute, second }));\n    }\n    static fromDateTime(dt) {\n        return new EpochUTC(dt.getTime() / 1000);\n    }\n    static fromDateTimeString(dateTimeString) {\n        const dts = dateTimeString.trim().toUpperCase().endsWith('Z') ? dateTimeString : `${dateTimeString}Z`;\n        return new EpochUTC(new Date(dts).getTime() / 1000);\n    }\n    static fromJ2000TTSeconds(seconds) {\n        const tInit = new EpochUTC(seconds + 946728000);\n        const ls = DataHandler.getInstance().getLeapSeconds(tInit.toJulianDate());\n        return tInit.roll(-32.184 - ls);\n    }\n    static fromDefinitiveString(definitiveString) {\n        const fields = definitiveString.trim().split(' ');\n        const dateFields = fields[0].split('/');\n        const day = parseInt(dateFields[0]);\n        const year = parseInt(dateFields[1]);\n        // eslint-disable-next-line prefer-destructuring\n        const timeField = fields[1];\n        // Add day - 1 days in milliseconds to the epoch.\n        const dts = new Date(`${year}-01-01T${timeField}Z`).getTime() + (day - 1) * MS_PER_DAY;\n        return new EpochUTC(dts / 1000);\n    }\n    roll(seconds) {\n        return new EpochUTC(this.posix + seconds);\n    }\n    toMjd() {\n        return this.toJulianDate() - 2400000.5;\n    }\n    toMjdGsfc() {\n        return this.toMjd() - 29999.5;\n    }\n    toTAI() {\n        const ls = DataHandler.getInstance().getLeapSeconds(this.toJulianDate());\n        return new EpochTAI(this.posix + ls);\n    }\n    toTT() {\n        return new EpochTT(this.toTAI().posix + 32.184);\n    }\n    toTDB() {\n        const tt = this.toTT();\n        const tTT = tt.toJulianCenturies();\n        const mEarth = (357.5277233 + 35999.05034 * tTT) * DEG2RAD;\n        const seconds = 0.001658 * Math.sin(mEarth) + 0.00001385 * Math.sin(2 * mEarth);\n        return new EpochTDB(tt.posix + seconds);\n    }\n    toGPS() {\n        const referenceTime = EpochUTC.fromDateTimeString('1980-01-06T00:00:00.000Z');\n        const ls = DataHandler.getInstance().getLeapSeconds(this.toJulianDate());\n        const delta = this.roll(ls - EpochGPS.offset).difference(referenceTime);\n        const week = delta / secondsPerWeek;\n        const weekFloor = Math.floor(week);\n        const seconds = (week - weekFloor) * secondsPerWeek;\n        return new EpochGPS(weekFloor, seconds, referenceTime);\n    }\n    gmstAngle() {\n        const t = this.toJulianCenturies();\n        const seconds = evalPoly(t, EpochUTC.gmstPoly_);\n        let result = ((seconds / 240) * DEG2RAD) % TAU;\n        if (result < 0) {\n            result += TAU;\n        }\n        return result;\n    }\n    gmstAngleDegrees() {\n        return this.gmstAngle() * RAD2DEG;\n    }\n    static gmstPoly_ = new Float64Array([\n        -6.2e-6,\n        0.093104,\n        876600 * 3600 + 8640184.812866,\n        67310.54841,\n    ]);\n    static dayOfYearLookup_ = [\n        [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],\n        [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335],\n    ];\n    static isLeapYear_(year) {\n        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n    }\n    static dayOfYear_(year, month, day) {\n        const dex = EpochUTC.isLeapYear_(year) ? 1 : 0;\n        const dayOfYearArray = EpochUTC.dayOfYearLookup_[dex];\n        const daysBeforeCurrentMonth = dayOfYearArray[month - 1];\n        return daysBeforeCurrentMonth + day - 1;\n    }\n    static dateToPosix_({ year, month, day, hour, minute, second }) {\n        const days = EpochUTC.dayOfYear_(year, month, day);\n        const yearMod = year - 1900;\n        return (minute * 60 +\n            hour * 3600 +\n            days * 86400 +\n            (yearMod - 70) * 31536000 +\n            Math.floor((yearMod - 69) / 4) * 86400 -\n            Math.floor((yearMod - 1) / 100) * 86400 +\n            Math.floor((yearMod + 299) / 400) * 86400 +\n            second);\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nexport class EpochWindow {\n    start;\n    end;\n    constructor(start, end) {\n        this.start = start;\n        this.end = end;\n    }\n}\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nexport class TimeStamped {\n    /**\n     * Create a new time stamped value container at the provided epoch.\n     * @param epoch The timestamp epoch.\n     * @param value The timestamped value.\n     */\n    constructor(epoch, value) {\n        this.epoch = epoch;\n        this.value = value;\n    }\n    /**\n     * Timestamp epoch.\n     */\n    epoch;\n    /**\n     * Timestamped value.\n     */\n    value;\n}\n","export { Epoch } from './Epoch.js';\nexport { EpochGPS } from './EpochGPS.js';\nexport { EpochTAI } from './EpochTAI.js';\nexport { EpochTDB } from './EpochTDB.js';\nexport { EpochTT } from './EpochTT.js';\nexport { EpochUTC } from './EpochUTC.js';\nexport { EpochWindow } from './EpochWindow.js';\nexport { TimeStamped } from './TimeStamped.js';\n","/**\n * @author Theodore Kruczek\n * @description Orbital Object ToolKit (ootk) is a collection of tools for working\n * with satellites and other orbital objects.\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Many of the classes are based off of the work of @david-rc-dayton and his\n * Pious Squid library (https://github.com/david-rc-dayton/pious_squid) which\n * is licensed under the MIT license.\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\nimport { DEG2RAD, PI, RAD2DEG } from '../main.js';\n/**\n * Converts radians to degrees.\n * @param radians The value in radians to be converted.\n * @returns The value in degrees.\n */\nexport function rad2deg(radians) {\n    return ((radians * 180) / PI);\n}\n/**\n * Converts degrees to radians.\n * @param degrees The value in degrees to be converted.\n * @returns The value in radians.\n */\nexport function deg2rad(degrees) {\n    return ((degrees * PI) / 180.0);\n}\n/**\n * Converts radians to degrees latitude.\n * @param radians The radians value to convert.\n * @returns The corresponding degrees latitude.\n * @throws RangeError if the radians value is outside the range [-PI/2; PI/2].\n */\nexport function getDegLat(radians) {\n    if (radians < -PI / 2 || radians > PI / 2) {\n        throw new RangeError('Latitude radians must be in range [-PI/2; PI/2].');\n    }\n    return (radians * RAD2DEG);\n}\n/**\n * Converts radians to degrees for longitude.\n * @param radians The value in radians to be converted.\n * @returns The converted value in degrees.\n * @throws {RangeError} If the input radians is not within the range [-PI; PI].\n */\nexport function getDegLon(radians) {\n    if (radians < -PI || radians > PI) {\n        throw new RangeError('Longitude radians must be in range [-PI; PI].');\n    }\n    return (radians * RAD2DEG);\n}\n/**\n * Converts degrees to radians for latitude.\n * @param degrees The degrees value to convert.\n * @returns The equivalent radians value.\n * @throws {RangeError} If the degrees value is not within the range [-90, 90].\n */\nexport function getRadLat(degrees) {\n    if (degrees < -90 || degrees > 90) {\n        throw new RangeError('Latitude degrees must be in range [-90; 90].');\n    }\n    return (degrees * DEG2RAD);\n}\n/**\n * Converts degrees to radians.\n * @param degrees The value in degrees to be converted.\n * @returns The value in radians.\n * @throws {RangeError} If the input degrees are not within the range [-180; 180].\n */\nexport function getRadLon(degrees) {\n    if (degrees < -180 || degrees > 180) {\n        throw new RangeError('Longitude degrees must be in range [-180; 180].');\n    }\n    return (degrees * DEG2RAD);\n}\n","export * from './conversions.js';\nexport * from './transforms.js';\n","import { DEG2RAD, Earth, MILLISECONDS_TO_DAYS, PI, RAD2DEG, Sgp4, TAU, } from '../main.js';\n/**\n * Converts ECF to ECI coordinates.\n *\n * [X]     [C -S  0][X]\n * [Y]  =  [S  C  0][Y]\n * [Z]eci  [0  0  1][Z]ecf\n * @param ecf takes xyz coordinates\n * @param gmst takes a number in gmst time\n * @returns array containing eci coordinates\n */\nexport function ecf2eci(ecf, gmst) {\n    const X = (ecf.x * Math.cos(gmst) - ecf.y * Math.sin(gmst));\n    const Y = (ecf.x * Math.sin(gmst) + ecf.y * Math.cos(gmst));\n    const Z = ecf.z;\n    return { x: X, y: Y, z: Z };\n}\n/**\n * Converts ECEF coordinates to ENU coordinates.\n * @param ecf - The ECEF coordinates.\n * @param lla - The LLA coordinates.\n * @returns The ENU coordinates.\n */\nexport function ecf2enu(ecf, lla) {\n    const { lat, lon } = lla;\n    const { x, y, z } = ecf;\n    const e = (-Math.sin(lon) * x + Math.cos(lon) * y);\n    const n = (-Math.sin(lat) * Math.cos(lon) * x - Math.sin(lat) * Math.sin(lon) * y + Math.cos(lat) * z);\n    const u = (Math.cos(lat) * Math.cos(lon) * x + Math.cos(lat) * Math.sin(lon) * y + Math.sin(lat) * z);\n    return { x: e, y: n, z: u };\n}\n/**\n * Converts ECI to ECF coordinates.\n *\n * [X]     [C -S  0][X]\n * [Y]  =  [S  C  0][Y]\n * [Z]eci  [0  0  1][Z]ecf\n *\n * Inverse:\n * [X]     [C  S  0][X]\n * [Y]  =  [-S C  0][Y]\n * [Z]ecf  [0  0  1][Z]eci\n * @param eci takes xyz coordinates\n * @param gmst takes a number in gmst time\n * @returns array containing ecf coordinates\n */\nexport function eci2ecf(eci, gmst) {\n    const x = (eci.x * Math.cos(gmst) + eci.y * Math.sin(gmst));\n    const y = (eci.x * -Math.sin(gmst) + eci.y * Math.cos(gmst));\n    const z = eci.z;\n    return {\n        x,\n        y,\n        z,\n    };\n}\n/**\n * EciToGeodetic converts eci coordinates to lla coordinates\n * @variation cached - results are cached\n * @param eci takes xyz coordinates\n * @param gmst takes a number in gmst time\n * @returns array containing lla coordinates\n */\nexport function eci2lla(eci, gmst) {\n    // http://www.celestrak.com/columns/v02n03/\n    const a = 6378.137;\n    const b = 6356.7523142;\n    const R = Math.sqrt(eci.x * eci.x + eci.y * eci.y);\n    const f = (a - b) / a;\n    const e2 = 2 * f - f * f;\n    let lon = Math.atan2(eci.y, eci.x) - gmst;\n    while (lon < -PI) {\n        lon += TAU;\n    }\n    while (lon > PI) {\n        lon -= TAU;\n    }\n    const kmax = 20;\n    let k = 0;\n    let lat = Math.atan2(eci.z, Math.sqrt(eci.x * eci.x + eci.y * eci.y));\n    let C = 0;\n    while (k < kmax) {\n        C = 1 / Math.sqrt(1 - e2 * (Math.sin(lat) * Math.sin(lat)));\n        lat = Math.atan2(eci.z + a * C * e2 * Math.sin(lat), R);\n        k += 1;\n    }\n    const alt = R / Math.cos(lat) - a * C;\n    lon = (lon * RAD2DEG);\n    lat = (lat * RAD2DEG);\n    return { lon: lon, lat: lat, alt: alt };\n}\n/**\n * Converts geodetic coordinates (longitude, latitude, altitude) to Earth-Centered Earth-Fixed (ECF) coordinates.\n * @param lla The geodetic coordinates in radians and meters.\n * @returns The ECF coordinates in meters.\n */\nexport function llaRad2ecf(lla) {\n    const { lon, lat, alt } = lla;\n    const a = 6378.137;\n    const b = 6356.7523142;\n    const f = (a - b) / a;\n    const e2 = 2 * f - f * f;\n    const normal = a / Math.sqrt(1 - e2 * Math.sin(lat) ** 2);\n    const x = (normal + alt) * Math.cos(lat) * Math.cos(lon);\n    const y = (normal + alt) * Math.cos(lat) * Math.sin(lon);\n    const z = (normal * (1 - e2) + alt) * Math.sin(lat);\n    return {\n        x: x,\n        y: y,\n        z: z,\n    };\n}\n/**\n * Converts geodetic coordinates (longitude, latitude, altitude) to Earth-Centered Earth-Fixed (ECF) coordinates.\n * @param lla The geodetic coordinates in degrees and meters.\n * @returns The ECF coordinates in meters.\n */\nexport function lla2ecf(lla) {\n    const { lon, lat, alt } = lla;\n    const lonRad = lon * DEG2RAD;\n    const latRad = lat * DEG2RAD;\n    return llaRad2ecf({\n        lon: lonRad,\n        lat: latRad,\n        alt,\n    });\n}\n/**\n * Converts geodetic coordinates (latitude, longitude, altitude) to Earth-centered inertial (ECI) coordinates.\n * @variation cached - results are cached\n * @param lla The geodetic coordinates in radians and meters.\n * @param gmst The Greenwich Mean Sidereal Time in seconds.\n * @returns The ECI coordinates in meters.\n */\nexport function lla2eci(lla, gmst) {\n    const { lat, lon, alt } = lla;\n    const cosLat = Math.cos(lat);\n    const sinLat = Math.sin(lat);\n    const cosLon = Math.cos(lon + gmst);\n    const sinLon = Math.sin(lon + gmst);\n    const x = (Earth.radiusMean + alt) * cosLat * cosLon;\n    const y = (Earth.radiusMean + alt) * cosLat * sinLon;\n    const z = (Earth.radiusMean + alt) * sinLat;\n    return { x, y, z };\n}\n/**\n * Calculates Geodetic Lat Lon Alt to ECEF coordinates.\n * @deprecated This needs to be validated.\n * @param lla The geodetic coordinates in degrees and meters.\n * @returns The ECEF coordinates in meters.\n */\nexport function lla2ecef(lla) {\n    const { lat, lon, alt } = lla;\n    const a = 6378.137; // semi-major axis length in meters according to the WGS84\n    const b = 6356.752314245; // semi-minor axis length in meters according to the WGS84\n    const e = Math.sqrt(1 - b ** 2 / a ** 2); // eccentricity\n    const N = a / Math.sqrt(1 - e ** 2 * Math.sin(lat) ** 2); // radius of curvature in the prime vertical\n    const x = ((N + alt) * Math.cos(lat) * Math.cos(lon));\n    const y = ((N + alt) * Math.cos(lat) * Math.sin(lon));\n    const z = ((N * (1 - e ** 2) + alt) * Math.sin(lat));\n    return { x, y, z };\n}\n/**\n * Converts LLA to SEZ coordinates.\n * @see http://www.celestrak.com/columns/v02n02/\n * @param lla The LLA coordinates.\n * @param ecf The ECF coordinates.\n * @returns The SEZ coordinates.\n */\nexport function lla2sez(lla, ecf) {\n    const lon = lla.lon;\n    const lat = lla.lat;\n    const observerEcf = llaRad2ecf({\n        lat,\n        lon,\n        alt: 0,\n    });\n    const rx = ecf.x - observerEcf.x;\n    const ry = ecf.y - observerEcf.y;\n    const rz = ecf.z - observerEcf.z;\n    // Top is short for topocentric\n    const south = Math.sin(lat) * Math.cos(lon) * rx + Math.sin(lat) * Math.sin(lon) * ry - Math.cos(lat) * rz;\n    const east = -Math.sin(lon) * rx + Math.cos(lon) * ry;\n    const zenith = Math.cos(lat) * Math.cos(lon) * rx + Math.cos(lat) * Math.sin(lon) * ry + Math.sin(lat) * rz;\n    return { s: south, e: east, z: zenith };\n}\n/**\n * Converts a vector in Right Ascension, Elevation, and Range (RAE) coordinate system\n * to a vector in South, East, and Zenith (SEZ) coordinate system.\n * @param rae The vector in RAE coordinate system.\n * @returns The vector in SEZ coordinate system.\n */\nexport function rae2sez(rae) {\n    const south = -rae.rng * Math.cos(rae.el) * Math.cos(rae.az);\n    const east = rae.rng * Math.cos(rae.el) * Math.sin(rae.az);\n    const zenith = rae.rng * Math.sin(rae.el);\n    return {\n        s: south,\n        e: east,\n        z: zenith,\n    };\n}\n/**\n * Converts a vector in Right Ascension, Elevation, and Range (RAE) coordinate system\n * to Earth-Centered Fixed (ECF) coordinate system.\n * @template D - The dimension of the RAE vector.\n * @template A - The dimension of the LLA vector.\n * @param rae - The vector in RAE coordinate system.\n * @param lla - The vector in LLA coordinate system.\n * @returns The vector in ECF coordinate system.\n */\nexport function rae2ecf(rae, lla) {\n    const llaRad = {\n        lat: (lla.lat * DEG2RAD),\n        lon: (lla.lon * DEG2RAD),\n        alt: lla.alt,\n    };\n    const raeRad = {\n        az: (rae.az * DEG2RAD),\n        el: (rae.el * DEG2RAD),\n        rng: rae.rng,\n    };\n    const obsEcf = llaRad2ecf(llaRad);\n    const sez = rae2sez(raeRad);\n    // Some needed calculations\n    const slat = Math.sin(llaRad.lat);\n    const slon = Math.sin(llaRad.lon);\n    const clat = Math.cos(llaRad.lat);\n    const clon = Math.cos(llaRad.lon);\n    const x = slat * clon * sez.s + -slon * sez.e + clat * clon * sez.z + obsEcf.x;\n    const y = slat * slon * sez.s + clon * sez.e + clat * slon * sez.z + obsEcf.y;\n    const z = -clat * sez.s + slat * sez.z + obsEcf.z;\n    return { x, y, z };\n}\n/**\n * Converts a vector from RAE (Range, Azimuth, Elevation) coordinates to ECI (Earth-Centered Inertial) coordinates.\n * @variation cached - results are cached\n * @param rae The vector in RAE coordinates.\n * @param lla The vector in LLA (Latitude, Longitude, Altitude) coordinates.\n * @param gmst The Greenwich Mean Sidereal Time.\n * @returns The vector in ECI coordinates.\n */\nexport function rae2eci(rae, lla, gmst) {\n    const ecf = rae2ecf(rae, lla);\n    const eci = ecf2eci(ecf, gmst);\n    return eci;\n}\n/**\n * Converts a vector in RAE (Range, Azimuth, Elevation) coordinates to ENU (East, North, Up) coordinates.\n * @param rae - The vector in RAE coordinates.\n * @returns The vector in ENU coordinates.\n */\nexport function rae2enu(rae) {\n    const e = (rae.rng * Math.cos(rae.el) * Math.sin(rae.az));\n    const n = (rae.rng * Math.cos(rae.el) * Math.cos(rae.az));\n    const u = (rae.rng * Math.sin(rae.el));\n    return { x: e, y: n, z: u };\n}\n/**\n * Converts South, East, and Zenith (SEZ) coordinates to Right Ascension, Elevation, and Range (RAE) coordinates.\n * @param sez The SEZ coordinates.\n * @returns Rng, Az, El array\n */\nexport function sez2rae(sez) {\n    const rng = Math.sqrt(sez.s * sez.s + sez.e * sez.e + sez.z * sez.z);\n    const el = Math.asin(sez.z / rng);\n    const az = (Math.atan2(-sez.e, sez.s) + PI);\n    return { rng, az, el };\n}\n/**\n * Converts Earth-Centered Fixed (ECF) coordinates to Right Ascension (RA),\n * Elevation (E), and Azimuth (A) coordinates.\n * @param lla The Latitude, Longitude, and Altitude (LLA) coordinates.\n * @param ecf The Earth-Centered Fixed (ECF) coordinates.\n * @returns The Right Ascension (RA), Elevation (E), and Azimuth (A) coordinates.\n */\nexport function ecfRad2rae(lla, ecf) {\n    const sezCoords = lla2sez(lla, ecf);\n    const rae = sez2rae(sezCoords);\n    return { rng: rae.rng, az: (rae.az * RAD2DEG), el: (rae.el * RAD2DEG) };\n}\n/**\n * Converts Earth-Centered Fixed (ECF) coordinates to Right Ascension (RA),\n * Elevation (E), and Azimuth (A) coordinates.\n * @variation cached - results are cached\n * @param lla The Latitude, Longitude, and Altitude (LLA) coordinates.\n * @param ecf The Earth-Centered Fixed (ECF) coordinates.\n * @returns The Right Ascension (RA), Elevation (E), and Azimuth (A) coordinates.\n */\nexport function ecf2rae(lla, ecf) {\n    const { lat, lon } = lla;\n    const latRad = (lat * DEG2RAD);\n    const lonRad = (lon * DEG2RAD);\n    const rae = ecfRad2rae({ lat: latRad, lon: lonRad, alt: lla.alt }, ecf);\n    return rae;\n}\nexport const jday = (year, mon, day, hr, minute, sec) => {\n    if (typeof year === 'undefined') {\n        const now = new Date();\n        const jDayStart = new Date(now.getUTCFullYear(), 0, 0);\n        const jDayDiff = now.getDate() - jDayStart.getDate();\n        return Math.floor(jDayDiff / MILLISECONDS_TO_DAYS);\n    }\n    if (typeof mon === 'undefined' ||\n        typeof day === 'undefined' ||\n        typeof hr === 'undefined' ||\n        typeof minute === 'undefined' ||\n        typeof sec === 'undefined') {\n        throw new Error('Invalid date');\n    }\n    return (367.0 * year -\n        Math.floor(7 * (year + Math.floor((mon + 9) / 12.0)) * 0.25) +\n        Math.floor((275 * mon) / 9.0) +\n        day +\n        1721013.5 +\n        ((sec / 60.0 + minute) / 60.0 + hr) / 24.0);\n};\n/**\n * Calculates the Greenwich Mean Sidereal Time (GMST) for a given date.\n * @param date - The date for which to calculate the GMST.\n * @returns An object containing the GMST value and the Julian date.\n */\nexport function calcGmst(date) {\n    const j = jday(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds()) +\n        date.getUTCMilliseconds() * MILLISECONDS_TO_DAYS;\n    const gmst = Sgp4.gstime(j);\n    return { gmst, j };\n}\n/**\n * Converts ECI coordinates to RAE (Right Ascension, Azimuth, Elevation) coordinates.\n * @variation cached - results are cached\n * @param now - Current date and time.\n * @param eci - ECI coordinates of the satellite.\n * @param sensor - Sensor object containing observer's geodetic coordinates.\n * @returns Object containing azimuth, elevation and range in degrees and kilometers respectively.\n */\nexport function eci2rae(now, eci, sensor) {\n    now = new Date(now);\n    const { gmst } = calcGmst(now);\n    const positionEcf = eci2ecf(eci, gmst);\n    const lla = {\n        lat: (sensor.lat * DEG2RAD),\n        lon: (sensor.lon * DEG2RAD),\n        alt: sensor.alt,\n    };\n    const rae = ecfRad2rae(lla, positionEcf);\n    return rae;\n}\n/**\n * Calculates the inertial azimuth of a satellite given its latitude and inclination.\n * @param lat - The latitude of the satellite in degrees.\n * @param inc - The inclination of the satellite in degrees.\n * @returns The inertial azimuth of the satellite in degrees.\n */\nexport function calcInertAz(lat, inc) {\n    const phi = lat * DEG2RAD;\n    const i = inc * DEG2RAD;\n    const az = Math.asin(Math.cos(i) / Math.cos(phi));\n    return (az * RAD2DEG);\n}\n/**\n * Calculates the inclination angle of a satellite from its launch azimuth and latitude.\n * @param lat - The latitude of the observer in degrees.\n * @param az - The launch azimuth angle of the satellite in degrees clockwise from north.\n * @returns The inclination angle of the satellite in degrees.\n */\nexport function calcIncFromAz(lat, az) {\n    const phi = lat * DEG2RAD;\n    const beta = az * DEG2RAD;\n    const inc = Math.acos(Math.sin(beta) * Math.cos(phi));\n    return (inc * RAD2DEG);\n}\n/**\n * Converts Azimuth and Elevation to U and V.\n * Azimuth is the angle off of boresight in the horizontal plane.\n * Elevation is the angle off of boresight in the vertical plane.\n * Cone half angle is the angle of the cone of the radar max field of view.\n * @param az - Azimuth in radians\n * @param el - Elevation in radians\n * @param coneHalfAngle - Cone half angle in radians\n * @returns U and V in radians\n */\nexport function azel2uv(az, el, coneHalfAngle) {\n    if (az > coneHalfAngle && az < coneHalfAngle) {\n        throw new RangeError(`Azimuth is out of bounds: ${az}`);\n    }\n    if (el > coneHalfAngle && el < coneHalfAngle) {\n        throw new RangeError(`Elevation is out of bounds: ${el}`);\n    }\n    const alpha = (az / (coneHalfAngle * RAD2DEG)) * 90;\n    const beta = (el / (coneHalfAngle * RAD2DEG)) * 90;\n    const u = Math.sin(alpha);\n    let v = -Math.sin(beta);\n    v = Object.is(v, -0) ? 0 : v;\n    return { u, v };\n}\n/**\n * Determine azimuth and elevation off of boresight based on sensor orientation and RAE.\n * @param rae Range, Azimuth, Elevation\n * @param sensor Radar sensor object\n * @param face Face number of the sensor\n * @param maxSensorAz Maximum sensor azimuth\n * @returns Azimuth and Elevation off of boresight\n */\nexport function rae2raeOffBoresight(rae, sensor, face, maxSensorAz) {\n    let az = (rae.az * DEG2RAD);\n    let el = (rae.el * DEG2RAD);\n    // Correct azimuth for sensor orientation.\n    az = az > maxSensorAz * DEG2RAD ? (az - TAU) : az;\n    az = (az - sensor.boresightAz[face]);\n    el = (el - sensor.boresightEl[face]);\n    return { az, el };\n}\n/**\n * Converts Range Az El to Range U V.\n * @param rae Range, Azimuth, Elevation\n * @param sensor Radar sensor object\n * @param face Face number of the sensor\n * @param maxSensorAz Maximum sensor azimuth\n * @returns Range, U, V\n */\nexport function rae2ruv(rae, sensor, face, maxSensorAz) {\n    const { az, el } = rae2raeOffBoresight(rae, sensor, face, maxSensorAz);\n    const { u, v } = azel2uv(az, el, sensor.beamwidthRad);\n    return { rng: rae.rng, u, v };\n}\n/**\n * Converts U and V to Azimuth and Elevation off of boresight.\n * @param u The U coordinate.\n * @param v The V coordinate.\n * @param coneHalfAngle The cone half angle of the radar.\n * @returns Azimuth and Elevation off of boresight.\n */\nexport function uv2azel(u, v, coneHalfAngle) {\n    if (u > 1 || u < -1) {\n        throw new RangeError(`u is out of bounds: ${u}`);\n    }\n    if (v > 1 || v < -1) {\n        throw new RangeError(`v is out of bounds: ${v}`);\n    }\n    const alpha = Math.asin(u);\n    const beta = Math.asin(v);\n    const az = ((alpha / 90) * (coneHalfAngle * RAD2DEG));\n    const el = ((beta / 90) * (coneHalfAngle * RAD2DEG));\n    return { az, el };\n}\n/**\n * Converts coordinates from East-North-Up (ENU) to Right-Front-Up (RF) coordinate system.\n * @param enu - The ENU coordinates to be converted.\n * @param enu.x - The east coordinate.\n * @param enu.y - The north coordinate.\n * @param enu.z - The up coordinate.\n * @param az - The azimuth angle in radians.\n * @param el - The elevation angle in radians.\n * @returns The converted RF coordinates.\n */\nexport function enu2rf({ x, y, z }, az, el) {\n    const xrf = Math.cos(el) * Math.cos(az) * x - Math.sin(az) * y + Math.sin(el) * Math.cos(az) * z;\n    const yrf = Math.cos(el) * Math.sin(az) * x + Math.cos(az) * y + Math.sin(el) * Math.sin(az) * z;\n    const zrf = -Math.sin(el) * x + Math.cos(el) * z;\n    return {\n        x: xrf,\n        y: yrf,\n        z: zrf,\n    };\n}\n","/**\n * @author @thkruz Theodore Kruczek\n * @license AGPL-3.0-or-later\n * @copyright (c) 2025 Kruczek Labs LLC\n *\n * Orbital Object ToolKit is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * Orbital Object ToolKit is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * Orbital Object ToolKit. If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * Enum representing different types of objects.\n */\nexport var SpaceObjectType;\n(function (SpaceObjectType) {\n    SpaceObjectType[SpaceObjectType[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    SpaceObjectType[SpaceObjectType[\"PAYLOAD\"] = 1] = \"PAYLOAD\";\n    SpaceObjectType[SpaceObjectType[\"ROCKET_BODY\"] = 2] = \"ROCKET_BODY\";\n    SpaceObjectType[SpaceObjectType[\"DEBRIS\"] = 3] = \"DEBRIS\";\n    SpaceObjectType[SpaceObjectType[\"SPECIAL\"] = 4] = \"SPECIAL\";\n    SpaceObjectType[SpaceObjectType[\"BALLISTIC_MISSILE\"] = 8] = \"BALLISTIC_MISSILE\";\n    SpaceObjectType[SpaceObjectType[\"STAR\"] = 9] = \"STAR\";\n    SpaceObjectType[SpaceObjectType[\"INTERGOVERNMENTAL_ORGANIZATION\"] = 10] = \"INTERGOVERNMENTAL_ORGANIZATION\";\n    SpaceObjectType[SpaceObjectType[\"SUBORBITAL_PAYLOAD_OPERATOR\"] = 11] = \"SUBORBITAL_PAYLOAD_OPERATOR\";\n    SpaceObjectType[SpaceObjectType[\"PAYLOAD_OWNER\"] = 12] = \"PAYLOAD_OWNER\";\n    SpaceObjectType[SpaceObjectType[\"METEOROLOGICAL_ROCKET_LAUNCH_AGENCY_OR_MANUFACTURER\"] = 13] = \"METEOROLOGICAL_ROCKET_LAUNCH_AGENCY_OR_MANUFACTURER\";\n    SpaceObjectType[SpaceObjectType[\"PAYLOAD_MANUFACTURER\"] = 14] = \"PAYLOAD_MANUFACTURER\";\n    SpaceObjectType[SpaceObjectType[\"LAUNCH_AGENCY\"] = 15] = \"LAUNCH_AGENCY\";\n    SpaceObjectType[SpaceObjectType[\"LAUNCH_SITE\"] = 16] = \"LAUNCH_SITE\";\n    SpaceObjectType[SpaceObjectType[\"LAUNCH_POSITION\"] = 17] = \"LAUNCH_POSITION\";\n    SpaceObjectType[SpaceObjectType[\"LAUNCH_FACILITY\"] = 18] = \"LAUNCH_FACILITY\";\n    SpaceObjectType[SpaceObjectType[\"CONTROL_FACILITY\"] = 19] = \"CONTROL_FACILITY\";\n    SpaceObjectType[SpaceObjectType[\"GROUND_SENSOR_STATION\"] = 20] = \"GROUND_SENSOR_STATION\";\n    SpaceObjectType[SpaceObjectType[\"OPTICAL\"] = 21] = \"OPTICAL\";\n    SpaceObjectType[SpaceObjectType[\"MECHANICAL\"] = 22] = \"MECHANICAL\";\n    SpaceObjectType[SpaceObjectType[\"PHASED_ARRAY_RADAR\"] = 23] = \"PHASED_ARRAY_RADAR\";\n    SpaceObjectType[SpaceObjectType[\"OBSERVER\"] = 24] = \"OBSERVER\";\n    SpaceObjectType[SpaceObjectType[\"BISTATIC_RADIO_TELESCOPE\"] = 25] = \"BISTATIC_RADIO_TELESCOPE\";\n    SpaceObjectType[SpaceObjectType[\"COUNTRY\"] = 26] = \"COUNTRY\";\n    SpaceObjectType[SpaceObjectType[\"LAUNCH_VEHICLE_MANUFACTURER\"] = 27] = \"LAUNCH_VEHICLE_MANUFACTURER\";\n    SpaceObjectType[SpaceObjectType[\"ENGINE_MANUFACTURER\"] = 28] = \"ENGINE_MANUFACTURER\";\n    SpaceObjectType[SpaceObjectType[\"NOTIONAL\"] = 29] = \"NOTIONAL\";\n    SpaceObjectType[SpaceObjectType[\"FRAGMENT\"] = 30] = \"FRAGMENT\";\n    SpaceObjectType[SpaceObjectType[\"SHORT_TERM_FENCE\"] = 31] = \"SHORT_TERM_FENCE\";\n    SpaceObjectType[SpaceObjectType[\"MAX_SPACE_OBJECT_TYPE\"] = 32] = \"MAX_SPACE_OBJECT_TYPE\";\n    SpaceObjectType[SpaceObjectType[\"TERRESTRIAL_PLANET\"] = 33] = \"TERRESTRIAL_PLANET\";\n    SpaceObjectType[SpaceObjectType[\"GAS_GIANT\"] = 34] = \"GAS_GIANT\";\n    SpaceObjectType[SpaceObjectType[\"ICE_GIANT\"] = 35] = \"ICE_GIANT\";\n    SpaceObjectType[SpaceObjectType[\"DWARF_PLANET\"] = 36] = \"DWARF_PLANET\";\n    SpaceObjectType[SpaceObjectType[\"MOON\"] = 37] = \"MOON\";\n})(SpaceObjectType || (SpaceObjectType = {}));\nexport var ZoomValue;\n(function (ZoomValue) {\n    ZoomValue[ZoomValue[\"LEO\"] = 0.45] = \"LEO\";\n    ZoomValue[ZoomValue[\"GEO\"] = 0.82] = \"GEO\";\n    ZoomValue[ZoomValue[\"MAX\"] = 1] = \"MAX\";\n})(ZoomValue || (ZoomValue = {}));\n/*\n * + Operational\n * - Nonoperational\n * P Partially Operational\n * Partially fulfilling primary mission or secondary mission(s)\n * B Backup/Standby\n * Previously operational satellite put into reserve status\n * S Spare\n * New satellite awaiting full activation\n * X Extended Mission\n * D Decayed\n * ? Unknown\n */\nexport var PayloadStatus;\n(function (PayloadStatus) {\n    PayloadStatus[\"OPERATIONAL\"] = \"+\";\n    PayloadStatus[\"NONOPERATIONAL\"] = \"-\";\n    PayloadStatus[\"PARTIALLY_OPERATIONAL\"] = \"P\";\n    PayloadStatus[\"BACKUP_STANDBY\"] = \"B\";\n    PayloadStatus[\"SPARE\"] = \"S\";\n    PayloadStatus[\"EXTENDED_MISSION\"] = \"X\";\n    PayloadStatus[\"DECAYED\"] = \"D\";\n    PayloadStatus[\"UNKNOWN\"] = \"?\";\n})(PayloadStatus || (PayloadStatus = {}));\n","/**\n * Full circle in radians (PI * 2)\n *\n * https://tauday.com/tau-manifesto\n */\nexport const TAU = (2.0 * Math.PI);\n/**\n * Represents half of the mathematical constant PI.\n */\nexport const halfPi = (0.5 * Math.PI);\n/**\n * Converts degrees to radians.\n */\nexport const DEG2RAD = (Math.PI / 180.0);\n/**\n * Converts radians to degrees.\n */\nexport const RAD2DEG = (180.0 / Math.PI);\n/**\n * Conversion factor from seconds to degrees.\n */\nexport const sec2deg = (1.0 / 60.0 / 60.0);\n/**\n * Conversion factor from seconds to days.\n */\nexport const sec2day = sec2deg / 24.0;\n/**\n * Conversion factor from arcseconds to radians.\n */\nexport const asec2rad = (sec2deg * DEG2RAD);\n/**\n * Convert ten-thousandths of an arcsecond to radians.\n */\nexport const ttasec2rad = (asec2rad / 10000.0);\n/**\n * Convert milliarcseconds to radians.\n */\nexport const masec2rad = (asec2rad / 1000.0);\n/**\n * The angular velocity of the Earth in radians per second.\n */\nexport const angularVelocityOfEarth = 7.292115e-5;\n/**\n * Astronomical unit in kilometers.\n */\nexport const astronomicalUnit = 149597870.0;\n// / Convert milliseconds to seconds.\nexport const msec2sec = 1e-3;\n// / Speed of light.\nexport const cMPerSec = 299792458;\nexport const cKmPerSec = 299792458 / 1000;\nexport const cKmPerMs = 299792458 / 1000 / 1000;\n// / Milliseconds per day.\nexport const MS_PER_DAY = 86400000;\n// / Seconds per day.\nexport const secondsPerDay = 86400.0;\n// / Convert seconds to minutes.\nexport const sec2min = (1.0 / 60.0);\n// / Seconds per sidereal day.\nexport const secondsPerSiderealDay = 86164.0905;\n// / Seconds per week.\nexport const secondsPerWeek = secondsPerDay * 7.0;\n/**\n * Half the number of radians in a circle.\n */\nexport const PI = Math.PI;\nexport const x2o3 = 2.0 / 3.0;\nexport const temp4 = 1.5e-12;\n/**\n * The number of minutes in a day.\n */\nexport const MINUTES_PER_DAY = 1440;\n/**\n * The number of milliseconds in a day.\n */\nexport const MILLISECONDS_TO_DAYS = 1.15741e-8;\n/**\n * The number of milliseconds in a day.\n */\nexport const MILLISECONDS_PER_DAY = 1000 * 60 * 60 * 24;\n/**\n * The number of milliseconds in a second.\n */\nexport const MILLISECONDS_PER_SECOND = 1000;\nexport const RADIUS_OF_EARTH = 6371; // Radius of Earth in kilometers\nexport const earthGravityParam = 398600.4415;\n","import { Tle, CovarianceSample, CovarianceFrame, StateCovariance } from '../main.js';\n/**\n * Creates a 6x6 state covariance matrix from a TLE\n * @param tleLine1 The first line of the TLE\n * @param tleLine2 The second line of the TLE\n * @param frame The covariance frame (CovarianceFrame.ECI or CovarianceFrame.RIC)\n * @param sigmaScale Scaling factor for the sigmas (default: 1.0)\n * @returns A StateCovariance object containing the 6x6 covariance matrix\n */\nexport function createCovarianceFromTle(tleLine1, tleLine2, frame = CovarianceFrame.RIC, sigmaScale = 1.0) {\n    // Parse the TLE and get the state vector\n    const tle = new Tle(tleLine1, tleLine2);\n    const temeState = tle.state;\n    const j2000State = temeState.toJ2000();\n    // eslint-disable-next-line no-console\n    console.log('J2000 State:', j2000State);\n    /*\n     * Determine appropriate sigma values based on TLE\n     * These are rough estimates and can be adjusted based on your needs\n     */\n    const positionSigma = 1.0 * sigmaScale; // km\n    const velocitySigma = 0.001 * sigmaScale; // km/s\n    // Create a diagonal covariance matrix with sigma values\n    const sigmas = [\n        positionSigma, positionSigma, positionSigma,\n        velocitySigma, velocitySigma, velocitySigma,\n    ];\n    // Generate the covariance matrix in the desired frame\n    return StateCovariance.fromSigmas(sigmas, frame);\n}\n/**\n * Creates a sample-based covariance from a TLE with more realistic uncertainties\n * @param tleLine1 The first line of the TLE\n * @param tleLine2 The second line of the TLE\n * @param frame The covariance frame (CovarianceFrame.ECI or CovarianceFrame.RIC)\n * @returns A StateCovariance object\n */\nexport function createSampleCovarianceFromTle(tleLine1, tleLine2, frame = CovarianceFrame.RIC) {\n    // Parse the TLE and get the state vector\n    const tle = new Tle(tleLine1, tleLine2);\n    const temeState = tle.state;\n    const j2000State = temeState.toJ2000();\n    /*\n     * Create initial covariance with basic sigma values\n     * Position uncertainties are higher in-track than radial/cross-track\n     * for most space catalog objects\n     */\n    const sigmas = frame === CovarianceFrame.RIC\n        ? [0.12, 1.0, 0.1, 0.00012, 0.001, 0.0001] // RIC frame: [R,I,C,Rdot,Idot,Cdot]\n        : [0.6, 0.6, 0.6, 0.0006, 0.0006, 0.0006]; // ECI frame: [x,y,z,vx,vy,vz]\n    const covariance = StateCovariance.fromSigmas(sigmas, frame);\n    // Create a covariance sample that will be used to generate a more realistic covariance\n    const sample = new CovarianceSample(j2000State, covariance, tle);\n    // Return the desample in the appropriate frame\n    return frame === CovarianceFrame.RIC ? sample.desampleRIC() : sample.desampleJ2000();\n}\n","/* eslint-disable require-jsdoc */\nimport { AngularDiameterMethod } from '../enums/AngularDiameterMethod.js';\nimport { AngularDistanceMethod } from '../enums/AngularDistanceMethod.js';\nimport { SpaceObjectType } from '../types/types.js';\nimport { angularVelocityOfEarth, cKmPerSec } from './constants.js';\n/**\n * Calculates the factorial of a given number.\n * @param n - The number to calculate the factorial for.\n * @returns The factorial of the given number.\n */\nexport function factorial(n) {\n    const nAbs = Math.abs(n);\n    let result = 1;\n    for (let i = 2; i <= nAbs; i++) {\n        result *= i;\n    }\n    return result;\n}\n/**\n * Calculates the base 10 logarithm of a number.\n * @param x - The number to calculate the logarithm for.\n * @returns The base 10 logarithm of the input number.\n */\nexport function log10(x) {\n    return Math.log(x) / Math.LN10;\n}\n/**\n * Calculates the hyperbolic secant of a number.\n * @param x - The number to calculate the hyperbolic secant of.\n * @returns The hyperbolic secant of the given number.\n */\nexport function sech(x) {\n    return 1 / Math.cosh(x);\n}\n/**\n * Calculates the hyperbolic cosecant of a number.\n * @param x - The number for which to calculate the hyperbolic cosecant.\n * @returns The hyperbolic cosecant of the given number.\n */\nexport function csch(x) {\n    return 1 / Math.sinh(x);\n}\n/**\n * Returns the inverse hyperbolic cosecant of a number.\n * @param x - The number to calculate the inverse hyperbolic cosecant of.\n * @returns The inverse hyperbolic cosecant of the given number.\n */\nexport function acsch(x) {\n    return Math.log(1 / x + Math.sqrt(1 / (x * x) + 1));\n}\n/**\n * Calculates the inverse hyperbolic secant (asech) of a number.\n * @param x - The number to calculate the inverse hyperbolic secant of.\n * @returns The inverse hyperbolic secant of the given number.\n */\nexport function asech(x) {\n    return Math.log(1 / x + Math.sqrt(1 / (x * x) - 1));\n}\n/**\n * Calculates the inverse hyperbolic cotangent (acoth) of a number.\n * @param x - The number to calculate the acoth of.\n * @returns The inverse hyperbolic cotangent of the given number.\n */\nexport function acoth(x) {\n    return 0.5 * Math.log((x + 1) / (x - 1));\n}\n/**\n * Copies the sign of the second number to the first number.\n * @param mag - The magnitude of the number.\n * @param sgn - The sign of the number.\n * @returns The number with the magnitude of `mag` and the sign of `sgn`.\n */\nexport function copySign(mag, sgn) {\n    return Math.abs(mag) * Math.sign(sgn);\n}\n/**\n * Evaluates a polynomial function at a given value.\n * @param x - The value at which to evaluate the polynomial.\n * @param coeffs - The coefficients of the polynomial.\n * @returns The result of evaluating the polynomial at the given value.\n */\nexport function evalPoly(x, coeffs) {\n    let result = coeffs[0];\n    for (let i = 1; i < coeffs.length; i++) {\n        result = result * x + coeffs[i];\n    }\n    return result;\n}\n/**\n * Concatenates two Float64Arrays into a new Float64Array.\n * @param a - The first Float64Array.\n * @param b - The second Float64Array.\n * @returns A new Float64Array containing the concatenated values of `a` and `b`.\n */\nexport function concat(a, b) {\n    const result = new Float64Array(a.length + b.length);\n    result.set(a);\n    result.set(b, a.length);\n    return result;\n}\n/**\n * Calculates the angle in the half-plane that best matches the given angle.\n * @param angle - The angle to be matched.\n * @param match - The angle to be matched against.\n * @returns The angle in the half-plane that best matches the given angle.\n */\nexport function matchHalfPlane(angle, match) {\n    const a1 = angle;\n    const a2 = 2 * Math.PI - angle;\n    const d1 = Math.atan2(Math.sin(a1 - match), Math.cos(a1 - match));\n    const d2 = Math.atan2(Math.sin(a2 - match), Math.cos(a2 - match));\n    return Math.abs(d1) < Math.abs(d2) ? a1 : a2;\n}\n/**\n * Wraps an angle to the range [-Ï€, Ï€].\n * @param theta - The angle to wrap.\n * @returns The wrapped angle.\n */\nexport function wrapAngle(theta) {\n    const result = ((theta + Math.PI) % (2 * Math.PI)) - Math.PI;\n    if (result === -Math.PI) {\n        return Math.PI;\n    }\n    return result;\n}\n/**\n * Calculates the angular distance between two points on a sphere using the cosine formula.\n * @param lam1 - The longitude of the first point in radians.\n * @param phi1 - The latitude of the first point in radians.\n * @param lam2 - The longitude of the second point in radians.\n * @param phi2 - The latitude of the second point in radians.\n * @returns The angular distance between the two points in radians.\n */\nfunction angularDistanceCosine_(lam1, phi1, lam2, phi2) {\n    const a = Math.sin(phi1) * Math.sin(phi2);\n    const b = Math.cos(phi1) * Math.cos(phi2) * Math.cos(lam2 - lam1);\n    return Math.acos(a + b);\n}\n/**\n * Calculates the angular distance between two points on a sphere using the Haversine formula.\n * @param lam1 - The longitude of the first point in radians.\n * @param phi1 - The latitude of the first point in radians.\n * @param lam2 - The longitude of the second point in radians.\n * @param phi2 - The latitude of the second point in radians.\n * @returns The angular distance between the two points in radians.\n */\nfunction angularDistanceHaversine_(lam1, phi1, lam2, phi2) {\n    const dlam = lam2 - lam1;\n    const dphi = phi2 - phi1;\n    const sdlam = Math.sin(0.5 * dlam);\n    const sdphi = Math.sin(0.5 * dphi);\n    const a = sdphi * sdphi + Math.cos(phi1) * Math.cos(phi2) * sdlam * sdlam;\n    return 2.0 * Math.asin(Math.min(1.0, Math.sqrt(a)));\n}\n/**\n * Calculates the angular distance between two points on a sphere.\n * @param lam1 The longitude of the first point.\n * @param phi1 The latitude of the first point.\n * @param lam2 The longitude of the second point.\n * @param phi2 The latitude of the second point.\n * @param method The method to use for calculating the angular distance. Defaults to AngularDistanceMethod.Cosine.\n * @returns The angular distance between the two points.\n * @throws Error if an invalid angular distance method is provided.\n */\nexport function angularDistance(lam1, phi1, lam2, phi2, method = AngularDistanceMethod.Cosine) {\n    switch (method) {\n        case AngularDistanceMethod.Cosine:\n            return angularDistanceCosine_(lam1, phi1, lam2, phi2);\n        case AngularDistanceMethod.Haversine:\n            return angularDistanceHaversine_(lam1, phi1, lam2, phi2);\n        default:\n            throw new Error('Invalid angular distance method.');\n    }\n}\n/**\n * Calculates the angular diameter of an object.\n * @param diameter - The diameter of the object.\n * @param distance - The distance to the object.\n * @param method - The method used to calculate the angular diameter. Defaults to AngularDiameterMethod.Sphere.\n * @returns The angular diameter of the object.\n * @throws Error if an invalid angular diameter method is provided.\n */\nexport function angularDiameter(diameter, distance, method = AngularDiameterMethod.Sphere) {\n    switch (method) {\n        case AngularDiameterMethod.Circle:\n            return 2 * Math.atan(diameter / (2 * distance));\n        case AngularDiameterMethod.Sphere:\n            return 2 * Math.asin(diameter / (2 * distance));\n        default:\n            throw new Error('Invalid angular diameter method.');\n    }\n}\n/**\n * Performs linear interpolation between two points.\n * @param x - The x-coordinate to interpolate.\n * @param x0 - The x-coordinate of the first point.\n * @param y0 - The y-coordinate of the first point.\n * @param x1 - The x-coordinate of the second point.\n * @param y1 - The y-coordinate of the second point.\n * @returns The interpolated y-coordinate corresponding to the given x-coordinate.\n */\nexport function linearInterpolate(x, x0, y0, x1, y1) {\n    return (y0 * (x1 - x) + y1 * (x - x0)) / (x1 - x0);\n}\n/**\n * Calculates the mean value of an array of numbers.\n * @param values - The array of numbers.\n * @returns The mean value of the numbers.\n */\nexport function mean(values) {\n    const n = values.length;\n    let sum = 0.0;\n    for (const v of values) {\n        sum += v;\n    }\n    return sum / n;\n}\n/**\n * Calculates the standard deviation of an array of numbers.\n * @param values - The array of numbers.\n * @param isSample - Optional. Specifies whether the array represents a sample. Default is false.\n * @returns The standard deviation of the array.\n */\nexport function std(values, isSample = false) {\n    const mu = mean(values);\n    const n = values.length;\n    let sum = 0.0;\n    for (const v of values) {\n        const sub = v - mu;\n        sum += sub * sub;\n    }\n    const m = isSample ? 1 : 0;\n    return Math.sqrt((1.0 / (n - m)) * sum);\n}\n/**\n * Calculates the covariance between two arrays.\n * @param a - The first array.\n * @param b - The second array.\n * @param isSample - Optional. Specifies whether the arrays represent a sample. Default is false.\n * @returns The covariance between the two arrays.\n */\nexport function covariance(a, b, isSample = false) {\n    const n = a.length;\n    const am = mean(a);\n    const bm = mean(b);\n    let result = 0.0;\n    for (let i = 0; i < n; i++) {\n        result += (a[i] - am) * (b[i] - bm);\n    }\n    const m = isSample ? 1 : 0;\n    return result / (n - m);\n}\n/**\n * Calculates the gamma function of a number.\n * @param n - The input number.\n * @returns The gamma function value.\n */\nexport function gamma(n) {\n    return factorial(n - 1);\n}\n/**\n * Calculates the eccentric anomaly (e0) and true anomaly (nu) using Newton's method\n * for a given eccentricity (ecc) and mean anomaly (m).\n * @param ecc - The eccentricity of the orbit.\n * @param m - The mean anomaly.\n * @returns An object containing the eccentric anomaly (e0) and true anomaly (nu).\n */\nexport function newtonM(ecc, m) {\n    const numiter = 50;\n    const small = 1e-8;\n    let e0;\n    let nu;\n    if (ecc > small) {\n        if ((m < 0.0 && m > -Math.PI) || m > Math.PI) {\n            e0 = m - ecc;\n        }\n        else {\n            e0 = m + ecc;\n        }\n        let ktr = 1;\n        let e1 = e0 + (m - e0 + ecc * Math.sin(e0)) / (1.0 - ecc * Math.cos(e0));\n        while (Math.abs(e1 - e0) > small && ktr <= numiter) {\n            ktr++;\n            e0 = e1;\n            e1 = e0 + (m - e0 + ecc * Math.sin(e0)) / (1.0 - ecc * Math.cos(e0));\n        }\n        const sinv = (Math.sqrt(1.0 - ecc * ecc) * Math.sin(e1)) / (1.0 - ecc * Math.cos(e1));\n        const cosv = (Math.cos(e1) - ecc) / (1.0 - ecc * Math.cos(e1));\n        nu = Math.atan2(sinv, cosv);\n    }\n    else {\n        nu = m;\n        e0 = m;\n    }\n    return { e0, nu };\n}\n/**\n * Calculates the eccentric anomaly (e0) and mean anomaly (m) using Newton's method\n * for a given eccentricity (ecc) and true anomaly (nu).\n * @param ecc - The eccentricity of the orbit.\n * @param nu - The true anomaly.\n * @returns An object containing the calculated eccentric anomaly (e0) and mean anomaly (m).\n */\nexport function newtonNu(ecc, nu) {\n    const small = 1e-8;\n    let e0 = 0.0;\n    let m = 0.0;\n    if (Math.abs(ecc) < small) {\n        m = nu;\n        e0 = nu;\n    }\n    else if (ecc < 1.0 - small) {\n        const sine = (Math.sqrt(1.0 - ecc * ecc) * Math.sin(nu)) / (1.0 + ecc * Math.cos(nu));\n        const cose = (ecc + Math.cos(nu)) / (1.0 + ecc * Math.cos(nu));\n        e0 = Math.atan2(sine, cose);\n        m = e0 - ecc * Math.sin(e0);\n    }\n    if (ecc < 1.0) {\n        m -= Math.floor(m / (2 * Math.PI)) * (2 * Math.PI);\n        if (m < 0.0) {\n            m += 2.0 * Math.PI;\n        }\n        e0 -= Math.floor(e0 / (2 * Math.PI)) * (2 * Math.PI);\n    }\n    return { e0, m: m };\n}\n/**\n * Creates a 2D array with the specified number of rows and columns, filled with the same given value.\n * @template T The type of elements in the array.\n * @param rows The number of rows in the 2D array.\n * @param columns The number of columns in the 2D array.\n * @param value The value to fill the array with.\n * @returns The 2D array with the specified number of rows and columns, filled with the given value.\n */\nexport function array2d(rows, columns, value) {\n    const output = [];\n    for (let i = 0; i < rows; i++) {\n        output.push(Array(columns).fill(value));\n    }\n    return output;\n}\n/**\n * Clamps a number between a minimum and maximum value.\n * @param x The number to clamp.\n * @param min The minimum value.\n * @param max The maximum value.\n * @returns The clamped number.\n */\nexport function clamp(x, min, max) {\n    return Math.max(min, Math.min(x, max));\n}\n/**\n * Determines whether a given year is a leap year.\n * @param dateIn The date to check.\n * @returns `true` if the year is a leap year, `false` otherwise.\n */\nexport function isLeapYear(dateIn) {\n    const year = dateIn.getUTCFullYear();\n    if ((year & 3) !== 0) {\n        return false;\n    }\n    return year % 100 !== 0 || year % 400 === 0;\n}\n/**\n * Calculates the day of the year for a given date.\n * If no date is provided, the current date is used.\n *\n * This is sometimes referred to as the Jday, but is\n * very different from the Julian day used in astronomy.\n * @param date - The date for which to calculate the day of the year.\n * @returns The day of the year as a number.\n */\nexport function getDayOfYear(date = new Date()) {\n    const dayCount = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n    const mn = date.getUTCMonth();\n    const dn = date.getUTCDate();\n    let dayOfYear = dayCount[mn] + dn;\n    if (mn > 1 && isLeapYear(date)) {\n        dayOfYear++;\n    }\n    return dayOfYear;\n}\n/**\n * Rounds a number to a specified number of decimal places.\n * @param value - The number to round.\n * @param places - The number of decimal places to round to.\n * @returns The rounded number.\n */\nexport function toPrecision(value, places) {\n    return Number(value.toFixed(places));\n}\n/**\n * Returns the sign of a number.\n * @param value - The number to determine the sign of.\n * @returns 1 if the number is positive, -1 if the number is negative.\n */\nexport function sign(value) {\n    return value >= 0 ? 1 : -1;\n}\nconst spaceObjTypeStrMap_ = {\n    [SpaceObjectType.UNKNOWN]: 'Unknown',\n    [SpaceObjectType.PAYLOAD]: 'Payload',\n    [SpaceObjectType.ROCKET_BODY]: 'Rocket Body',\n    [SpaceObjectType.DEBRIS]: 'Debris',\n    [SpaceObjectType.SPECIAL]: 'Special',\n    [SpaceObjectType.BALLISTIC_MISSILE]: 'Ballistic Missile',\n    [SpaceObjectType.STAR]: 'Star',\n    [SpaceObjectType.INTERGOVERNMENTAL_ORGANIZATION]: 'Intergovernmental Organization',\n    [SpaceObjectType.SUBORBITAL_PAYLOAD_OPERATOR]: 'Suborbital Payload Operator',\n    [SpaceObjectType.PAYLOAD_OWNER]: 'Payload Owner',\n    [SpaceObjectType.METEOROLOGICAL_ROCKET_LAUNCH_AGENCY_OR_MANUFACTURER]: 'Meteorological Rocket Launch Agency or Manufacturer',\n    [SpaceObjectType.PAYLOAD_MANUFACTURER]: 'Payload Manufacturer',\n    [SpaceObjectType.LAUNCH_AGENCY]: 'Launch Agency',\n    [SpaceObjectType.LAUNCH_SITE]: 'Launch Site',\n    [SpaceObjectType.LAUNCH_POSITION]: 'Launch Position',\n    [SpaceObjectType.LAUNCH_FACILITY]: 'Launch Facility',\n    [SpaceObjectType.CONTROL_FACILITY]: 'Control Facility',\n    [SpaceObjectType.GROUND_SENSOR_STATION]: 'Ground Sensor Station',\n    [SpaceObjectType.OPTICAL]: 'Optical',\n    [SpaceObjectType.MECHANICAL]: 'Mechanical',\n    [SpaceObjectType.PHASED_ARRAY_RADAR]: 'Phased Array Radar',\n    [SpaceObjectType.OBSERVER]: 'Observer',\n    [SpaceObjectType.BISTATIC_RADIO_TELESCOPE]: 'Bi-static Radio Telescope',\n    [SpaceObjectType.COUNTRY]: 'Country',\n    [SpaceObjectType.LAUNCH_VEHICLE_MANUFACTURER]: 'Launch Vehicle Manufacturer',\n    [SpaceObjectType.ENGINE_MANUFACTURER]: 'Engine Manufacturer',\n    [SpaceObjectType.NOTIONAL]: 'Notional',\n    [SpaceObjectType.FRAGMENT]: 'Fragment',\n    [SpaceObjectType.SHORT_TERM_FENCE]: 'Short Term Fence',\n    [SpaceObjectType.MAX_SPACE_OBJECT_TYPE]: 'Max Space Object Type',\n};\n/**\n * Converts a SpaceObjectType to a string representation.\n * @param spaceObjType - The SpaceObjectType to convert.\n * @returns The string representation of the SpaceObjectType.\n */\nexport const spaceObjType2Str = (spaceObjType) => spaceObjTypeStrMap_[spaceObjType] || 'Unknown';\n/**\n * Calculates the Doppler factor for a given location, position, and velocity.\n * The Doppler factor is a measure of the change in frequency or wavelength of a wave\n * as observed by an observer moving relative to the source of the wave.\n * @param location - The location vector of the observer.\n * @param position - The position vector of the source.\n * @param velocity - The velocity vector of the source.\n * @returns The calculated Doppler factor.\n */\nexport const dopplerFactor = (location, position, velocity) => {\n    const range = {\n        x: position.x - location.x,\n        y: position.y - location.y,\n        z: position.z - location.z,\n    };\n    const distance = Math.sqrt(range.x ** 2 + range.y ** 2 + range.z ** 2);\n    const rangeVel = {\n        x: velocity.x + angularVelocityOfEarth * location.y,\n        y: velocity.y - angularVelocityOfEarth * location.x,\n        z: velocity.z,\n    };\n    const rangeRate = (range.x * rangeVel.x + range.y * rangeVel.y + range.z * rangeVel.z) / distance;\n    const dopplerFactor = 1 - rangeRate / cKmPerSec;\n    return dopplerFactor;\n};\n/**\n * Creates an array of numbers from start to stop (inclusive) with the specified step.\n * @param start The starting number.\n * @param stop The ending number.\n * @param step The step value.\n * @returns An array of numbers.\n */\nexport function createVec(start, stop, step) {\n    const array = [];\n    for (let i = start; i <= stop; i += step) {\n        array.push(i);\n    }\n    return array;\n}\n/**\n * Calculates the derivative of a differentiable function.\n * @param f The differentiable function.\n * @param h The step size for numerical differentiation. Default value is 1e-3.\n * @returns The derivative function.\n */\nexport function derivative(f, h = 1e-3) {\n    /**\n     * @param x The value at which to calculate the derivative.\n     * @returns The derivative of the function at the given value.\n     */\n    function df(x) {\n        const hh = h * 0.5;\n        return (f(x + hh) - f(x - hh)) / h;\n    }\n    return df;\n}\n","export * from './functions.js';\nexport * from './constants.js';\nexport * from './linearDistance.js';\nexport * from './jacobian.js';\nexport * from './create-covariance-from-tle.js';\n","import { array2d, Matrix, Vector } from '../main.js';\n/**\n * Calculates the Jacobian matrix of a given Jacobian function.\n *\n * The function calculates how small perturbations in each input variable affect all output variables,\n * using a second-order accurate central difference approximation.\n *\n * In orbital mechanics applications, this matrix is essential for solving complex problems like\n * orbit transfers, trajectory optimization, and precise orbital determination.\n * @param f The Jacobian function.\n * @param m The number of rows in the Jacobian matrix.\n * @param x0 The initial values of the variables.\n * @param step The step size for numerical differentiation (default: 1e-5).\n * @returns The Jacobian matrix.\n */\nexport const jacobian = (f, m, x0, step = 0.00001) => {\n    const n = x0.length;\n    const j = array2d(m, n, 0);\n    const h = 0.5 * step;\n    for (let k = 0; k < n; k++) {\n        const xp = x0.slice();\n        xp[k] += h;\n        const fp = new Vector(f(xp));\n        const xm = x0.slice();\n        xm[k] -= h;\n        const fm = new Vector(f(xm));\n        const cd = fp.subtract(fm).scale(1 / step);\n        for (let i = 0; i < m; i++) {\n            j[i][k] = cd.elements[i];\n        }\n    }\n    return new Matrix(j);\n};\n","/**\n * Calculates the linear distance between two points in three-dimensional space.\n * @param pos1 The first position.\n * @param pos2 The second position.\n * @returns The linear distance between the two positions in kilometers.\n */\nexport function linearDistance(pos1, pos2) {\n    return Math.sqrt((pos1.x - pos2.x) ** 2 + (pos1.y - pos2.y) ** 2 + (pos1.z - pos2.z) ** 2);\n}\n","/**\n * /////////////////////////////////////////////////////////////////////////////\n *\n * The file constants.ts contains a set of constants used in the KeepTrack application.\n * It defines constants related to zooming, radians, degrees, milliseconds, Earth's gravitational\n * constant, minutes, distances of the Sun and Moon from the Earth, and more.\n * https://github.com/Pownkumar1234/powney---3d-satelite-toolkit\n *\n * @Copyright (C) 2025 Kruczek Labs LLC\n *\n * KeepTrack is free software: you can redistribute it and/or modify it under the\n * terms of the GNU Affero General Public License as published by the Free Software\n * Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * KeepTrack is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along with\n * KeepTrack. If not, see <http://www.gnu.org/licenses/>.\n *\n * /////////////////////////////////////////////////////////////////////////////\n */\n/**\n * Exponent used for calculating zoom distance.\n */\nexport const ZOOM_EXP = 3.8;\n/**\n * Earths gravitational constant.\n */\nexport const EARTHS_GRAV_CONST = 6.6725985e-11;\n/**\n * The mass of the Earth in kilograms.\n */\nexport const MASS_OF_EARTH = 5.97378250603408e24;\n/**\n * The offset away from the earth when drawing the camera in Planetarium or Astronomy modes.\n */\nexport const PLANETARIUM_DIST = 3;\n/**\n * The radius used to draw the Sun in kilometers.\n * This value is used to scale the Sun's size when rendering it.\n */\nexport const RADIUS_OF_DRAW_SUN = 9000;\n/**\n * The scalar distance used to draw the Sun.\n * This value is used to scale the Sun's size and distance from the Earth.\n */\nexport const SUN_SCALAR_DISTANCE = 250000;\n/**\n * The radius used to draw the Moon in kilometers.\n * This value is used to scale the Moon's size when rendering it.\n */\nexport const RADIUS_OF_DRAW_MOON = 4000;\n/**\n * The scalar distance used to draw the Moon.\n * This value is used to scale the Moon's size and distance from the Earth.\n */\nexport const MOON_SCALAR_DISTANCE = 200000;\n/**\n * Radius of the Earth in kilometers.\n */\nexport const RADIUS_OF_EARTH = 6371; // Radius of Earth in kilometers\n/**\n * Distance objects are placed above earth to avoid z-buffer fighting\n */\nexport const GROUND_BUFFER_DISTANCE = 2.5;\n/**\n * Radius of the Sun in kilometers\n */\nexport const RADIUS_OF_SUN = 695700;\n/**\n * Artificial Star Distance - Lower number Reduces webgl depth buffer\n */\nexport const STAR_DISTANCE = 250000;\n/**\n * Distance from Earth to the Sun in kilometers\n */\nexport const DISTANCE_TO_SUN = 149597870; // Distance from Earth to the Sun in kilometers\n/**\n * Earth's Obliquity in degrees\n */\nexport const EARTH_OBLIQUITY_DEGREES = 23.438480461241912;\n/**\n * Earth's Obliquity in radians\n */\nexport const EARTH_OBLIQUITY_RADIANS = EARTH_OBLIQUITY_DEGREES * (Math.PI / 180);\n","/* eslint-disable */\n// @ts-nocheck\nconst A = {\n    JMod: 2400000.5,\n    J2000: 2451545,\n    J1900: 2415020,\n    B1900: 2415020.3135,\n    B1950: 2433282.4235,\n    JulianYear: 365.25,\n    JulianCentury: 36525,\n    BesselianYear: 365.2421988,\n    AU: 149597870,\n};\nA.EclCoord = function (a, b, c) {\n    if (isNaN(a) || isNaN(b))\n        throw Error('Invalid EclCoord object: (' + a + ', ' + b + ')');\n    this.lat = a;\n    this.lng = b;\n    void 0 !== c && (this.h = c);\n};\nA.EclCoord.prototype = {\n    toWgs84String: function () {\n        return A.Math.formatNum((180 * this.lat) / Math.PI) + ', ' + A.Math.formatNum((180 * -this.lng) / Math.PI);\n    },\n};\nA.EclCoordfromWgs84 = function (a, b, c) {\n    return new A.EclCoord((a * Math.PI) / 180, (-b * Math.PI) / 180, c);\n};\nA.EqCoord = function (a, b) {\n    if (isNaN(a) || isNaN(b))\n        throw Error('Invalid EqCoord object: (' + a + ', ' + b + ')');\n    this.ra = a;\n    this.dec = b;\n};\nA.EqCoord.prototype = {\n    toString: function () {\n        return 'ra:' + A.Math.formatNum((180 * this.ra) / Math.PI) + ', dec:' + A.Math.formatNum((180 * this.dec) / Math.PI);\n    },\n};\nA.HzCoord = function (a, b) {\n    if (isNaN(a) || isNaN(b))\n        throw Error('Invalid HzCoord object: (' + a + ', ' + b + ')');\n    this.az = a;\n    this.alt = b;\n};\nA.HzCoord.prototype = {\n    toString: function () {\n        return 'azi:' + A.Math.formatNum((180 * this.az) / Math.PI) + ', alt:' + A.Math.formatNum((180 * this.alt) / Math.PI);\n    },\n};\nA.Coord = {\n    dmsToDeg: function (a, b, c, d) {\n        d = (60 * (60 * b + c) + d) / 3600;\n        return a ? -d : d;\n    },\n    calcAngle: function (a, b, c, d) {\n        return (A.Coord.dmsToDeg(a, b, c, d) * Math.PI) / 180;\n    },\n    calcRA: function (a, b, c) {\n        return ((A.Coord.dmsToDeg(!1, a, b, c) % 24) * 15 * Math.PI) / 180;\n    },\n    secondsToHMSStr: function (a) {\n        var b = Math.floor(a / 86400);\n        a = A.Math.pMod(a, 86400);\n        var c = Math.floor(a / 3600) % 24, d = Math.floor(a / 60) % 60;\n        a = Math.floor(a % 60);\n        return (0 !== b ? b + 'd ' : '') + (10 > c ? '0' : '') + c + ':' + (10 > d ? '0' : '') + d + ':' + (10 > a ? '0' : '') + a;\n    },\n    secondsToHMStr: function (a) {\n        var b = Math.floor(a / 86400);\n        a = A.Math.pMod(a, 86400);\n        var c = Math.floor(a / 3600) % 24;\n        a = Math.floor(a / 60) % 60;\n        return (0 !== b ? b + 'd ' : '') + (10 > c ? '0' : '') + c + ':' + (10 > a ? '0' : '') + a;\n    },\n    eqToEcl: function (a, b) {\n        var c = Math.sin(a.ra), d = Math.sin(a.dec), e = Math.cos(a.dec), f = Math.sin(b);\n        b = Math.cos(b);\n        return new A.EclCoord(Math.atan2(c * b + (d / e) * f, Math.cos(a.ra)), Math.asin(d * b - e * f * c));\n    },\n    eclToEq: function (a, b) {\n        var c = Math.sin(a.lat), d = Math.sin(a.lng), e = Math.cos(a.lng), f = Math.sin(b);\n        b = Math.cos(b);\n        let a2 = Math.atan2(c * b - (d / e) * f, Math.cos(a.lat));\n        0 > a2 && (a2 += 2 * Math.PI);\n        return new A.EqCoord(a2, Math.asin(d * b + e * f * c));\n    },\n    eqToHz: function (a, b, c) {\n        c = c - b.lng - a.ra;\n        var d = Math.cos(c), e = Math.sin(b.lat);\n        b = Math.cos(b.lat);\n        var f = Math.sin(a.dec);\n        a = Math.cos(a.dec);\n        return new A.HzCoord(Math.atan2(Math.sin(c), d * e - (f / a) * b), Math.asin(e * f + b * a * d));\n    },\n};\nA.DeltaT = {\n    jdToJde: function (a, b) {\n        b || (b = A.DeltaT.estimate(a));\n        return a + b / 86400;\n    },\n    jdeToJd: function (a, b) {\n        b || (b = A.DeltaT.estimate(a));\n        return a - b / 86400;\n    },\n    decimalYear: function (a) {\n        a = A.JulianDay.jdToCalendar(a);\n        return a.y + (a.m - 0.5) / 12;\n    },\n    estimate: function (a) {\n        var b = A.DeltaT.decimalYear(a);\n        a = Math.pow;\n        return -500 > b\n            ? -20 + 32 * a((b - 1820) / 100, 2)\n            : 500 > b\n                ? ((b /= 100), 10583.6 - 1014.41 * b + 33.78311 * a(b, 2) - 5.952053 * a(b, 3) - 0.1798452 * a(b, 4) + 0.022174192 * a(b, 5) + 0.0090316521 * a(b, 6))\n                : 1600 > b\n                    ? ((b = (b - 1e3) / 100), 1574.2 - 556.01 * b + 71.23472 * a(b, 2) + 0.319781 * a(b, 3) - 0.8503463 * a(b, 4) - 0.005050998 * a(b, 5) + 0.0083572073 * a(b, 6))\n                    : 1700 > b\n                        ? ((b -= 1600), 120 - 0.9808 * b - 0.01532 * a(b, 2) + a(b, 3) / 7129)\n                        : 1800 > b\n                            ? ((b -= 1700), 8.83 + 0.1603 * b - 0.0059285 * a(b, 2) + 1.3336e-4 * a(b, 3) - a(b, 4) / 1174e3)\n                            : 1860 > b\n                                ? ((b -= 1800), 13.72 - 0.332447 * b + 0.0068612 * a(b, 2) + 0.0041116 * a(b, 3) - 3.7436e-4 * a(b, 4) + 1.21272e-5 * a(b, 5) - 1.699e-7 * a(b, 6) + 8.75e-10 * a(b, 7))\n                                : 1900 > b\n                                    ? ((b -= 1860), 7.62 + 0.5737 * b - 0.251754 * a(b, 2) + 0.01680668 * a(b, 3) - 4.473624e-4 * a(b, 4) + a(b, 5) / 233174)\n                                    : 1920 > b\n                                        ? ((b -= 1900), -2.79 + 1.494119 * b - 0.0598939 * a(b, 2) + 0.0061966 * a(b, 3) - 1.97e-4 * a(b, 4))\n                                        : 1941 > b\n                                            ? ((b -= 1920), 21.2 + 0.84493 * b - 0.0761 * a(b, 2) + 0.0020936 * a(b, 3))\n                                            : 1961 > b\n                                                ? ((b -= 1950), 29.07 + 0.407 * b - a(b, 2) / 233 + a(b, 3) / 2547)\n                                                : 1986 > b\n                                                    ? ((b -= 1975), 45.45 + 1.067 * b - a(b, 2) / 260 - a(b, 3) / 718)\n                                                    : 2005 > b\n                                                        ? ((b -= 2e3), 63.86 + 0.3345 * b - 0.060374 * a(b, 2) + 0.0017275 * a(b, 3) + 6.51814e-4 * a(b, 4) + 2.373599e-5 * a(b, 5))\n                                                        : 2050 > b\n                                                            ? ((b -= 2e3), 62.92 + 0.32217 * b + 0.005589 * a(b, 2))\n                                                            : 2150 > b\n                                                                ? -20 + 32 * a((b - 1820) / 100, 2) - 0.5628 * (2150 - b)\n                                                                : -20 + 32 * a((b - 1820) / 100, 2);\n    },\n};\nA.Globe = {\n    Er: 6378.14,\n    Fl: 1 / 298.257,\n    parallaxConstants: function (a, b) {\n        b || (b = 0);\n        var c = 1 - A.Globe.Fl;\n        b = (0.001 * b) / A.Globe.Er;\n        return { rhoslat: Math.sin(Math.atan(c * Math.tan(a))) * c + b * Math.sin(a), rhoclat: Math.cos(Math.atan(c * Math.tan(a))) + b * Math.cos(a) };\n    },\n};\nA.Interp = {\n    newLen3: function (a, b, c) {\n        if (3 != c.length)\n            throw 'Error not 3';\n        if (b === a)\n            throw 'Error no x range';\n        var d = c[1] - c[0], e = c[2] - c[1];\n        return { x1: a, x3: b, y: c, a: d, b: e, c: e - d, abSum: d + e, xSum: b + a, xDiff: b - a };\n    },\n    interpolateX: function (a, b) {\n        return A.Interp.interpolateN(a, (2 * b - a.xSum) / a.xDiff);\n    },\n    interpolateN: function (a, b) {\n        return a.y[1] + 0.5 * b * (a.abSum + b * a.c);\n    },\n};\nA.JulianDay = function (a, b) {\n    a instanceof Date && (a = A.JulianDay.dateToJD(a));\n    this.jd = a;\n    this.deltaT = b ? b : A.DeltaT.estimate(this.jd);\n    this.jde = A.DeltaT.jdToJde(this.jd, this.deltaT);\n};\nA.JulianDay.prototype = {\n    toCalendar: function () {\n        return A.JulianDay.jdToCalendar(this.jd);\n    },\n    toDate: function () {\n        return A.JulianDay.jdToDate(this.jd);\n    },\n    jdJ2000Century: function () {\n        return (this.jd - A.J2000) / A.JulianCentury;\n    },\n    jdeJ2000Century: function () {\n        return (this.jde - A.J2000) / A.JulianCentury;\n    },\n    startOfDay: function () {\n        return new A.JulianDay(Math.floor(this.jde - 0.5) + 0.5, this.deltaT);\n    },\n};\nA.JulianDay.gregorianTimeStart = Date.UTC(1582, 9, 4);\nA.JulianDay.jdFromGregorian = function (a, b, c) {\n    return new A.JulianDay(A.JulianDay.jdFromGregorian(a, b, c));\n};\nA.JulianDay.jdFromJulian = function (a, b, c) {\n    return new A.JulianDay(A.JulianDay.calendarJulianToJD(a, b, c));\n};\nA.JulianDay.jdFromJDE = function (a) {\n    var b = A.DeltaT.estimate(a);\n    a = A.DeltaT.jdeToJd(a, b);\n    return new A.JulianDay(a, b);\n};\nA.JulianDay.dateToJD = function (a) {\n    var b = a.getUTCDate() + A.JulianDay.secondsFromHMS(a.getUTCHours(), a.getUTCMinutes(), a.getUTCSeconds()) / 86400;\n    return a.getTime() < A.JulianDay.gregorianTimeStart\n        ? A.JulianDay.calendarJulianToJD(a.getUTCFullYear(), a.getUTCMonth() + 1, b)\n        : A.JulianDay.calendarGregorianToJD(a.getUTCFullYear(), a.getUTCMonth() + 1, b);\n};\nA.JulianDay.calendarGregorianToJD = function (a, b, c) {\n    if (1 === b || 2 === b)\n        a--, (b += 12);\n    var d = Math.floor(a / 100);\n    return Math.floor((36525 * (a + 4716)) / 100) + Math.floor((306 * (b + 1)) / 10) + (2 - d + Math.floor(d / 4)) + c - 1524.5;\n};\nA.JulianDay.calendarJulianToJD = function (a, b, c) {\n    if (1 === b || 2 === b)\n        a--, (b += 12);\n    return Math.floor((36525 * (a + 4716)) / 100) + Math.floor((306 * (b + 1)) / 10) + c - 1524.5;\n};\nA.JulianDay.secondsFromHMS = function (a, b, c) {\n    return 3600 * a + 60 * b + c;\n};\nA.JulianDay.jdToDate = function (a) {\n    var b = A.JulianDay.jdToCalendar(a);\n    a = A.Math.modF(a + 0.5)[1];\n    a = Math.round(86400 * a);\n    return new Date(Date.UTC(b.y, b.m - 1, Math.floor(b.d), Math.floor(a / 3600) % 24, Math.floor(a / 60) % 60, Math.floor(a % 60)));\n};\nA.JulianDay.jdToCalendar = function (a) {\n    a = A.Math.modF(a + 0.5);\n    var b = a[0], c = b;\n    2299151 <= b && ((c = Math.floor((100 * b - 186721625) / 3652425)), (c = b + 1 + c - Math.floor(c / 4)));\n    var d = c + 1524;\n    b = Math.floor((100 * d - 12210) / 36525);\n    var e = Math.floor((36525 * b) / 100);\n    c = Math.floor((1e4 * (d - e)) / 306001);\n    a = d - e - Math.floor((306001 * c) / 1e4) + a[1];\n    c = 14 === c || 15 === c ? c - 13 : c - 1;\n    return { y: 1 === c || 2 === c ? Math.floor(b) - 4715 : Math.floor(b) - 4716, m: c, d: a };\n};\nA.JulianDay.leapYearGregorian = function (a) {\n    return (0 === a % 4 && 0 !== a % 100) || 0 === a % 400;\n};\nA.JulianDay.dayOfYear = function (a, b, c, d) {\n    a = 2;\n    d && a--;\n    return A.JulianDay._wholeMonths(b, a) + c;\n};\nA.JulianDay._wholeMonths = function (a, b) {\n    return Math.round((275 * a) / 9 - ((a + 9) / 12) * b - 30);\n};\nA.Math = {\n    pMod: function (a, b) {\n        a %= b;\n        0 > a && (a += b);\n        return a;\n    },\n    modF: function (a) {\n        return 0 > a ? ((a = -a), [-Math.floor(a), -(a % 1)]) : [Math.floor(a), a % 1];\n    },\n    horner: function (a, b) {\n        var c = b.length - 1;\n        if (0 >= c)\n            throw 'empty array not supported';\n        for (var d = b[c]; 0 < c;)\n            c--, (d = d * a + b[c]);\n        return d;\n    },\n    formatNum: function (a, b) {\n        b = Math.pow(10, b | 4);\n        return Math.round(a * b) / b;\n    },\n};\nA.Moon = {\n    parallax: function (a) {\n        return Math.asin(6378.14 / a);\n    },\n    apparentEquatorial: function (a) {\n        var b = A.Moon.geocentricPosition(a), c = A.Nutation.nutation(a);\n        a = A.Nutation.meanObliquityLaskar(a) + c.deltaobliquity;\n        return { eq: A.Coord.eclToEq(new A.EclCoord(b.lng + c.deltalng, b.lat), a), delta: b.delta };\n    },\n    apparentTopocentric: function (a, b, c) {\n        var d = A.Moon.apparentEquatorial(a), e = A.Globe.parallaxConstants(b.lat, b.h), f = A.Moon.parallax(d.delta);\n        c || (c = A.Sidereal.apparentInRa(a));\n        return { eq: A.Parallax.topocentric(d.eq, f, e.rhoslat, e.rhoclat, b.lng, c), delta: d.delta };\n    },\n    topocentricPosition: function (a, b, c) {\n        var d = A.Sidereal.apparentInRa(a);\n        a = A.Moon.apparentTopocentric(a, b, d);\n        var e = A.Coord.eqToHz(a.eq, b, d);\n        !0 === c && (e.alt += A.Refraction.bennett2(e.alt));\n        b = A.Moon.parallacticAngle(b.lat, d - (b.lng + a.eq.ra), a.eq.dec);\n        return { hz: e, eq: a.eq, delta: a.delta, q: b };\n    },\n    approxTransit: function (a, b) {\n        a = a.startOfDay();\n        return A.Rise.approxTransit(b, A.Sidereal.apparent0UT(a), A.Moon.apparentTopocentric(a, b).eq);\n    },\n    approxTimes: function (a, b) {\n        a = a.startOfDay();\n        var c = A.Moon.apparentTopocentric(a, b), d = A.Moon.parallax(c.delta);\n        d = A.Rise.stdh0Lunar(d);\n        a = A.Sidereal.apparent0UT(a);\n        return A.Rise.approxTimes(b, d, a, c.eq);\n    },\n    times: function (a, b) {\n        a = a.startOfDay();\n        var c = A.Moon.apparentTopocentric(new A.JulianDay(a.jd - 1, a.deltaT), b), d = A.Moon.apparentTopocentric(a, b), e = A.Moon.apparentTopocentric(new A.JulianDay(a.jd + 1, a.deltaT), b), f = A.Moon.parallax(d.delta);\n        f = A.Rise.stdh0Lunar(f);\n        var g = A.Sidereal.apparent0UT(a);\n        return A.Rise.times(b, a.deltaT, f, g, [c.eq, d.eq, e.eq]);\n    },\n    parallacticAngle: function (a, b, c) {\n        return Math.atan2(Math.sin(b), Math.tan(a) * Math.cos(c) - Math.sin(c) * Math.cos(b));\n    },\n    geocentricPosition: function (a) {\n        var b = Math.PI / 180, c = a.jdeJ2000Century();\n        a = A.Math.pMod(A.Math.horner(c, [218.3164477 * b, 481267.88123421 * b, -0.0015786 * b, b / 538841, -b / 65194e3]), 2 * Math.PI);\n        var d = A.Math.pMod(A.Math.horner(c, [297.8501921 * b, 445267.1114034 * b, -0.0018819 * b, b / 545868, -b / 113065e3]), 2 * Math.PI), e = A.Math.pMod(A.Math.horner(c, [357.5291092 * b, 35999.0502909 * b, -1.535e-4 * b, b / 2449e4]), 2 * Math.PI), f = A.Math.pMod(A.Math.horner(c, [134.9633964 * b, 477198.8675055 * b, 0.0087414 * b, b / 69699, -b / 14712e3]), 2 * Math.PI), g = A.Math.pMod(A.Math.horner(c, [93.272095 * b, 483202.0175233 * b, -0.0036539 * b, -b / 3526e3, b / 86331e4]), 2 * Math.PI), l = 119.75 * b + 131.849 * b * c, m = 53.09 * b + 479264.29 * b * c, h = 313.45 * b + 481266.484 * b * c;\n        c = A.Math.horner(c, [1, -0.002516, -7.4e-6]);\n        var p = c * c;\n        m = 3958 * Math.sin(l) + 1962 * Math.sin(a - g) + 318 * Math.sin(m);\n        var n = 0;\n        l = -2235 * Math.sin(a) + 382 * Math.sin(h) + 175 * Math.sin(l - g) + 175 * Math.sin(l + g) + 127 * Math.sin(a - f) - 115 * Math.sin(a + f);\n        for (h = 0; h < A.Moon.ta.length; h++) {\n            var k = A.Moon.ta[h];\n            var r = d * k[0] + e * k[1] + f * k[2] + g * k[3], q = Math.sin(r);\n            r = Math.cos(r);\n            switch (k[1]) {\n                case 0:\n                    m += k[4] * q;\n                    n += k[5] * r;\n                    break;\n                case 1:\n                case -1:\n                    m += k[4] * q * c;\n                    n += k[5] * r * c;\n                    break;\n                case 2:\n                case -2:\n                    m += k[4] * q * p;\n                    n += k[5] * r * p;\n                    break;\n                default:\n                    throw 'error';\n            }\n        }\n        for (h = 0; h < A.Moon.tb.length; h++)\n            switch (((k = A.Moon.tb[h]), (q = Math.sin(d * k[0] + e * k[1] + f * k[2] + g * k[3])), k[1])) {\n                case 0:\n                    l += k[4] * q;\n                    break;\n                case 1:\n                case -1:\n                    l += k[4] * q * c;\n                    break;\n                case 2:\n                case -2:\n                    l += k[4] * q * p;\n                    break;\n                default:\n                    throw 'error';\n            }\n        return { lng: A.Math.pMod(a, 2 * Math.PI) + 1e-6 * m * b, lat: 1e-6 * l * b, delta: 385000.56 + 0.001 * n };\n    },\n    ta: [\n        [0, 0, 1, 0, 6288774, -20905355],\n        [2, 0, -1, 0, 1274027, -3699111],\n        [2, 0, 0, 0, 658314, -2955968],\n        [0, 0, 2, 0, 213618, -569925],\n        [0, 1, 0, 0, -185116, 48888],\n        [0, 0, 0, 2, -114332, -3149],\n        [2, 0, -2, 0, 58793, 246158],\n        [2, -1, -1, 0, 57066, -152138],\n        [2, 0, 1, 0, 53322, -170733],\n        [2, -1, 0, 0, 45758, -204586],\n        [0, 1, -1, 0, -40923, -129620],\n        [1, 0, 0, 0, -34720, 108743],\n        [0, 1, 1, 0, -30383, 104755],\n        [2, 0, 0, -2, 15327, 10321],\n        [0, 0, 1, 2, -12528, 0],\n        [0, 0, 1, -2, 10980, 79661],\n        [4, 0, -1, 0, 10675, -34782],\n        [0, 0, 3, 0, 10034, -23210],\n        [4, 0, -2, 0, 8548, -21636],\n        [2, 1, -1, 0, -7888, 24208],\n        [2, 1, 0, 0, -6766, 30824],\n        [1, 0, -1, 0, -5163, -8379],\n        [1, 1, 0, 0, 4987, -16675],\n        [2, -1, 1, 0, 4036, -12831],\n        [2, 0, 2, 0, 3994, -10445],\n        [4, 0, 0, 0, 3861, -11650],\n        [2, 0, -3, 0, 3665, 14403],\n        [0, 1, -2, 0, -2689, -7003],\n        [2, 0, -1, 2, -2602, 0],\n        [2, -1, -2, 0, 2390, 10056],\n        [1, 0, 1, 0, -2348, 6322],\n        [2, -2, 0, 0, 2236, -9884],\n        [0, 1, 2, 0, -2120, 5751],\n        [0, 2, 0, 0, -2069, 0],\n        [2, -2, -1, 0, 2048, -4950],\n        [2, 0, 1, -2, -1773, 4130],\n        [2, 0, 0, 2, -1595, 0],\n        [4, -1, -1, 0, 1215, -3958],\n        [0, 0, 2, 2, -1110, 0],\n        [3, 0, -1, 0, -892, 3258],\n        [2, 1, 1, 0, -810, 2616],\n        [4, -1, -2, 0, 759, -1897],\n        [0, 2, -1, 0, -713, -2117],\n        [2, 2, -1, 0, -700, 2354],\n        [2, 1, -2, 0, 691, 0],\n        [2, -1, 0, -2, 596, 0],\n        [4, 0, 1, 0, 549, -1423],\n        [0, 0, 4, 0, 537, -1117],\n        [4, -1, 0, 0, 520, -1571],\n        [1, 0, -2, 0, -487, -1739],\n        [2, 1, 0, -2, -399, 0],\n        [0, 0, 2, -2, -381, -4421],\n        [1, 1, 1, 0, 351, 0],\n        [3, 0, -2, 0, -340, 0],\n        [4, 0, -3, 0, 330, 0],\n        [2, -1, 2, 0, 327, 0],\n        [0, 2, 1, 0, -323, 1165],\n        [1, 1, -1, 0, 299, 0],\n        [2, 0, 3, 0, 294, 0],\n        [2, 0, -1, -2, 0, 8752],\n    ],\n    tb: [\n        [0, 0, 0, 1, 5128122],\n        [0, 0, 1, 1, 280602],\n        [0, 0, 1, -1, 277693],\n        [2, 0, 0, -1, 173237],\n        [2, 0, -1, 1, 55413],\n        [2, 0, -1, -1, 46271],\n        [2, 0, 0, 1, 32573],\n        [0, 0, 2, 1, 17198],\n        [2, 0, 1, -1, 9266],\n        [0, 0, 2, -1, 8822],\n        [2, -1, 0, -1, 8216],\n        [2, 0, -2, -1, 4324],\n        [2, 0, 1, 1, 4200],\n        [2, 1, 0, -1, -3359],\n        [2, -1, -1, 1, 2463],\n        [2, -1, 0, 1, 2211],\n        [2, -1, -1, -1, 2065],\n        [0, 1, -1, -1, -1870],\n        [4, 0, -1, -1, 1828],\n        [0, 1, 0, 1, -1794],\n        [0, 0, 0, 3, -1749],\n        [0, 1, -1, 1, -1565],\n        [1, 0, 0, 1, -1491],\n        [0, 1, 1, 1, -1475],\n        [0, 1, 1, -1, -1410],\n        [0, 1, 0, -1, -1344],\n        [1, 0, 0, -1, -1335],\n        [0, 0, 3, 1, 1107],\n        [4, 0, 0, -1, 1021],\n        [4, 0, -1, 1, 833],\n        [0, 0, 1, -3, 777],\n        [4, 0, -2, 1, 671],\n        [2, 0, 0, -3, 607],\n        [2, 0, 2, -1, 596],\n        [2, -1, 1, -1, 491],\n        [2, 0, -2, 1, -451],\n        [0, 0, 3, -1, 439],\n        [2, 0, 2, 1, 422],\n        [2, 0, -3, -1, 421],\n        [2, 1, -1, 1, -366],\n        [2, 1, 0, 1, -351],\n        [4, 0, 0, 1, 331],\n        [2, -1, 1, 1, 315],\n        [2, -2, 0, -1, 302],\n        [0, 0, 1, 3, -283],\n        [2, 1, 1, -1, -229],\n        [1, 1, 0, -1, 223],\n        [1, 1, 0, 1, 223],\n        [0, 1, -2, -1, -220],\n        [2, 1, -1, -1, -220],\n        [1, 0, 1, 1, -185],\n        [2, -1, -2, -1, 181],\n        [0, 1, 2, 1, -177],\n        [4, 0, -2, -1, 176],\n        [4, -1, -1, -1, 166],\n        [1, 0, 1, -1, -164],\n        [4, 0, 1, -1, 132],\n        [1, 0, -1, -1, -119],\n        [4, -1, 0, -1, 115],\n        [2, -2, 0, 1, 107],\n    ],\n};\nA.MoonIllum = {\n    phaseAngleEq: function (a, b, c, d) {\n        a = A.MoonIllum._coselong(a, c);\n        return Math.atan2(d * Math.sin(Math.acos(a)), b - d * a);\n    },\n    phaseAngleEq2: function (a, b) {\n        return Math.acos(-A.MoonIllum._coselong(a, b));\n    },\n    illuminated: function (a) {\n        return (1 + Math.cos(a)) / 2;\n    },\n    positionAngle: function (a, b) {\n        var c = Math.cos(b.dec);\n        return Math.atan2(c * Math.sin(b.ra - a.ra), Math.sin(b.dec) * Math.cos(a.dec) - c * Math.sin(a.dec) * Math.cos(b.ra - a.ra));\n    },\n    _coselong: function (a, b) {\n        return Math.sin(b.dec) * Math.sin(a.dec) + Math.cos(b.dec) * Math.cos(a.dec) * Math.cos(b.ra - a.ra);\n    },\n};\nA.Nutation = {\n    nutation: function (a) {\n        a = a.jdeJ2000Century();\n        for (var b = (A.Math.horner(a, [297.85036, 445267.11148, -0.0019142, 1 / 189474]) * Math.PI) / 180, c = (A.Math.horner(a, [357.52772, 35999.05034, -1.603e-4, -1 / 3e5]) * Math.PI) / 180, d = (A.Math.horner(a, [134.96298, 477198.867398, 0.0086972, 1 / 5620]) * Math.PI) / 180, e = (A.Math.horner(a, [93.27191, 483202.017538, -0.0036825, 1 / 327270]) * Math.PI) / 180, f = (A.Math.horner(a, [125.04452, -1934.136261, 0.0020708, 1 / 45e4]) * Math.PI) / 180, g = 0, l = 0, m = A.Nutation.table22A.length - 1; 0 <= m; m--) {\n            var h = A.Nutation.table22A[m], p = h[0] * b + h[1] * c + h[2] * d + h[3] * e + h[4] * f, n = Math.cos(p);\n            g += Math.sin(p) * (h[5] + h[6] * a);\n            l += n * (h[7] + h[8] * a);\n        }\n        return { deltalng: (1e-4 / 3600) * g * (Math.PI / 180), deltaobliquity: (1e-4 / 3600) * l * (Math.PI / 180) };\n    },\n    nutationInRA: function (a) {\n        var b = A.Nutation.meanObliquityLaskar(a);\n        a = A.Nutation.nutation(a);\n        return a.deltalng * Math.cos(b + a.deltaobliquity);\n    },\n    trueObliquity: function (a) {\n        var b = A.Nutation.meanObliquityLaskar(a);\n        a = A.Nutation.nutation(a);\n        return b + a.deltaobliquity;\n    },\n    meanObliquity: function (a) {\n        return A.Math.horner(a.jdeJ2000Century(), [\n            (84381.448 / 3600) * (Math.PI / 180),\n            (-46.815 / 3600) * (Math.PI / 180),\n            (-5.9e-4 / 3600) * (Math.PI / 180),\n            (0.001813 / 3600) * (Math.PI / 180),\n        ]);\n    },\n    meanObliquityLaskar: function (a) {\n        return A.Math.horner(0.01 * a.jdeJ2000Century(), [\n            (84381.448 / 3600) * (Math.PI / 180),\n            (-4680.93 / 3600) * (Math.PI / 180),\n            (-1.55 / 3600) * (Math.PI / 180),\n            (1999.25 / 3600) * (Math.PI / 180),\n            (-51.38 / 3600) * (Math.PI / 180),\n            (-249.67 / 3600) * (Math.PI / 180),\n            (-39.05 / 3600) * (Math.PI / 180),\n            (7.12 / 3600) * (Math.PI / 180),\n            (27.87 / 3600) * (Math.PI / 180),\n            (5.79 / 3600) * (Math.PI / 180),\n            (2.45 / 3600) * (Math.PI / 180),\n        ]);\n    },\n    table22A: [\n        [0, 0, 0, 0, 1, -171996, -174.2, 92025, 8.9],\n        [-2, 0, 0, 2, 2, -13187, -1.6, 5736, -3.1],\n        [0, 0, 0, 2, 2, -2274, -0.2, 977, -0.5],\n        [0, 0, 0, 0, 2, 2062, 0.2, -895, 0.5],\n        [0, 1, 0, 0, 0, 1426, -3.4, 54, -0.1],\n        [0, 0, 1, 0, 0, 712, 0.1, -7, 0],\n        [-2, 1, 0, 2, 2, -517, 1.2, 224, -0.6],\n        [0, 0, 0, 2, 1, -386, -0.4, 200, 0],\n        [0, 0, 1, 2, 2, -301, 0, 129, -0.1],\n        [-2, -1, 0, 2, 2, 217, -0.5, -95, 0.3],\n        [-2, 0, 1, 0, 0, -158, 0, 0, 0],\n        [-2, 0, 0, 2, 1, 129, 0.1, -70, 0],\n        [0, 0, -1, 2, 2, 123, 0, -53, 0],\n        [2, 0, 0, 0, 0, 63, 0, 0, 0],\n        [0, 0, 1, 0, 1, 63, 0.1, -33, 0],\n        [2, 0, -1, 2, 2, -59, 0, 26, 0],\n        [0, 0, -1, 0, 1, -58, -0.1, 32, 0],\n        [0, 0, 1, 2, 1, -51, 0, 27, 0],\n        [-2, 0, 2, 0, 0, 48, 0, 0, 0],\n        [0, 0, -2, 2, 1, 46, 0, -24, 0],\n        [2, 0, 0, 2, 2, -38, 0, 16, 0],\n        [0, 0, 2, 2, 2, -31, 0, 13, 0],\n        [0, 0, 2, 0, 0, 29, 0, 0, 0],\n        [-2, 0, 1, 2, 2, 29, 0, -12, 0],\n        [0, 0, 0, 2, 0, 26, 0, 0, 0],\n        [-2, 0, 0, 2, 0, -22, 0, 0, 0],\n        [0, 0, -1, 2, 1, 21, 0, -10, 0],\n        [0, 2, 0, 0, 0, 17, -0.1, 0, 0],\n        [2, 0, -1, 0, 1, 16, 0, -8, 0],\n        [-2, 2, 0, 2, 2, -16, 0.1, 7, 0],\n        [0, 1, 0, 0, 1, -15, 0, 9, 0],\n        [-2, 0, 1, 0, 1, -13, 0, 7, 0],\n        [0, -1, 0, 0, 1, -12, 0, 6, 0],\n        [0, 0, 2, -2, 0, 11, 0, 0, 0],\n        [2, 0, -1, 2, 1, -10, 0, 5, 0],\n        [2, 0, 1, 2, 2, -8, 0, 3, 0],\n        [0, 1, 0, 2, 2, 7, 0, -3, 0],\n        [-2, 1, 1, 0, 0, -7, 0, 0, 0],\n        [0, -1, 0, 2, 2, -7, 0, 3, 0],\n        [2, 0, 0, 2, 1, -7, 0, 3, 0],\n        [2, 0, 1, 0, 0, 6, 0, 0, 0],\n        [-2, 0, 2, 2, 2, 6, 0, -3, 0],\n        [-2, 0, 1, 2, 1, 6, 0, -3, 0],\n        [2, 0, -2, 0, 1, -6, 0, 3, 0],\n        [2, 0, 0, 0, 1, -6, 0, 3, 0],\n        [0, -1, 1, 0, 0, 5, 0, 0, 0],\n        [-2, -1, 0, 2, 1, -5, 0, 3, 0],\n        [-2, 0, 0, 0, 1, -5, 0, 3, 0],\n        [0, 0, 2, 2, 1, -5, 0, 3, 0],\n        [-2, 0, 2, 0, 1, 4, 0, 0, 0],\n        [-2, 1, 0, 2, 1, 4, 0, 0, 0],\n        [0, 0, 1, -2, 0, 4, 0, 0, 0],\n        [-1, 0, 1, 0, 0, -4, 0, 0, 0],\n        [-2, 1, 0, 0, 0, -4, 0, 0, 0],\n        [1, 0, 0, 0, 0, -4, 0, 0, 0],\n        [0, 0, 1, 2, 0, 3, 0, 0, 0],\n        [0, 0, -2, 2, 2, -3, 0, 0, 0],\n        [-1, -1, 1, 0, 0, -3, 0, 0, 0],\n        [0, 1, 1, 0, 0, -3, 0, 0, 0],\n        [0, -1, 1, 2, 2, -3, 0, 0, 0],\n        [2, -1, -1, 2, 2, -3, 0, 0, 0],\n        [0, 0, 3, 2, 2, -3, 0, 0, 0],\n        [2, -1, 0, 2, 2, -3, 0, 0, 0],\n    ],\n};\nA.Parallax = {\n    earthsunParallax: ((8.794 / 60 / 60) * Math.PI) / 180,\n    horizontal: function (a) {\n        return ((8.794 / 60 / 60) * Math.PI) / 180 / a;\n    },\n    topocentric: function (a, b, c, d, e, f) {\n        e = A.Math.pMod(f - e - a.ra, 2 * Math.PI);\n        b = Math.sin(b);\n        f = Math.cos(e);\n        var g = Math.cos(a.dec);\n        e = Math.atan2(-d * b * Math.sin(e), g - d * b * f);\n        return new A.EqCoord(a.ra + e, Math.atan2((Math.sin(a.dec) - c * b) * Math.cos(e), g - d * b * f));\n    },\n    topocentric2: function (a, b, c, d, e, f) {\n        e = A.Math.pMod(f - e - a.ra, 2 * Math.PI);\n        f = Math.cos(a.dec);\n        return new A.EqCoord(a.ra + (-b * d * Math.sin(e)) / f, a.dec + -b * (c * f - d * Math.cos(e) * Math.sin(a.dec)));\n    },\n};\nA.Refraction = {\n    bennett: function (a) {\n        0 > a && (a = 0);\n        var b = Math.PI / 180;\n        return b / 60 / Math.tan(a + (7.31 * b * b) / (a + 4.4 * b));\n    },\n    bennett2: function (a) {\n        var b = Math.PI / 180, c = 60 / b, d = 0.06 / c;\n        c = 14.7 * c * b;\n        b *= 13;\n        a = A.Refraction.bennett(a);\n        return a - d * Math.sin(c * a + b);\n    },\n    saemundsson: function (a) {\n        var b = Math.PI / 180;\n        return (1.02 * b) / 60 / Math.tan(a + (10.3 * b * b) / (a + 5.11 * b));\n    },\n};\nA.Rise = {\n    meanRefraction: (0.5667 * Math.PI) / 180,\n    stdh0Stellar: (-0.5667 * Math.PI) / 180,\n    stdh0Solar: (-0.8333 * Math.PI) / 180,\n    stdh0LunarMean: (0.125 * Math.PI) / 180,\n    stdh0Lunar: function (a) {\n        return 0.7275 * a - A.Rise.meanRefraction;\n    },\n    circumpolar: function (a, b, c) {\n        a = (Math.sin(b) - Math.sin(a) * Math.sin(c)) / (Math.cos(a) * Math.cos(c));\n        return -1 > a || 1 < a ? null : a;\n    },\n    approxTransit: function (a, b, c) {\n        return (43200 * (c.ra + a.lng)) / Math.PI - b;\n    },\n    approxTimes: function (a, b, c, d) {\n        b = A.Rise.circumpolar(a.lat, b, d.dec);\n        if (!b)\n            return null;\n        b = (43200 * Math.acos(b)) / Math.PI;\n        a = (43200 * (d.ra + a.lng)) / Math.PI - c;\n        return {\n            transit: A.Math.pMod(a, 86400),\n            transitd: Math.floor(a / 86400),\n            rise: A.Math.pMod(a - b, 86400),\n            rised: Math.floor((a - b) / 86400),\n            set: A.Math.pMod(a + b, 86400),\n            setd: Math.floor((a + b) / 86400),\n        };\n    },\n    times: function (a, b, c, d, e) {\n        function f(e) {\n            var f = A.Math.pMod(d + (360.985647 * e) / 360, 86400), g = e + b, h = A.Interp.interpolateX(l, g);\n            g = A.Interp.interpolateX(m, g);\n            f = (f * Math.PI) / 43200 - (a.lng + h);\n            h = Math.cos(g);\n            return A.Math.pMod(e + (((p * Math.sin(g) + n * h * Math.cos(f) - c) / (h * n * Math.sin(f))) * 43200) / Math.PI, 86400);\n        }\n        var g = A.Rise.approxTimes(a, c, d, e[1]);\n        if (!g)\n            return null;\n        var l = A.Interp.newLen3(-86400, 86400, [e[0].ra, e[1].ra, e[2].ra]), m = A.Interp.newLen3(-86400, 86400, [e[0].dec, e[1].dec, e[2].dec]);\n        e = d + (360.985647 * g.transit) / 360;\n        var h = A.Interp.interpolateX(l, g.transit + b);\n        g.transit = A.Math.pMod(g.transit - (e - (43200 * (a.lng + h)) / Math.PI), 86400);\n        var p = Math.sin(a.lat), n = Math.cos(a.lat);\n        g.rise = f(g.rise);\n        g.set = f(g.set);\n        return g;\n    },\n};\nA.Sidereal = {\n    iau82: [24110.54841, 8640184.812866, 0.093104, 6.2e-6],\n    jdToCFrac: function (a) {\n        a = A.Math.modF(a.jd + 0.5);\n        return [new A.JulianDay(a[0] - 0.5).jdJ2000Century(), a[1]];\n    },\n    mean: function (a) {\n        return A.Math.pMod(A.Sidereal._mean(a), 86400);\n    },\n    _mean: function (a) {\n        a = A.Sidereal._mean0UT(a);\n        return a.s + 86636.55536784 * a.f;\n    },\n    _meanInRA: function (a) {\n        a = A.Sidereal._mean0UT(a);\n        return (a.s * Math.PI) / 43200 + 2.0054758187 * a.f * Math.PI;\n    },\n    mean0UT: function (a) {\n        a = A.Sidereal._mean0UT(a);\n        return A.Math.pMod(a.s, 86400);\n    },\n    _mean0UT: function (a) {\n        a = A.Sidereal.jdToCFrac(a);\n        return { s: A.Math.horner(a[0], A.Sidereal.iau82), f: a[1] };\n    },\n    apparentInRa: function (a) {\n        var b = A.Sidereal._meanInRA(a);\n        a = A.Nutation.nutationInRA(a);\n        return A.Math.pMod(b + a, 2 * Math.PI);\n    },\n    apparent: function (a) {\n        var b = A.Sidereal._mean(a);\n        a = (648e3 * A.Nutation.nutationInRA(a)) / Math.PI / 15;\n        return A.Math.pMod(b + a, 86400);\n    },\n    apparentLocal: function (a, b) {\n        a = A.Sidereal.apparent(a);\n        return A.Math.pMod(a - (43200 * b) / Math.PI, 86400);\n    },\n    apparent0UT: function (a) {\n        var b = A.Math.modF(a.jd + 0.5);\n        a = A.Math.modF(a.jde + 0.5);\n        b = A.Math.horner((b[0] - 0.5 - A.J2000) / 36525, A.Sidereal.iau82) + 86636.55536784 * b[1];\n        a = (648e3 * A.Nutation.nutationInRA(new A.JulianDay(a[0]))) / Math.PI / 15;\n        return A.Math.pMod(b + a, 86400);\n    },\n};\nA.Solar = {\n    earthsunDelta: 149597870,\n    apparentEquatorial: function (a) {\n        var b = a.jdJ2000Century(), c = A.Solar.node(b);\n        b = A.Solar.apparentLongitude(b, c);\n        a = A.Nutation.meanObliquityLaskar(a) + ((0.00256 * Math.PI) / 180) * Math.cos(c);\n        c = Math.sin(b);\n        return new A.EqCoord(Math.atan2(Math.cos(a) * c, Math.cos(b)), Math.asin(Math.sin(a) * c));\n    },\n    apparentTopocentric: function (a, b, c) {\n        var d = A.Solar.apparentEquatorial(a), e = A.Globe.parallaxConstants(b.lat, b.h);\n        c || (c = A.Sidereal.apparentInRa(a));\n        return A.Parallax.topocentric2(d, A.Parallax.earthsunParallax, e.rhoslat, e.rhoclat, b.lng, c);\n    },\n    topocentricPosition: function (a, b, c) {\n        var d = A.Sidereal.apparentInRa(a);\n        a = A.Solar.apparentTopocentric(a, b, d);\n        b = A.Coord.eqToHz(a, b, d);\n        !0 === c && (b.alt += A.Refraction.bennett2(b.alt));\n        return { hz: b, eq: a };\n    },\n    approxTransit: function (a, b) {\n        a = a.startOfDay();\n        return A.Rise.approxTransit(b, A.Sidereal.apparent0UT(a), A.Solar.apparentTopocentric(a, b));\n    },\n    approxTimes: function (a, b) {\n        var c = a.startOfDay();\n        a = A.Solar.apparentTopocentric(c, b);\n        var d = A.Rise.stdh0Solar;\n        c = A.Sidereal.apparent0UT(c);\n        return A.Rise.approxTimes(b, d, c, a);\n    },\n    times: function (a, b) {\n        a = a.startOfDay();\n        var c = A.Solar.apparentTopocentric(new A.JulianDay(a.jd - 1, a.deltaT), b), d = A.Solar.apparentTopocentric(a, b), e = A.Solar.apparentTopocentric(new A.JulianDay(a.jd + 1, a.deltaT), b), f = A.Rise.stdh0Solar, g = A.Sidereal.apparent0UT(a);\n        return A.Rise.times(b, a.deltaT, f, g, [c, d, e]);\n    },\n    meanAnomaly: function (a) {\n        return (A.Math.horner(a, [357.52911, 35999.05029, -1.537e-4]) * Math.PI) / 180;\n    },\n    trueLongitude: function (a) {\n        var b = (A.Math.horner(a, [280.46646, 36000.76983, 3.032e-4]) * Math.PI) / 180, c = A.Solar.meanAnomaly(a);\n        a = ((A.Math.horner(a, [1.914602, -0.004817, -1.4e-5]) * Math.sin(c) + (0.019993 - 1.01e-4 * a) * Math.sin(2 * c) + 2.89e-4 * Math.sin(3 * c)) * Math.PI) / 180;\n        return { s: A.Math.pMod(b + a, 2 * Math.PI), v: A.Math.pMod(c + a, 2 * Math.PI) };\n    },\n    apparentLongitude: function (a, b) {\n        b || (b = A.Solar.node(a));\n        return A.Solar.trueLongitude(a).s - (0.00569 * Math.PI) / 180 - ((0.00478 * Math.PI) / 180) * Math.sin(b);\n    },\n    node: function (a) {\n        return ((125.04 - 1934.136 * a) * Math.PI) / 180;\n    },\n};\nA.Solistice = {\n    march: function (a) {\n        return 1e3 > a ? A.Solistice._eq(a, A.Solistice.mc0) : A.Solistice._eq(a - 2e3, A.Solistice.mc2);\n    },\n    june: function (a) {\n        return 1e3 > a ? A.Solistice._eq(a, A.Solistice.jc0) : A.Solistice._eq(a - 2e3, A.Solistice.jc2);\n    },\n    september: function (a) {\n        return 1e3 > a ? A.Solistice._eq(a, A.Solistice.sc0) : A.Solistice._eq(a - 2e3, A.Solistice.sc2);\n    },\n    december: function (a) {\n        return 1e3 > a ? A.Solistice._eq(a, A.Solistice.dc0) : A.Solistice._eq(a - 2e3, A.Solistice.dc2);\n    },\n    _eq: function (a, b) {\n        a = A.Math.horner(0.001 * a, b);\n        b = (a - A.J2000) / A.JulianCentury;\n        var c = ((35999.373 * Math.PI) / 180) * b - (2.47 * Math.PI) / 180;\n        c = 1 + 0.0334 * Math.cos(c) + 7e-4 * Math.cos(2 * c);\n        for (var d = 0, e = this.terms.length - 1; 0 <= e; e--) {\n            var f = this.terms[e];\n            d += f[0] * Math.cos(((f[1] + f[2] * b) * Math.PI) / 180);\n        }\n        return a + (1e-5 * d) / c;\n    },\n    mc0: [1721139.29189, 365242.1374, 0.06134, 0.00111, -7.1e-4],\n    jc0: [1721233.25401, 365241.72562, -0.05232, 0.00907, 2.5e-4],\n    sc0: [1721325.70455, 365242.49558, -0.11677, -0.00297, 7.4e-4],\n    dc0: [1721414.39987, 365242.88257, -0.00769, -0.00933, -6e-5],\n    mc2: [2451623.80984, 365242.37404, 0.05169, -0.00411, -5.7e-4],\n    jc2: [2451716.56767, 365241.62603, 0.00325, 0.00888, -3e-4],\n    sc2: [2451810.21715, 365242.01767, -0.11575, 0.00337, 7.8e-4],\n    dc2: [2451900.05952, 365242.74049, -0.06223, -0.00823, 3.2e-4],\n    terms: [\n        [485, 324.96, 1934.136],\n        [203, 337.23, 32964.467],\n        [199, 342.08, 20.186],\n        [182, 27.85, 445267.112],\n        [156, 73.14, 45036.886],\n        [136, 171.52, 22518.443],\n        [77, 222.54, 65928.934],\n        [74, 296.72, 3034.906],\n        [70, 243.58, 9037.513],\n        [58, 119.81, 33718.147],\n        [52, 297.17, 150.678],\n        [50, 21.02, 2281.226],\n        [45, 247.54, 29929.562],\n        [44, 325.15, 31555.956],\n        [29, 60.93, 4443.417],\n        [18, 155.12, 67555.328],\n        [17, 288.79, 4562.452],\n        [16, 198.04, 62894.029],\n        [14, 199.76, 31436.921],\n        [12, 95.39, 14577.848],\n        [12, 287.11, 31931.756],\n        [12, 320.81, 34777.259],\n        [9, 227.73, 1222.114],\n        [8, 15.45, 16859.074],\n    ],\n};\nexport { A };\n","import { DEG2RAD, getDayOfYear, TAU } from '@ootk/src/main';\nimport { RADIUS_OF_EARTH, ZOOM_EXP } from './constants';\n/**\n * This function normalizes the angle to be between -TAU/2 and TAU/2.\n */\nexport const normalizeAngle = (angle) => {\n    let normalizedAngle = angle % TAU;\n    if (normalizedAngle > TAU / 2) {\n        normalizedAngle -= TAU;\n    }\n    if (normalizedAngle < -TAU / 2) {\n        normalizedAngle += TAU;\n    }\n    return normalizedAngle;\n};\n/**\n * This function converts longitude in degrees to yaw in radians for the camera.\n */\nexport const lon2yaw = (lon, selectedDate) => {\n    const realTime = new Date();\n    let propTime = new Date();\n    /*\n     * NOTE: camera formula sometimes is incorrect, but has been stable for over a year\n     * NOTE: Looks wrong again as of 8/29/2020 - time of year issue?\n     * NOTE: Could camera be related to daylight savings time? Subtracting one hour from selected date works\n     */\n    const doy = getDayOfYear(selectedDate);\n    const modifier = 1000 * 60 * 60 * (-11.23 + 0.065666667 * doy);\n    propTime.setUTCHours(selectedDate.getUTCHours());\n    // + (selectedDate.getUTCMonth() * 2 - 11) / 2); // Offset has to account for time of year. Add 2 Hours per month into the year starting at -12.\n    propTime.setUTCMinutes(selectedDate.getUTCMinutes());\n    propTime.setUTCSeconds(selectedDate.getUTCSeconds());\n    propTime = new Date(propTime.getTime() * 1 + modifier);\n    realTime.setUTCHours(0, 0, 0, 0);\n    const longOffset = (((propTime.getTime() - realTime.getTime()) / 60 / 60 / 1000) % 24) * 15; // 15 Degress Per Hour longitude Offset\n    return normalizeAngle(((lon + longOffset) * DEG2RAD));\n};\n/**\n * This function converts latitude in degrees to pitch in radians.\n */\nexport const lat2pitch = (lat) => {\n    const QUARTER_TAU = TAU / 4;\n    let pitch = lat * DEG2RAD;\n    pitch = Math.min(Math.max(pitch, -QUARTER_TAU), QUARTER_TAU);\n    return pitch;\n};\n/**\n * This function converts altitude in kilometers to a zoom level between MIN_ZOOM_LEVEL and MAX_ZOOM_LEVEL for the camera.\n */\nexport const alt2zoom = (alt, minZoomDistance, maxZoomDistance, minDistanceFromSatellite) => {\n    if (minZoomDistance > maxZoomDistance) {\n        throw new Error('minZoomDistance must be less than maxZoomDistance');\n    }\n    const distanceFromCenter = alt + RADIUS_OF_EARTH + minDistanceFromSatellite;\n    const zoomLevel = ((distanceFromCenter - minZoomDistance) / (maxZoomDistance - minZoomDistance)) ** (1 / ZOOM_EXP);\n    return Number.isNaN(zoomLevel) ? 0.5 : Math.min(Math.max(zoomLevel, 0), 1);\n};\nconst isLeapYear_ = (dateIn) => {\n    const year = dateIn.getUTCFullYear();\n    if ((year & 3) !== 0) {\n        return false;\n    }\n    return year % 100 !== 0 || year % 400 === 0;\n};\n/**\n * Calculate the julian day from a calendar date.\n */\nexport const jday = (year, month, day, hour, minute, second) => {\n    // Any negative values throw an error\n    if (year < 0 || month < 1 || day < 0 || hour < 0 || minute < 0 || second < 0) {\n        throw new Error('Invalid negative value');\n    }\n    // Validate month\n    if (month > 12) {\n        throw new Error('Invalid month value');\n    }\n    // Validate day\n    if (day > 31) {\n        throw new Error('Invalid day value');\n    }\n    // Validate hour\n    if (hour > 23) {\n        throw new Error('Invalid hour value');\n    }\n    // Validate minute\n    if (minute > 59) {\n        throw new Error('Invalid minute value');\n    }\n    // Validate second\n    if (second > 60) {\n        throw new Error('Invalid second value');\n    }\n    return (367.0 * year -\n        Math.trunc(7 * (year + Math.trunc((month + 9) / 12.0)) * 0.25) +\n        Math.trunc((275 * month) / 9.0) +\n        day +\n        1721013.5 +\n        ((second / 60.0 + minute) / 60.0 + hour) / 24.0);\n};\n/**\n * Converts a local date to a zulu (UTC) date.\n */\nexport const localToZulu = (date) => new Date(date.toISOString());\nexport const dateFromJday = (year, day) => {\n    if (year < 0) {\n        throw new Error('Invalid negative value');\n    }\n    if (day < 1 || day > 366) {\n        throw new Error('Invalid day value');\n    }\n    const date = new Date(Date.UTC(year, 0)); // initialize a date in `year-01-01` in UTC\n    if (isLeapYear_(date)) {\n        if (day > 366) {\n            throw new Error('Invalid day value');\n        }\n    }\n    else if (day > 365) {\n        throw new Error('Invalid day value');\n    }\n    return new Date(date.setUTCDate(day)); // set the UTC date to the specified day\n};\nexport const dateToLocalInIso = (date) => {\n    const offsetMs = -date.getTimezoneOffset() * 60 * 1000;\n    const localDate = new Date(date.getTime() + offsetMs);\n    const iso = localDate.toISOString().replace('T', ' ');\n    return `${iso.slice(0, 19)} ${iso.slice(25, 31)}`;\n};\n","/**\n * Message Types for communication with the Orbit Cruncher Worker\n * These must match those in orbitCruncher.ts\n */\nexport var OrbitCruncherMsgType;\n(function (OrbitCruncherMsgType) {\n    OrbitCruncherMsgType[OrbitCruncherMsgType[\"INIT\"] = 0] = \"INIT\";\n    OrbitCruncherMsgType[OrbitCruncherMsgType[\"UPDATE\"] = 1] = \"UPDATE\";\n    OrbitCruncherMsgType[OrbitCruncherMsgType[\"CHANGE_ORBIT_TYPE\"] = 2] = \"CHANGE_ORBIT_TYPE\";\n    OrbitCruncherMsgType[OrbitCruncherMsgType[\"MISSILE_UPDATE\"] = 3] = \"MISSILE_UPDATE\";\n    OrbitCruncherMsgType[OrbitCruncherMsgType[\"SATELLITE_UPDATE\"] = 4] = \"SATELLITE_UPDATE\";\n    OrbitCruncherMsgType[OrbitCruncherMsgType[\"SETTINGS_UPDATE\"] = 5] = \"SETTINGS_UPDATE\";\n    OrbitCruncherMsgType[OrbitCruncherMsgType[\"RESPONSE_READY\"] = 6] = \"RESPONSE_READY\";\n    OrbitCruncherMsgType[OrbitCruncherMsgType[\"RESPONSE_DATA\"] = 7] = \"RESPONSE_DATA\";\n})(OrbitCruncherMsgType || (OrbitCruncherMsgType = {}));\nexport var OrbitDrawTypes;\n(function (OrbitDrawTypes) {\n    OrbitDrawTypes[OrbitDrawTypes[\"ORBIT\"] = 0] = \"ORBIT\";\n    OrbitDrawTypes[OrbitDrawTypes[\"TRAIL\"] = 1] = \"TRAIL\";\n})(OrbitDrawTypes || (OrbitDrawTypes = {}));\n","import { MILLISECONDS_TO_DAYS, PI, RAD2DEG, Sgp4, SpaceObjectType, rae2eci, } from '@ootk/src/main';\nimport { A } from '../../engine/utils/external/meuusjs';\nimport { jday } from '../../engine/utils/transforms';\n/* Returns Current Propagation Time */\nexport const propTime = (dynamicOffsetEpoch, staticOffset, propRate) => {\n    const now = new Date();\n    const dynamicPropOffset = now.getTime() - dynamicOffsetEpoch;\n    now.setTime(dynamicOffsetEpoch + staticOffset + dynamicPropOffset * propRate);\n    return now;\n};\nexport const checkSunExclusion = (sensor, j, gmst, now) => {\n    const jdo = new A.JulianDay(j); // now\n    // eslint-disable-next-line new-cap\n    const coord = A.EclCoordfromWgs84(0, 0, 0);\n    // eslint-disable-next-line new-cap\n    const coord2 = A.EclCoordfromWgs84(sensor.lat, sensor.lon, sensor.alt);\n    // AZ / EL Calculation\n    const tp = A.Solar.topocentricPosition(jdo, coord, false);\n    const tpRel = A.Solar.topocentricPosition(jdo, coord2, false);\n    const sunAz = (tp.hz.az * RAD2DEG + (180 % 360));\n    const sunEl = ((tp.hz.alt * RAD2DEG) % 360);\n    const sunElRel = (tpRel.hz.alt * RAD2DEG) % 360;\n    // Range Calculation\n    const T = new A.JulianDay(A.JulianDay.dateToJD(now)).jdJ2000Century();\n    let sunG = (A.Solar.meanAnomaly(T) * 180) / PI;\n    sunG %= 360.0;\n    const sunR = 1.00014 - 0.01671 * Math.cos(sunG) - 0.00014 * Math.cos(2 * sunG);\n    const sunRange = ((sunR * 149597870700) / 1000); // au to km conversion\n    // RAE to ECI\n    const sunECI = rae2eci({ az: sunAz, el: sunEl, rng: sunRange }, { lat: 0, lon: 0, alt: 0 }, gmst);\n    return sensor && (sensor.type === SpaceObjectType.OPTICAL || sensor.type === SpaceObjectType.OBSERVER) && sunElRel > -6 ? [true, sunECI] : [false, sunECI];\n};\nexport const isInFov = (sensor, lookangles) => {\n    if (!lookangles) {\n        return 0;\n    }\n    const { az, el, rng } = lookangles;\n    sensor.minAz2 ??= Infinity;\n    sensor.maxAz2 ??= -Infinity;\n    sensor.minEl2 ??= Infinity;\n    sensor.maxEl2 ??= -Infinity;\n    sensor.minRng2 ??= Infinity;\n    sensor.maxRng2 ??= -Infinity;\n    if (sensor.minAz > sensor.maxAz) {\n        if (((az >= sensor.minAz || az <= sensor.maxAz) && el >= sensor.minEl && el <= sensor.maxEl && rng <= sensor.maxRng && rng >= sensor.minRng) ||\n            ((az >= (sensor.minAz2) || az <= sensor.maxAz2) && el >= sensor.minEl2 && el <= sensor.maxEl2 && rng <= sensor.maxRng2 && rng >= sensor.minRng2)) {\n            return 1;\n        }\n    }\n    else if ((az >= sensor.minAz && az <= sensor.maxAz && el >= sensor.minEl && el <= sensor.maxEl && rng <= sensor.maxRng && rng >= sensor.minRng) ||\n        (az >= sensor.minAz2 && az <= sensor.maxAz2 && el >= sensor.minEl2 && el <= sensor.maxEl2 && rng <= sensor.maxRng2 && rng >= sensor.minRng2)) {\n        return 1;\n    }\n    return 0;\n};\nexport const setupTimeVariables = (dynamicOffsetEpoch, staticOffset, propRate, isSunlightView, sensors) => {\n    const now = propTime(dynamicOffsetEpoch, staticOffset, propRate);\n    const j = jday(now.getUTCFullYear(), now.getUTCMonth() + 1, // Note, this function requires months in range 1-12.\n    now.getUTCDate(), now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds()) +\n        now.getUTCMilliseconds() * MILLISECONDS_TO_DAYS;\n    const gmst = Sgp4.gstime(j);\n    let isSunExclusion = false;\n    let sunEci = { x: 0, y: 0, z: 0 };\n    if (isSunlightView && sensors?.length === 1) {\n        // TODO: Sun exclusion should be calculated for each sensor\n        [isSunExclusion, sunEci] = checkSunExclusion(sensors[0], j, gmst, now);\n    }\n    const j2 = jday(now.getUTCFullYear(), now.getUTCMonth() + 1, // Note, this function requires months in range 1-12.\n    now.getUTCDate(), now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds() + 1) +\n        now.getUTCMilliseconds() * MILLISECONDS_TO_DAYS;\n    const gmstNext = Sgp4.gstime(j2);\n    return {\n        now,\n        j,\n        gmst,\n        gmstNext,\n        isSunExclusion,\n        sunEci,\n    };\n};\nexport const createLatLonAltRad = (lat, lon, alt) => ({\n    lon,\n    lat,\n    alt,\n});\nexport const createLatLonAlt = (lat, lon, alt) => ({\n    lon: (lon * RAD2DEG),\n    lat: (lat * RAD2DEG),\n    alt,\n});\nexport const isInValidElevation = (rae, selectedSatFOV) => rae.el > 90 - selectedSatFOV;\n","__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n        if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n            Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n        }\n    }\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.rv = () => (\"1.4.11\")","__webpack_require__.ruid = \"bundler=rspack@1.4.11\";\n","import { DEG2RAD, eci2ecf, Sgp4, TAU } from '@ootk/src/main';\nimport { RADIUS_OF_EARTH } from '../engine/utils/constants';\nimport { jday } from '../engine/utils/transforms';\nimport { OrbitCruncherMsgType, OrbitDrawTypes, } from './orbit-cruncher-interfaces';\nimport { propTime } from './positionCruncher/calculations';\nlet dynamicOffsetEpoch;\nlet staticOffset = 0;\nlet propRate = 1.0;\n/** CONSTANTS */\nconst objCache = [];\nlet numberOfSegments;\nlet orbitType = OrbitDrawTypes.ORBIT;\nlet orbitFadeFactor = 1.0;\nlet numberOfOrbitsToDraw = 1;\nconst trapIfJest_ = (cb) => {\n    try {\n        cb();\n    }\n    catch (e) {\n        // If Jest isn't running then throw the error\n        if (!process) {\n            throw e;\n        }\n    }\n};\nexport const onMessage = (m) => {\n    switch (m.data.type) {\n        case OrbitCruncherMsgType.INIT:\n            handleMsgInit_(m.data);\n            return;\n        case OrbitCruncherMsgType.SATELLITE_UPDATE:\n            handleMsgSatelliteUpdate_(m.data);\n            break;\n        case OrbitCruncherMsgType.MISSILE_UPDATE:\n            handleMsgMissileUpdate_(m.data);\n            break;\n        case OrbitCruncherMsgType.SETTINGS_UPDATE:\n            handleMsgSettingsUpdate_(m.data);\n            break;\n        case OrbitCruncherMsgType.CHANGE_ORBIT_TYPE:\n            handleMsgChangeOrbitType(m.data);\n            return;\n        default:\n            return;\n    }\n    if (m.data.type === OrbitCruncherMsgType.SATELLITE_UPDATE || m.data.type === OrbitCruncherMsgType.MISSILE_UPDATE) {\n        updateOrbitData_(m.data);\n    }\n};\nconst updateOrbitData_ = (data) => {\n    /*\n    * TODO: figure out how to calculate the orbit points on constant\n    * position slices, not timeslices (ugly perigees on HEOs)\n    */\n    dynamicOffsetEpoch = data.dynamicOffsetEpoch;\n    staticOffset = data.staticOffset;\n    propRate = data.propRate;\n    const id = data.id;\n    let isEcfOutput = data.isEcfOutput || false;\n    const pointsOut = new Float32Array((numberOfSegments + 1) * 4);\n    const len = numberOfSegments + 1;\n    let i = 0;\n    // Calculate Missile Orbits\n    if (objCache[id].missile) {\n        while (i < len) {\n            const missile = objCache[id];\n            if (missile.latList?.length === 0) {\n                pointsOut[i * 4] = 0;\n                pointsOut[i * 4 + 1] = 0;\n                pointsOut[i * 4 + 2] = 0;\n                pointsOut[i * 4 + 3] = 0;\n                i++;\n            }\n            else {\n                drawMissileSegment_(missile, i, pointsOut, len);\n                i++;\n            }\n        }\n    }\n    else if (objCache[id].ignore || !objCache[id].satrec) {\n        // Invalid objects or OemSatellite with no TLEs\n        trapIfJest_(() => {\n            postMessage({\n                type: OrbitCruncherMsgType.RESPONSE_DATA,\n                pointsOut,\n                satId: id,\n            });\n        });\n        return;\n    }\n    else {\n        const nowDate = propTime(dynamicOffsetEpoch, staticOffset, propRate);\n        const nowJ = jday(nowDate.getUTCFullYear(), nowDate.getUTCMonth() + 1, nowDate.getUTCDate(), nowDate.getUTCHours(), nowDate.getUTCMinutes(), nowDate.getUTCSeconds()) +\n            nowDate.getUTCMilliseconds() * 1.15741e-8; // days per millisecond\n        const satelliteObject = objCache[id];\n        const satrec = satelliteObject.satrec;\n        const now = (nowJ - satrec.jdsatepoch) * 1440.0; // in minutes\n        // Calculate Satellite Orbits\n        const period = (2 * Math.PI) / satrec.no; // convert rads/min to min\n        let timeslice = period / numberOfSegments;\n        // If a ECF output and  Geostationary orbit, then we can draw multiple orbits\n        if (isEcfOutput && period > 1420 && period < 1460 && satrec.ecco < 0.05) {\n            timeslice *= numberOfOrbitsToDraw;\n        }\n        else {\n            isEcfOutput = false;\n        }\n        if (orbitType === OrbitDrawTypes.ORBIT) {\n            while (i < len) {\n                drawTleOrbitSegment_(now, i, timeslice, id, isEcfOutput, period, pointsOut, len);\n                i++;\n            }\n        }\n        else if (orbitType === OrbitDrawTypes.TRAIL) {\n            while (i < len) {\n                drawTleOrbitSegmentTrail_(now, i, timeslice, id, isEcfOutput, period, pointsOut, len);\n                i++;\n            }\n        }\n    }\n    // TODO: Explore SharedArrayBuffer Options\n    trapIfJest_(() => {\n        postMessage({\n            type: OrbitCruncherMsgType.RESPONSE_DATA,\n            pointsOut,\n            satId: id,\n        });\n    });\n};\nconst drawMissileSegment_ = (missile, i, pointsOut, len) => {\n    const x = Math.round(missile.altList.length * (i / numberOfSegments));\n    const missileTime = propTime(dynamicOffsetEpoch, staticOffset, propRate);\n    const j = jday(missileTime.getUTCFullYear(), missileTime.getUTCMonth() + 1, // Note, this function requires months in range 1-12.\n    missileTime.getUTCDate(), missileTime.getUTCHours(), missileTime.getUTCMinutes(), missileTime.getUTCSeconds()) +\n        missileTime.getUTCMilliseconds() * 1.15741e-8; // days per millisecond\n    const gmst = Sgp4.gstime(j);\n    const cosLat = Math.cos(missile.latList[x] * DEG2RAD);\n    const sinLat = Math.sin(missile.latList[x] * DEG2RAD);\n    const cosLon = Math.cos(missile.lonList[x] * DEG2RAD + gmst);\n    const sinLon = Math.sin(missile.lonList[x] * DEG2RAD + gmst);\n    pointsOut[i * 4] = (RADIUS_OF_EARTH + missile.altList[x]) * cosLat * cosLon;\n    pointsOut[i * 4 + 1] = (RADIUS_OF_EARTH + missile.altList[x]) * cosLat * sinLon;\n    pointsOut[i * 4 + 2] = (RADIUS_OF_EARTH + missile.altList[x]) * sinLat;\n    pointsOut[i * 4 + 3] = Math.min(orbitFadeFactor * (len / (i + 1)), 1.0);\n};\nconst drawTleOrbitSegmentTrail_ = (now, i, timeslice, id, isEcfOutput, period, pointsOut, len) => {\n    const t = now + i * timeslice;\n    const sv = Sgp4.propagate(objCache[id].satrec, t);\n    if (!sv) {\n        pointsOut[i * 4] = 0;\n        pointsOut[i * 4 + 1] = 0;\n        pointsOut[i * 4 + 2] = 0;\n        pointsOut[i * 4 + 3] = 0;\n        return;\n    }\n    let pos = sv.position;\n    if (isEcfOutput) {\n        pos = eci2ecf(pos, (i * timeslice * TAU) / period);\n    }\n    pointsOut[i * 4] = pos.x;\n    pointsOut[i * 4 + 1] = pos.y;\n    pointsOut[i * 4 + 2] = pos.z;\n    pointsOut[i * 4 + 3] = i < len / 40 ? Math.min(orbitFadeFactor * (len / 40 / (2 * (i + 1))), 1.0) : 0.0;\n};\nconst drawTleOrbitSegment_ = (now, i, timeslice, id, isEcfOutput, period, pointsOut, len) => {\n    const t = now + i * timeslice;\n    const sv = Sgp4.propagate(objCache[id].satrec, t);\n    if (!sv) {\n        pointsOut[i * 4] = 0;\n        pointsOut[i * 4 + 1] = 0;\n        pointsOut[i * 4 + 2] = 0;\n        pointsOut[i * 4 + 3] = 0;\n        return;\n    }\n    let pos = sv.position;\n    if (isEcfOutput) {\n        pos = eci2ecf(pos, (i * timeslice * TAU) / period);\n    }\n    pointsOut[i * 4] = pos.x;\n    pointsOut[i * 4 + 1] = pos.y;\n    pointsOut[i * 4 + 2] = pos.z;\n    pointsOut[i * 4 + 3] = Math.min(orbitFadeFactor * (len / (i + 1)), 1.0);\n};\nconst handleMsgInit_ = (data) => {\n    orbitFadeFactor = data.orbitFadeFactor ?? 1.0;\n    numberOfOrbitsToDraw = data.numberOfOrbitsToDraw ?? 1;\n    numberOfSegments = data.numSegs;\n    const objData = JSON.parse(data.objData);\n    const sLen = objData.length - 1;\n    let i = -1;\n    while (i < sLen) {\n        i++;\n        if (objData[i].missile) {\n            objCache[i] = objData[i];\n        }\n        else if (objData[i].ignore) {\n            objCache[i] = { ignore: true };\n        }\n        else if (objData[i].tle1 && objData[i].tle2) {\n            objCache[i] = {\n                satrec: Sgp4.createSatrec(objData[i].tle1, objData[i].tle2),\n            };\n        }\n        else {\n            throw new Error('Invalid Object Data');\n        }\n    }\n    postMessage({\n        type: OrbitCruncherMsgType.RESPONSE_READY,\n    });\n};\nconst handleMsgSatelliteUpdate_ = (data) => {\n    // If new orbit\n    if (data.tle1 && data.tle2) {\n        const satelliteCacheEntry = objCache[data.id];\n        satelliteCacheEntry.satrec = Sgp4.createSatrec(data.tle1, data.tle2);\n    }\n};\nconst handleMsgMissileUpdate_ = (data) => {\n    if (data.latList && data.lonList && data.altList) {\n        const missileCacheEntry = objCache[data.id];\n        missileCacheEntry.latList = data.latList;\n        missileCacheEntry.lonList = data.lonList;\n        missileCacheEntry.altList = data.altList;\n    }\n};\nconst handleMsgSettingsUpdate_ = (data) => {\n    numberOfOrbitsToDraw = data.numberOfOrbitsToDraw ?? numberOfOrbitsToDraw;\n};\nconst handleMsgChangeOrbitType = (data) => {\n    orbitType = data.orbitType;\n};\n// Set up the web worker\nonmessage = (m) => {\n    trapIfJest_(() => onMessage(m));\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0C;AAC1C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAAQ;AAC7B,yEAAyE;AACzE;AACA,2BAA2B,6CAAO;AAClC,sBAAsB,6CAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,2CAAK,2BAA2B,2CAAK;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,2CAAK,2BAA2B,2CAAK;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4M;AAC5M;AACO;AACP;AACA;AACA;AACA;AACA,gBAAgB,uDAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8CAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,yCAAG,UAAU,mDAAa;AACjE;AACA;AACA;AACA;AACA,qBAAqB,kDAAQ;AAC7B,sBAAsB,kDAAQ;AAC9B,oBAAoB,kDAAQ;AAC5B,iBAAiB;AACjB;AACA;AACA;AACA;AACA,yBAAyB,kDAAQ;AACjC,wBAAwB,kDAAQ;AAChC,wBAAwB,kDAAQ;AAChC,yBAAyB,kDAAQ;AACjC,yBAAyB,kDAAQ;AACjC;AACA;AACA,mBAAmB,6DAAuB;AAC1C,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gDAAU;AAC9B,wBAAwB,gDAAU;AAClC,4BAA4B,kDAAQ;AACpC;AACA;AACA,sBAAsB,8CAAQ;AAC9B,uBAAuB,8CAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yCAAG,+CAA+C,2DAAqB;AAC1F,2BAA2B,yCAAG;AAC9B;AACA;AACA;AACA,iDAAiD,6CAAO;AACxD;AACA;AACA;AACA,gCAAgC,yCAAG,QAAQ,2DAAqB;AAChE;AACA;AACA;AACA;AACA,0CAA0C,6CAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAe,8CAA8C,kEAA4B;AACxG;AACA;AACA;AACA,mBAAmB,8CAAQ;AAC3B,kBAAkB,8CAAQ;AAC1B,oBAAoB,8CAAQ;AAC5B;AACA;AACA;AACA;AACA,oBAAoB,8CAAQ;AAC5B,mBAAmB,8CAAQ;AAC3B,oBAAoB,8CAAQ;AAC5B;AACA;AACA;AACA;AACA,mBAAmB,8CAAQ;AAC3B,kBAAkB,8CAAQ;AAC1B,oBAAoB,8CAAQ;AAC5B;AACA;AACA;AACA,oBAAoB,6CAAO;AAC3B,oBAAoB,6CAAO;AAC3B,yCAAyC,6CAAO;AAChD,uBAAuB,6CAAO;AAC9B;AACA;AACA;AACA,iBAAiB,6CAAO;AACxB,qBAAqB,6CAAO;AAC5B,uCAAuC,6CAAO;AAC9C,uBAAuB,6CAAO;AAC9B;AACA;AACA;AACA,mBAAmB,6CAAO;AAC1B,oBAAoB,6CAAO;AAC3B,wCAAwC,6CAAO;AAC/C,sBAAsB,6CAAO;AAC7B;AACA;AACA;AACA,mBAAmB,6CAAO;AAC1B,qBAAqB,6CAAO;AAC5B,yCAAyC,6CAAO;AAChD,uBAAuB,6CAAO;AAC9B;AACA;AACA;AACA,mBAAmB,6CAAO;AAC1B,oBAAoB,6CAAO;AAC3B,uCAAuC,6CAAO;AAC9C,uBAAuB,6CAAO;AAC9B;AACA;AACA;AACA,mBAAmB,8CAAQ;AAC3B,mBAAmB,8CAAQ;AAC3B,kBAAkB,8CAAQ;AAC1B,oBAAoB,8CAAQ;AAC5B;AACA;;;;;;;;;;;;;;;;;;;;ACpMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8D;AACT;AACN;AACa;AACJ;AACrB;AACJ;AAC/B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oEAAqB;AAC5C;AACA,oBAAoB,wDAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,6DAAQ;AAC9B;AACA;AACA;AACA;AACA,6BAA6B,0DAAmB;AAChD,kBAAkB,uDAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oEAAe;AAC9C,uBAAuB,iDAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oEAAe,+DAA+D,kEAA4B;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,+CAA+C;AAC/C;AACA,kBAAkB,wDAAmB;AACrC,kBAAkB,8CAAS;AAC3B;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,oBAAoB,wDAAO;AAC3B,qBAAqB,wDAAO;AAC5B,kBAAkB,wDAAmB;AACrC;AACA,kBAAkB,qDAAgB;AAClC,gBAAgB,yDAAmB;AACnC;AACA;AACA;AACA;AACA;AACA,iBAAiB,qEAA+B,MAAM;AACtD;AACA,gBAAgB,uDAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,2DAAU;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wDAAO,8BAA8B;AACvD,kBAAkB,wDAAO,8BAA8B;AACvD,kBAAkB,wDAAO,4BAA4B;AACrD,sBAAsB,wDAAO,wBAAwB;AACrD,kBAAkB,wDAAO,wBAAwB;AACjD,iDAAiD;AACjD;AACA,gBAAgB,8DAAwB;AACxC,iBAAiB,2DAAqB;AACtC;AACA;AACA;AACA;AACA,2BAA2B,wDAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;AC9cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiK;AACjK;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,6CAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,6CAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,+CAAS;AACrD;AACA;AACA;AACA,sCAAsC,6CAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6CAAO;AAClC,2BAA2B,6CAAO;AAClC;AACA;AACA;AACA;AACA,gBAAgB,uDAAiB;AACjC,gBAAgB,yDAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gDAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAe,uDAAuD,kEAA4B;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yCAAG;AACrB;AACA,eAAe,yCAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6CAAO;AACzB,kBAAkB,6CAAO,aAAa;AACtC,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6CAAO;AAC9B;AACA;AACA,oBAAoB,6CAAO;AAC3B,qBAAqB,6CAAO;AAC5B;AACA,qBAAqB,gDAAU,EAAE;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uDAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mCAAmC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA,iCAAiC,6CAAO;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,gDAAU;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6CAAO;AAClC;AACA,mDAAmD,yCAAG;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,sDAAgB,wEAAwE,6CAAO;AACvI,yJAAyJ,6CAAO;AAChK;AACA;AACA;AACA,uHAAuH,6CAAO;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6CAAO;AAC3B;AACA;AACA;AACA;AACA;AACA,sBAAsB,8CAAQ;AAC9B,6BAA6B,sDAAgB;AAC7C,kBAAkB,sDAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+CAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2DAAqB;AACtC,gBAAgB,8DAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6CAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yCAAG;AACxC;AACA;AACA,oBAAoB,6CAAO;AAC3B,qBAAqB,6CAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2DAAqB;AACzC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yCAAG;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6CAAO;AACtB;AACA;;;;;;;;;;;;;;;;;;;;AC9hBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2C;AACR;AACF;AACF;;;;;;;;;;;;;;;;;;;ACzB/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AAClB;AACiB;AAC6C;AAC1B;AACT;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+FAA+F,kEAAiB,GAAG;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kEAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0DAAK;AACjC,kBAAkB,yEAAoB;AACtC,0BAA0B,0DAAK;AAC/B;AACA,gBAAgB,oDAAG;AACnB;AACA;AACA;AACA,gBAAgB,oDAAG;AACnB;AACA;AACA;AACA,gBAAgB,oDAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wDAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wDAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wDAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wDAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,sDAAgB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,sDAAgB;AACjF;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC,2CAA2C,+BAA+B;AAC1E,2CAA2C,6BAA6B;AACxE,2CAA2C,mCAAmC;AAC9E,4CAA4C,sCAAsC;AAClF,4CAA4C,kCAAkC;AAC9E,4CAA4C,mCAAmC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oDAAG;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wDAAO;AACvC;AACA,mBAAmB,kEAAe;AAClC;AACA;AACA,mBAAmB,kEAAe;AAClC;AACA;AACA,mBAAmB,kEAAe;AAClC;AACA;AACA,mBAAmB,kEAAe;AAClC;AACA,eAAe,oEAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6DAAQ;AACjC;AACA,yBAAyB,6DAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6DAAQ;AACpC;AACA;AACA;AACA;AACA,mBAAmB,wEAAmB,GAAG,0DAA0D;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0DAAK;AACpC,iBAAiB,mEAAc;AAC/B;AACA,iBAAiB,mEAAc;AAC/B,+CAA+C,oDAAG;AAClD;AACA,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,0DAAK;AAC1B,iBAAiB,mEAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;ACrRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgF;AAChC;AACW;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qCAAqC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kEAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC,oBAAoB,QAAQ;AAC5B,oBAAoB,OAAO;AAC3B,oBAAoB,OAAO;AAC3B,oBAAoB,OAAO;AAC3B,oBAAoB,OAAO;AAC3B,yBAAyB,aAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oDAAG;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4DAAO;AACzB,mBAAmB,oEAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiC;AACjC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iEAAiE;AACjF,oBAAoB,2DAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,IAAI,IAAI,SAAS,EAAE,WAAW,EAAE,YAAY,EAAE,WAAW;AACnF,0BAA0B,KAAK,EAAE,QAAQ,EAAE,SAAS,EAAE,SAAS,EAAE,UAAU,EAAE,UAAU,EAAE,WAAW;AACpG,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB,EAAE,IAAI,EAAE,yBAAyB;AAC3E;AACA;;;;;;;;;;;;;;;;;;;ACtLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyC;AACwB;AACZ;AACI;AACD;AACvB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4DAAgB;AACxC,kEAAkE,CAAC,4DAAgB,EAAE,UAAU,UAAU;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,wDAAO,gBAAgB,wDAAO;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD,4BAA4B,uBAAuB;AACnD,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wDAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wDAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kDAAY;AAC/B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+DAAmB,iBAAiB,qEAAyB;AAClF,sBAAsB,6DAAQ,iHAAiH,qEAAyB;AACxK,mBAAmB,0CAAI,WAAW,oEAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qEAA+B;AACrD,eAAe,oEAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qEAA+B;AACxD,wCAAwC,wDAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qEAA+B;AACxD,wCAAwC,4DAAgB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4DAAgB,IAAI,4DAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qEAA+B;AACxD;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4E;AAC9B;AAC9C;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAqB;AAChD;AACA;AACA;AACA,kBAAkB,2DAAqB;AACvC;AACA;AACA;AACA,sBAAsB,8CAAQ;AAC9B,sBAAsB,8CAAQ;AAC9B;AACA;AACA;AACA;AACA,kBAAkB,2DAAqB;AACvC;AACA;AACA;AACA,sBAAsB,8CAAQ;AAC9B,sBAAsB,8CAAQ;AAC9B;AACA;AACA;AACA;AACA,kBAAkB,2DAAqB;AACvC;AACA;AACA,sBAAsB,8CAAQ;AAC9B,sBAAsB,8CAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,4CAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8CAAQ;AACpC;AACA;AACA,4BAA4B,8CAAQ;AACpC;AACA,mBAAmB,2CAAK;AACxB;AACA;AACA,0CAA0C,gEAA0B;AACpE;AACA;AACA;AACA;AACA;AACA,mBAAmB,4CAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,8CAAQ,8BAA8B,8CAAQ;AAC9F;AACA;AACA;AACA,gDAAgD,8CAAQ,8BAA8B,8CAAQ;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,4CAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,4CAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8CAAQ;AACjC;AACA,mBAAmB,oDAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8CAAQ;AACxC;AACA,uBAAuB,8CAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B,wBAAwB,WAAW;AACnC,2BAA2B,2BAA2B;AACtD,2BAA2B,2BAA2B;AACtD;AACA;AACA;;;;;;;;;;;;;;;;;AC5NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyC;AACA;AACN;AACY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,mBAAmB,wDAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+DAAmB;AACrC,mBAAmB,qEAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4DAAgB;AAClC,kBAAkB,0DAAc;AAChC;AACA;AACA;AACA,iBAAiB,gEAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4CAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+DAAmB;AACvC,oBAAoB,qEAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6DAAiB,SAAS,6DAAiB;AAC1E;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kDAAQ;AAC3B;AACA;;;;;;;;;;;;;;;;;ACrIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyC;AACR;AACc;AACd;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,oBAAoB,wDAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4DAAgB;AAClC,kBAAkB,0DAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iEAAqB;AAC7D,mBAAmB,0CAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4DAAgB;AAClC,kBAAkB,0DAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0CAAI;AACvB;AACA;;;;;;;;;;;;;;;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmC;AACgB;AACnD;AACA;AACA;AACO,kBAAkB,4DAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,yEAA0B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4CAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,yEAA0B;AACpE;AACA;;;;;;;;;;;;;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiD;AACjD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B,2BAA2B,2BAA2B;AACtD,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yDAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4D;AAC5D;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B,wBAAwB,WAAW;AACnC,2BAA2B,2BAA2B;AACtD,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8CAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yCAAG,2BAA2B,8CAAQ;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8CAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA;AACA;AACA,eAAe,uEAAiC;AAChD;AACA;;;;;;;;;;;;;;;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyC;AACN;AACY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,mBAAmB,wDAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4DAAgB;AAClC,kBAAkB,0DAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4CAAK;AACxB;AACA;;;;;;;;;;;;;;;;;;;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AACV;AACQ;AACL;AACiD;AACpB;AAC/B;AACQ;AACrD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8DAAa;AAC1C;AACA,wBAAwB,8DAAa;AACrC;AACA,2BAA2B,8DAAa;AACxC;AACA,iCAAiC,8DAAa;AAC9C;AACA,+BAA+B,8DAAa;AAC5C;AACA,2BAA2B,8DAAa;AACxC;AACA,gCAAgC,8DAAa;AAC7C;AACA,2BAA2B,8DAAa;AACxC;AACA,4BAA4B,8DAAa;AACzC;AACA,8BAA8B,8DAAa;AAC3C;AACA,mCAAmC,8DAAa;AAChD;AACA,qCAAqC,8DAAa;AAClD;AACA,8BAA8B,8DAAa;AAC3C;AACA,6BAA6B,8DAAa;AAC1C;AACA,2BAA2B,8DAAa;AACxC;AACA,6BAA6B,8DAAa;AAC1C;AACA,6BAA6B,8DAAa;AAC1C;AACA,yBAAyB,8DAAa;AACtC;AACA,iCAAiC,8DAAa;AAC9C;AACA,yBAAyB,8DAAa;AACtC;AACA,yBAAyB,8DAAa;AACtC,wCAAwC,oEAAiB,cAAc,kEAAuB;AAC9F;AACA;AACA;AACA;AACA,uBAAuB,uDAAiB;AACxC;AACA;AACA,kBAAkB,WAAW,IAAI,WAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,wDAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oDAAG,uCAAuC,kEAAiB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0EAA2B,IAAI,KAAK,mCAAmC,8DAAa;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iEAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAc;AAC1C;AACA;AACA;AACA;AACA,mBAAmB,2CAAI,YAAY,8CAAQ,wBAAwB,8CAAQ;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAc;AAC1C;AACA,mBAAmB,2CAAI,iBAAiB,8CAAQ,wBAAwB,8CAAQ;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kEAAiB,gBAAgB,oDAAG,QAAQ,8DAAa;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wBAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,wDAAO;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA,qBAAqB,0DAAmB;AACxC,iBAAiB,4DAAqB;AACtC,oBAAoB,2DAAoB;AACxC,kBAAkB,6DAAsB;AACxC,mBAAmB,kEAA2B;AAC9C,mBAAmB,4DAAqB,CAAC,6DAAQ,kDAAkD,wDAAO;AAC1G,kBAAkB,+DAAwB;AAC1C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,MAAM;AAClE;AACA,eAAe,gEAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,+CAA+C;AACpF;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,YAAY;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,YAAY;AACjE;AACA,eAAe,gEAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oEAAoE;AACxG;AACA,qDAAqD,IAAI;AACzD;AACA,eAAe,gEAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,IAAI;AACxD;AACA,eAAe,gEAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,MAAM,GAAG,sCAAsC,EAAE,YAAY;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,MAAM;AAC3D;AACA,eAAe,gEAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA,eAAe,gEAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,eAAe;AACvE;AACA,eAAe,gEAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,UAAU,EAAE,UAAU;AACtD;AACA;AACA;AACA,kBAAkB,gCAAgC,EAAE,KAAK;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/1BuC;AACE;AACV;AACD;AACJ;AACC;AACQ;AACV;AACQ;AACP;AACD;AACQ;;;;;;;;;;;;;ACXjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoD;AACgD;AACnB;AACT;AACxE;AACO;AACP;AACA;AACA,cAAc,iDAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,4DAAU;AAC3C,iCAAiC,4DAAU;AAC3C;AACA;AACA;AACA,+BAA+B,sDAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yFAAsB;AACjD;AACA;AACA,wBAAwB,OAAO;AAC/B,4BAA4B,OAAO;AACnC;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iDAAW;AACpC,wBAAwB,OAAO;AAC/B;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC,gCAAgC,8CAAQ;AACxC,gCAAgC,8CAAQ;AACxC,qCAAqC,oEAAmB;AACxD,mCAAmC,2CAAK;AACxC,uCAAuC,yFAAsB;AAC7D;AACA,0CAA0C,oEAAmB;AAC7D,mCAAmC,yCAAG;AACtC,uCAAuC,yFAAsB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4CAAM;AAC7B,kBAAkB,iDAAW;AAC7B,wBAAwB,QAAQ;AAChC,4BAA4B,OAAO;AACnC;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA,wBAAwB,QAAQ;AAChC,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gEAAe,SAAS,oEAAmB;AAC9D;AACA;AACA;AACA,oBAAoB,gEAA0B;AAC9C,wBAAwB,QAAQ;AAChC,0BAA0B,yDAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gEAAe,SAAS,oEAAmB;AAC9D;AACA;AACA,iCAAiC;AACjC;AACA,6BAA6B,oDAAc;AAC3C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,+BAA+B,+CAAS;AACxC,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA,iBAAiB,qDAAe;AAChC;AACA;AACA,iBAAiB,qDAAe;AAChC;AACA;AACA,iBAAiB,qDAAe;AAChC;AACA,iBAAiB,qDAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AAC5C;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iDAAW;AAClC,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA,mBAAmB,4CAAM;AACzB;AACA;;;;;;;;;;;;;;;;;AC/DsC;AACD;;;;;;;;;;;;;;;;;ACDrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkD;AACc;AACV;AACM;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qEAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yEAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oFAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uFAA8B;AAC7C;AACA;;;;;;;;;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AAClB;AACnC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8DAAS;AAC/B,sBAAsB,8DAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,qCAAqC,4CAAK;;;;;;;;;;;;;;;;AC7DjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiD;AACY;AAC7D;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sEAAkB;AACrC;AACA;AACO,mDAAmD,0DAAY;;;;;;;;;;;;;ACxDtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuC;AACvC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,2CAA2C,gDAAO;;;;;;;;;;;;;AClDzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sDAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8BAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;;;;;;;;;;;;;ACrGP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACptBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,CAAC,sDAAsD;;;;;;;;;;;;;AC3BvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,CAAC,sDAAsD;;;;;;;;;;;;;AC3BhD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;;;;;;;;;;;;;ACVhC;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;;;;;;;;;;;;;ACP7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;;;;;;;;;;;;;AC9BnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;;;;;;;;;;;;;AC5B7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,CAAC,kCAAkC;;;;;;;;;;;;;;;;;;;;;;;;;;AC1BY;AACA;AACoB;AACA;AAC1B;AACU;AACV;;;;;;;;;;;;;;ACNzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsF;AACtF;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6DAAuB;AAC3C;AACA;AACA;AACA,uBAAuB,0DAAoB;AAC3C,2BAA2B,2CAAK,sBAAsB,qDAAe;AACrE,2CAA2C,6CAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qDAAe;AAClC;AACA,6BAA6B,0CAAI,cAAc,oDAAc,EAAE,qDAAe;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,8CAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yDAAmB;AACxC;AACA,sBAAsB,8CAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6DAAuB;AAC1C,mDAAmD,kBAAkB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,UAAU;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8CAAQ;AAC9B,mBAAmB,0CAAI,iBAAiB,qDAAe;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACU;AACN;AACV;AAC8B;AACZ;AACzD;AACO;AACP;AACA;AACA;AACA;AACA;AACA,oBAAoB,8CAAQ;AAC5B,mCAAmC,gDAAO;AAC1C;AACA;AACA;AACA,mCAAmC,0DAAY;AAC/C;AACA,0BAA0B,2BAA2B;AACrD,qCAAqC,kEAAgB;AACrD;AACA;AACA,2CAA2C,8EAAsB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gEAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qDAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmC;AACnC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AAChB;AACnC;AACO,qCAAqC,4CAAK;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sDAAgB;AAC7C;AACA,qBAAqB,0DAAoB;AACzC;AACA;AACA;AACA,sBAAsB,uDAAiB;AACvC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiD;AACjD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8CAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAAO;AACpC;AACA;AACA,qBAAqB,0DAAoB;AACzC;AACA;AACA;AACA;AACA;AACA,6BAA6B,4CAAM;AACnC;AACA;AACA,qBAAqB,qDAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AAC5C;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8CAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yCAAG,CAAC,qDAAe;AAChD;AACA;AACA;AACA,6BAA6B,yCAAG,CAAC,qDAAe;AAChD;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxD6C;;;;;;;;;;ACAnC;;;;;;;;;;;;;ACAV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0D;AACX;AACY;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,sCAAsC,oEAAiB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,wDAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2CAAK;AACxB;AACA;AACA,mBAAmB,iDAAW,KAAK,8CAAQ,2BAA2B,8CAAQ;AAC9E;AACA;;;;;;;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AACnD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8CAAQ;AACnC,2BAA2B,8CAAQ;AACnC,uBAAuB,iDAAW;AAClC;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoE;AACT;AACpD,mCAAmC,oEAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC,6BAA6B,8CAAQ;AACrC,mBAAmB,2CAAK;AACxB;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA,mBAAmB,iDAAW,KAAK,8CAAQ,kBAAkB,8CAAQ;AACrE;AACA;;;;;;;;;;;;;;AC7JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiD;AACjD;AACO,gCAAgC,0DAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkE;AACK;AACN;AACN;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,sCAAsC,oEAAiB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8CAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2CAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kDAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8FAAqC;AACpD;AACA;AACA,eAAe,wFAAkC;AACjD;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiC;AACA;AACK;AACN;AACM;AACL;AACU;AACK;AACR;AACF;AACC;AACD;AACN;AACG;AACH;AACM;AACL;AACK;AACS;AACT;;;;;;;;;;;;;;ACzCtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoD;AAC7C;AACP;AACA;AACA;AACA,cAAc;AACd,mBAAmB;AACnB,cAAc;AACd,mBAAmB;AACnB;AACA,iCAAiC,oEAAuB;AACxD;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oEAAuB;AACpD;AACA;AACA,6BAA6B,wEAA2B;AACxD;AACA;AACA,6BAA6B,mEAAsB;AACnD;AACA;AACA,6BAA6B,iEAAoB;AACjD;AACA;AACA,6BAA6B,8EAAiC;AAC9D;AACA;AACA,6BAA6B,qEAAwB;AACrD;AACA;AACA;AACA,aAAa,oEAAuB;AACpC,aAAa,oEAAuB;AACpC,aAAa,wEAA2B;AACxC,aAAa,mEAAsB;AACnC,aAAa,oEAAuB;AACpC,aAAa,8EAAiC;AAC9C,aAAa,iEAAoB;AACjC,aAAa,2FAA8C;AAC3D,aAAa,wFAA2C;AACxD,aAAa,0EAA6B;AAC1C,aAAa,gHAAmE;AAChF,aAAa,iFAAoC;AACjD,aAAa,0EAA6B;AAC1C,aAAa,wEAA2B;AACxC,aAAa,4EAA+B;AAC5C,aAAa,4EAA+B;AAC5C,aAAa,6EAAgC;AAC7C,aAAa,kFAAqC;AAClD,aAAa,oEAAuB;AACpC,aAAa,uEAA0B;AACvC,aAAa,+EAAkC;AAC/C,aAAa,qEAAwB;AACrC,aAAa,qFAAwC;AACrD,aAAa,oEAAuB;AACpC,aAAa,wFAA2C;AACxD,aAAa,gFAAmC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuD;AACL;AACP;AAC3C;AACA;AACA;AACO,gCAAgC,oDAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kEAAqB;AAClC;AACA;AACA;AACA,4BAA4B,0DAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kEAAqB;AAC1D;AACA;AACA,oBAAoB,yDAAmB;AACvC,oBAAoB,yDAAmB;AACvC,oBAAoB,yDAAmB;AACvC,oBAAoB,yDAAmB;AACvC,oBAAoB,yDAAmB;AACvC,oBAAoB,yDAAmB;AACvC,oBAAoB,yDAAmB;AACvC,oBAAoB,yDAAmB;AACvC,oBAAoB,yDAAmB;AACvC,oBAAoB,yDAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqC;AAC9B,6BAA6B,8CAAM;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgG;AACnD;AACtC,2BAA2B,sDAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oDAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO,EAAE,kDAAQ;AACjC,eAAe,iDAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAAO;AACpC,6BAA6B,6CAAO;AACpC;AACA;AACA;AACA;AACA,0BAA0B,6CAAO;AACjC;AACA;AACA,0BAA0B,6CAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0DAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oFAA8C;AAC/D,iBAAiB,iFAA2C;AAC5D,iBAAiB,mEAA6B;AAC9C,iBAAiB,yGAAmE;AACpF,iBAAiB,0EAAoC;AACrD,iBAAiB,iFAA2C;AAC5D,iBAAiB,yEAAmC;AACpD,iBAAiB,mEAA6B;AAC9C,iBAAiB,iEAA2B;AAC5C,iBAAiB,qEAA+B;AAChD;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACtC,yBAAyB,sDAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AAC7C;AACO,qBAAqB,sDAAU;AACtC;AACA;AACA;AACA;;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiF;AAC5B;AAC9C,uBAAuB,8DAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8EAAwC;AACzD,iBAAiB,gEAA0B;AAC3C,iBAAiB,wEAAkC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6CAAO;AACnC,4BAA4B,6CAAO;AACnC;AACA;AACA,eAAe,iDAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS,EAAE,iDAAO;AAClC;AACA,sDAAsD,6CAAO;AAC7D,sDAAsD,6CAAO;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,6CAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,6CAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,6CAAO;AACxC;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+C;AACJ;AACA;AACT;AACU;AACS;AACN;AAC0B;AACuB;AACxC;AACX;AAC7C;AACA;AACA;AACA;AACO,wBAAwB,uDAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAS;AACjC;AACA;AACA;AACA,uBAAuB,qEAAqB;AAC5C,uBAAuB,qEAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uDAAiB;AACvC;AACA;AACA;AACA,uBAAuB,qEAAqB;AAC5C,uBAAuB,qEAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8DAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uDAAQ;AAClC;AACA;AACA;AACA,mBAAmB,oDAAG,2BAA2B,wDAAO,aAAa,wDAAO;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,eAAe,6DAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,IAAI;AACpB;AACA;AACA;AACA,mBAAmB,oDAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,IAAI;AACpB;AACA;AACA;AACA,mBAAmB,oDAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uDAAQ;AACtC,4BAA4B,6DAAQ;AACpC,4BAA4B,6DAAQ;AACpC,uBAAuB,uDAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6DAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6DAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mDAAG;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6DAAO;AAC3B,eAAe,6DAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kEAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0DAAI,iKAAiK,qEAAoB;AACvM,iBAAiB,iDAAW;AAC5B,qDAAqD,gEAAe;AACpE,iBAAiB;AACjB;AACA;;;;;;;;;;;;;;;;;ACzbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgD;AAC0B;AACtB;AACH;AAC1C,qBAAqB,0DAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oEAAuB;AAC5C,qBAAqB,uEAA0B;AAC/C,qBAAqB,+EAAkC;AACvD,qBAAqB,qEAAwB;AAC7C,qBAAqB,qFAAwC;AAC7D,qBAAqB,6EAAgC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+BAA+B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8DAAc,aAAa,6DAAa;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6DAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kDAAQ;AAC7B,yBAAyB,iDAAO;AAChC,mBAAmB,2CAAK,CAAC,2DAAqB,YAAY,8CAAQ,0CAA0C,8CAAQ;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oEAAoB;AACvC;AACA,mBAAmB,8DAAc;AACjC;AACA;AACA,mBAAmB,6DAAa;AAChC;AACA;AACA,mBAAmB,gEAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC5OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6G;AAChE;AACtC,mBAAmB,sDAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0DAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0BAA0B;AAC1C;AACA,gBAAgB,OAAO;AACvB;AACA,eAAe,iDAAO,CAAC,iDAAO,QAAQ,wBAAwB;AAC9D;AACA,gBAAgB,0BAA0B;AAC1C,wBAAwB,oDAAc;AACtC,iBAAiB;AACjB;AACA;AACA,kBAAkB,8CAAI;AACtB,wCAAwC,0DAAoB;AAC5D,qBAAqB,iDAAW;AAChC,iBAAiB;AACjB;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzD6C;AACI;AACN;AACN;AACJ;AAC0B;AACN;AACR;AACR;AACI;;;;;;;;;;;;;;;;;;ACTzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AACvC;AACP;AACA;AACA;AACA;AACA,eAAe,8CAAQ;AACvB;AACO;AACP;AACA;AACA;AACA;AACA,eAAe,8CAAQ;AACvB;AACO;AACP;AACA;AACA;AACO;AACA;AACP;AACA,gCAAgC,WAAW;AAC3C,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,eAAe,4CAAM;AACrB;;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AAC6B;AACrB;AACiB;AACd;AACxD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,wDAAO;AAClE,iEAAiE,wDAAO;AACxE,gDAAgD,wDAAO,gBAAgB,wDAAO;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uDAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,oDAAG;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wDAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wDAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,wDAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,wDAAO;AACxD;AACA;AACA;AACA;AACA,4BAA4B,WAAW;AACvC,4BAA4B,mBAAmB;AAC/C,4BAA4B,mBAAmB;AAC/C,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uDAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6DAAQ;AACjC;AACA;AACA;AACA;AACA,mBAAmB,qDAAI,oBAAoB,oEAAe;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uDAAM;AAC1B;AACA;AACA;AACA;AACA,yBAAyB,6DAAQ;AACjC,4BAA4B,6DAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qDAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yFAA4B;AACtD,eAAe,oEAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yFAA4B;AAC7D,2CAA2C,wDAAO;AAClD;AACA;;;;;;;;;;;;;;;;;ACpNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0E;AACZ;AACN;AACiB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,wDAAO;AACjD;AACA,kFAAkF,wDAAO;AACzF,kEAAkE,wDAAO,uBAAuB,wDAAO;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,oDAAG;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,wDAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wDAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,wDAAO;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,wDAAO;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qEAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qEAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yFAA4B;AACtD,eAAe,oEAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yFAA4B;AAC7D,2CAA2C,wDAAO;AAClD;AACA;;;;;;;;;;;;;;;;;;ACvKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0E;AACrB;AACS;AACN;AACiB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,wDAAO;AACjD;AACA;AACA,uCAAuC,wDAAO;AAC9C;AACA,mEAAmE,wDAAO,uBAAuB,wDAAO;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,oDAAG;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,wDAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wDAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,wDAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,wDAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qEAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qEAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6DAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yFAA4B;AACtD,eAAe,oEAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yFAA4B;AAC7D,2CAA2C,wDAAO;AAClD;AACA;;;;;;;;;;;;;;;;;;;;;;;;AClMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsC;AACiB;AACE;AAC1B;;;;;;;;;;;;;;ACzB/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiD;AACjD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4CAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,yCAAG;AAC3C,wCAAwC,yCAAG;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA,mBAAmB,4CAAM;AACzB;AACA;;;;;;;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AACtD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6CAAO;AACtC,iCAAiC,6CAAO;AACxC,6BAA6B,6CAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6CAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6CAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,6CAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,6CAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6CAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,6CAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,QAAQ,aAAa,SAAS,WAAW,OAAO;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4CAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AAC9C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA,4BAA4B,aAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA,4BAA4B,aAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC,4BAA4B,eAAe;AAC3C,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA,mBAAmB,4CAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8CAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC,4BAA4B,WAAW;AACvC;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,wCAAwC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,uBAAuB;AAC5D;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA,qCAAqC,uBAAuB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C,iCAAiC,uBAAuB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C,iCAAiC,uBAAuB;AACxD;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiE;AAC1D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,KAAK,OAAO,KAAK,OAAO,KAAK,OAAO,KAAK;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4CAAM;AACzB;AACA;AACA;AACA,mBAAmB,8CAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8CAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mDAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4CAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4CAAM;AACjC,yBAAyB,4CAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoC;AACO;AACpC;AACP;AACA;AACA,8BAA8B,oDAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4CAAM;AACjC,wBAAwB,OAAO;AAC/B;AACA,+BAA+B,4CAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AAC9C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA,mBAAmB,4CAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4CAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4CAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4CAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8CAAQ;AAC3B;AACA;;;;;;;;;;;;;;;;AC7ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4C;AACP;AACA;AACrC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA,mBAAmB,8CAAM;AACzB;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wDAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8CAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8CAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8CAAM;AACzB;AACA;AACA;AACA,mBAAmB,8CAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8CAAM;AACzB;AACA;;;;;;;;;;;;;;;;;;;;AC/O2C;AACI;AACF;AACoB;;;;;;;;;;;;;;;;;;;;ACHjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqC;AACA;AACA;AACI;;;;;;;;;;;;;;ACzBzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiD;AACjD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,4BAA4B,OAAO;AACnC;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA,mBAAmB,0DAAY;AAC/B;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+FAA+F;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0DAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA;AACA;AACA,+BAA+B,KAAK,UAAU,UAAU,KAAK,IAAI,KAAK,IAAI,GAAG,OAAO;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qCAAqC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoC;AAC7B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4CAAM;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqE;AACD;AACkB;AAChC;AACiB;AACY;AACZ;AACvE;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,4EAAe;AAC7C,iCAAiC,4DAAU;AAC3C,+BAA+B,yFAAsB;AACrD;AACA;AACA;AACA,0BAA0B,2CAAK,0BAA0B,8CAAQ,2BAA2B,8CAAQ;AACpG;AACA,uBAAuB,6EAAgB;AACvC;AACA,mBAAmB,yFAAsB;AACzC;AACA;AACA,eAAe,gDAAM;AACrB;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sDAAsD,IAAI;AACtE;AACA;AACA;AACA,4BAA4B,iDAAW;AACvC,4BAA4B,iDAAW;AACvC;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,SAAS,QAAQ,gBAAgB,IAAI,IAAI,4CAAM,OAAO;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2EAAe,IAAI,+EAAmB;AACrE,mBAAmB,gFAAuB;AAC1C;AACA;;;;;;;;;;;;;AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4D;AACN;AAC6B;AACnF;AACA;AACA;AACO;AACP;AACA,qBAAqB,8CAAQ;AAC7B;AACA;AACA;AACA;AACA,uCAAuC,6CAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4CAAM;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2CAAK;AAC5B,+BAA+B,4DAAU;AACzC,0BAA0B,yFAAsB;AAChD,wBAAwB,2CAAK;AAC7B,2BAA2B,yFAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoD;AACK;AACwB;AACxC;AACI;AAC7C;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,0BAA0B,qDAAe;AACzC,0BAA0B,qDAAe;AACzC,0BAA0B,qDAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAU;AAChC,iCAAiC,8CAAQ;AACzC;AACA;AACA;AACA;AACA;AACA,yBAAyB,8CAA8C;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yCAAG;AACpB;AACA;AACA,yBAAyB,4DAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yFAAsB,KAAK,2CAAK;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gFAAgF;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,0BAA0B,kDAAQ;AAClC;AACA;AACA;AACA;AACA;AACA,yBAAyB,yGAAyG;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2CAAK;AACxB;AACA;;;;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0C;AAC1C;AACO;AACP;AACA,qBAAqB,8CAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6BAA6B,IAAI;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2CAAK;AAC5B;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACnNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoD;AACkB;AACW;AACd;AACtB;AAC7C;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,mCAAmC,8CAAQ;AAC3C;AACA;AACA;AACA;AACA,wBAAwB,sDAAU;AAClC;AACA;AACA;AACA,+BAA+B,4DAAU;AACzC;AACA,iCAAiC,8CAAQ;AACzC,iCAAiC,8CAAQ;AACzC,8BAA8B,2CAAK;AACnC,mCAAmC,yFAAsB;AACzD;AACA;AACA;AACA;AACA;AACA,+BAA+B,sEAAgC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qGAAqG;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sFAA4B;AACnD;AACA;AACA;AACA;AACA,SAAS;AACT,mBAAmB,2CAAK,iBAAiB,8CAAQ,uCAAuC,8CAAQ;AAChG;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACjF+D;AACQ;AAC9B;AACI;AACU;AACV;AACgB;;;;;;;;;;;;;;;;ACN7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqF;AAClD;AACU;AAC7C;AACO,+BAA+B,sDAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iEAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iEAA2B;AACtD;AACA;AACA;AACA;AACA,2BAA2B,iEAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6FAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqF;AAC/C;AACyB;AAC/D;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6FAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6FAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4EAAoB;AACtC,+BAA+B,8CAAQ;AACvC;AACA,SAAS,yCAAyC,iBAAiB;AACnE,mBAAmB,8CAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4EAAoB;AACtC,+BAA+B,8CAAQ;AACvC;AACA,SAAS,yCAAyC,iBAAiB;AACnE,mBAAmB,8CAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA,0BAA0B,8CAAQ,CAAC,4EAAoB;AACvD,mCAAmC,8CAAQ;AAC3C;AACA,aAAa,yCAAyC,iCAAiC;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA,0BAA0B,8CAAQ,CAAC,4EAAoB;AACvD,mCAAmC,8CAAQ;AAC3C;AACA,aAAa,yCAAyC,kCAAkC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoD;AACiC;AAC1C;AACE;AAC7C;AACO,oCAAoC,sDAAU;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,4DAAU;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6FAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2CAAK;AAChC;AACA;AACA;AACA,uCAAuC,iDAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2CAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6D;AAC7D;AACO,qCAAqC,sEAAkB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoD;AACT;AAC4C;AAC1C;AACI;AACR;AACzC;AACO,iCAAiC,sDAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,4DAAU;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2CAAK;AAChC;AACA;AACA;AACA,gDAAgD,oDAAc;AAC9D;AACA,wBAAwB,mBAAmB;AAC3C,uBAAuB,oDAAc;AACrC;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kDAAQ,KAAK,2CAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6FAAuB;AAC1C;AACA;AACA,mCAAmC,0DAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AAC7C;AACA;AACA;AACA;AACA;AACO,6BAA6B,sDAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC9FmE;AACE;AAChB;;;;;;;;;;;;;;ACFrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiC;;;;;;;;;;;;;;ACtBjC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF;AACjF,CAAC,sCAAsC;AACvC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,KAAK;AACnD;AACA;AACA;;;;;;;;;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AACrB;AACqC;AACtB;AACzC;AACP;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AACxC;AACP;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,uEAAoB;AAChH;AACA;AACA,mBAAmB,kEAAsB;AACzC;AACA;AACA;AACA;AACA;AACA,uCAAuC,mDAAE,GAAG;AAC5C;AACA;AACA;AACA;AACA,qCAAqC,2BAA2B,GAAG,2BAA2B,GAAG,2BAA2B;AAC5H,qCAAqC,2BAA2B,GAAG,2BAA2B,GAAG,2BAA2B;AAC5H;AACA;AACA,qCAAqC,2BAA2B;AAChE;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA,wBAAwB,wDAAO;AAC/B,wBAAwB,wDAAO;AAC/B,wBAAwB,wDAAO;AAC/B,qBAAqB,wDAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oFAAoF,uEAAoB;AACxG;AACA;AACA,mBAAmB,kEAAsB;AACzC;AACA,uCAAuC,mDAAE,GAAG;AAC5C,uBAAuB,kEAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA,wBAAwB,wDAAO;AAC/B,wBAAwB,wDAAO;AAC/B,wBAAwB,wDAAO;AAC/B,qBAAqB,wDAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,wBAAwB,wDAAO,aAAa,oDAAG,EAAE;AACjD;AACA;AACA,oBAAoB,oDAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,mDAAE;AACxD;AACA;AACA;AACA;AACA;AACA,yCAAyC,mDAAE;AAC3C;AACA;AACA;AACA;AACA;AACA,uBAAuB,mDAAE;AACzB;AACA,2BAA2B,mDAAE;AAC7B;AACA,wBAAwB,mDAAE;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA;AACA,uBAAuB,kEAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8EAAkC;AAC7D,qBAAqB;AACrB;AACA,iCAAiC,qDAAI;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8EAAkC;AAC7D,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oDAAG;AACpB,iBAAiB,oDAAG;AACpB,eAAe,oDAAG;AAClB,qCAAqC,oDAAG;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qCAAqC;AACpD;AACA;AACA,yBAAyB,mDAAE;AAC3B,yBAAyB,mDAAE;AAC3B;AACA;AACA,+BAA+B,+EAAmC;AAClE,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,sDAAK;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,oDAAG;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oFAAwC;AACnE,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2EAA+B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mDAAE;AAC/B;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,mDAAE;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,mDAAE;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAG;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oDAAG;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oDAAG;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oDAAG;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oDAAG;AAChC;AACA;AACA,6BAA6B,oDAAG;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAG;AACjC;AACA;AACA,8BAA8B,oDAAG;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0KAA0K;AAC1L,cAAc,8BAA8B;AAC5C,gBAAgB,UAAU,uEAAoB,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oDAAG;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oDAAG;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oDAAG;AAChC;AACA,6CAA6C,mDAAE;AAC/C;AACA;AACA,iCAAiC,oDAAG;AACpC;AACA;AACA,iCAAiC,oDAAG;AACpC;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yCAAyC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,oDAAG;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,oDAAG;AAChE,uDAAuD,oDAAG;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6NAA6N;AAC7O,cAAc,gKAAgK;AAC9K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,mDAAE;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,mDAAE;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,oDAAG;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,oDAAG;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,oDAAG;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mBAAmB;AACjC,gBAAgB,2KAA2K;AAC3L;AACA;AACA,2CAA2C,oDAAG;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,0CAA0C;AAC1C,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,WAAW;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sCAAsC;AACtD,cAAc,KAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oEAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oDAAG;AAClC,+EAA+E,oDAAG;AAClF;AACA;AACA,wBAAwB,oDAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE,4BAA4B,wDAAO,aAAa,oDAAG,EAAE;AACrD;AACA;AACA,wBAAwB,oDAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gDAAgD,uEAAoB,iGAAiG;AACrL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB,gBAAgB,KAAK;AACrB,gBAAgB,MAAM;AACtB,gBAAgB,QAAQ;AACxB;AACA,uBAAuB,kEAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2DAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mEAAmE;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kEAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,qDAAI;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,sDAAK;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oDAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qHAAqH;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2CAA2C;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;;;;;;;;;;;;;;AChmGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AACtD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8DAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AACE;AACvD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,+DAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU,GAAG,wBAAwB;AACvD;AACA;AACA;AACA,0DAA0D,+DAAc;AACxE,mBAAmB,yEAAuB;AAC1C;AACA;AACA;;;;;;;;;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmC;AACnC;AACO,uBAAuB,4CAAK;AACnC;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmC;AACnC;AACO,uBAAuB,4CAAK;AACnC;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmC;AACnC;AACO,sBAAsB,4CAAK;AAClC;;;;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0F;AACzC;AACM;AACpB;AACM;AACA;AACA;AACF;AAChC,uBAAuB,4CAAK;AACnC;AACA;AACA;AACA,sBAAsB,oDAAoD;AAC1E,oDAAoD,wCAAwC;AAC5F;AACA;AACA;AACA;AACA;AACA,4FAA4F,eAAe;AAC3G;AACA;AACA;AACA;AACA,mBAAmB,yEAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,KAAK,SAAS,UAAU,4BAA4B,2DAAU;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yEAAuB;AAC1C,mBAAmB,kDAAQ;AAC3B;AACA;AACA,mBAAmB,gDAAO;AAC1B;AACA;AACA;AACA;AACA,2DAA2D,wDAAO;AAClE;AACA,mBAAmB,kDAAQ;AAC3B;AACA;AACA;AACA,mBAAmB,yEAAuB;AAC1C,qCAAqC,yDAAe;AACpD,6BAA6B,+DAAc;AAC3C;AACA,6CAA6C,+DAAc;AAC3D,mBAAmB,kDAAQ;AAC3B;AACA;AACA;AACA,wBAAwB,6DAAQ;AAChC,wCAAwC,wDAAO,IAAI,oDAAG;AACtD;AACA,sBAAsB,oDAAG;AACzB;AACA;AACA;AACA;AACA,kCAAkC,wDAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wCAAwC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxCmC;AACM;AACA;AACA;AACF;AACE;AACM;AACA;;;;;;;;;;;;;;;;;;;ACP/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkD;AAClD;AACA;AACA;AACA;AACA;AACO;AACP,8BAA8B,wCAAE;AAChC;AACA;AACA;AACA;AACA;AACA;AACO;AACP,uBAAuB,wCAAE;AACzB;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACO;AACP,mBAAmB,wCAAE,kBAAkB,wCAAE;AACzC,wEAAwE;AACxE;AACA,sBAAsB,6CAAO;AAC7B;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY,mDAAmD;AAC3E;AACO;AACP,mBAAmB,wCAAE,cAAc,wCAAE;AACrC,uEAAuE;AACvE;AACA,sBAAsB,6CAAO;AAC7B;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACO;AACP;AACA,sEAAsE;AACtE;AACA,sBAAsB,6CAAO;AAC7B;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY,qDAAqD;AAC7E;AACO;AACP;AACA,wEAAwE;AACxE;AACA,sBAAsB,6CAAO;AAC7B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtFiC;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACD2D;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,WAAW;AACvB,YAAY,UAAU;AACtB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wCAAE;AACpB,eAAe,yCAAG;AAClB;AACA,iBAAiB,wCAAE;AACnB,eAAe,yCAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,6CAAO;AACxB,iBAAiB,6CAAO;AACxB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,gBAAgB;AAC5B,yBAAyB,6CAAO;AAChC,yBAAyB,6CAAO;AAChC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA,eAAe,sDAAgB;AAC/B,eAAe,sDAAgB;AAC/B,eAAe,sDAAgB;AAC/B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,gBAAgB;AAC5B,wBAAwB;AACxB,8BAA8B;AAC9B,8CAA8C;AAC9C,8DAA8D;AAC9D;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,wBAAwB,6CAAO;AAC/B,wBAAwB,6CAAO;AAC/B;AACA;AACA;AACA,sBAAsB,6CAAO;AAC7B,sBAAsB,6CAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,4CAA4C,wCAAE;AAC9C,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,aAAa,4BAA4B,6CAAO,iBAAiB,6CAAO;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,WAAW;AACvB,0BAA0B,6CAAO;AACjC,0BAA0B,6CAAO;AACjC,6BAA6B,wCAAwC;AACrE;AACA;AACO;AACP;AACA;AACA;AACA;AACA,qCAAqC,0DAAoB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oCAAoC,0DAAoB;AACxD,iBAAiB,iDAAW;AAC5B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,YAAY,OAAO;AACnB;AACA;AACA,2BAA2B,6CAAO;AAClC,2BAA2B,6CAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,sBAAsB,6CAAO;AAC7B,oBAAoB,6CAAO;AAC3B;AACA,iBAAiB,6CAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,sBAAsB,6CAAO;AAC7B,sBAAsB,6CAAO;AAC7B;AACA,kBAAkB,6CAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,0DAA0D,GAAG;AAC7D;AACA;AACA,4DAA4D,GAAG;AAC/D;AACA,yCAAyC,6CAAO;AAChD,wCAAwC,6CAAO;AAC/C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,uBAAuB,6CAAO;AAC9B,uBAAuB,6CAAO;AAC9B;AACA,4BAA4B,6CAAO,SAAS,yCAAG;AAC/C;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oDAAoD,EAAE;AACtD;AACA;AACA,oDAAoD,EAAE;AACtD;AACA;AACA;AACA,gDAAgD,6CAAO;AACvD,+CAA+C,6CAAO;AACtD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kBAAkB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AACpC;AACP;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtFvC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACO;AACP;AACO;AACA;AACA;AACP;AACO;AACP;AACO;AACP;AACO;AACP;AACO;AACP;AACO;AACP;AACA;AACA;AACO;AACA;AACA;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACA,8BAA8B;AAC9B;;;;;;;;;;;;;;;ACrF8E;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,6DAA6D,yDAAmB;AACvF;AACA,oBAAoB,yCAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gEAA0B;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,mEAAmE,yDAAmB;AAC7F;AACA,oBAAoB,yCAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yDAAmB;AAChD;AACA,mDAAmD;AACnD,uBAAuB,gEAA0B;AACjD;AACA,uBAAuB,sDAAgB;AACvC;AACA,qBAAqB,yDAAmB;AACxC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvDA;AAC0E;AACA;AACtB;AACe;AACnE;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0DAA0D,yFAA4B;AAC7F;AACA,aAAa,yFAA4B;AACzC;AACA,aAAa,4FAA+B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,sDAAsD,yFAA4B;AACzF;AACA,aAAa,yFAA4B;AACzC;AACA,aAAa,yFAA4B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,KAAK,oEAAuB;AAC5B,KAAK,oEAAuB;AAC5B,KAAK,wEAA2B;AAChC,KAAK,mEAAsB;AAC3B,KAAK,oEAAuB;AAC5B,KAAK,8EAAiC;AACtC,KAAK,iEAAoB;AACzB,KAAK,2FAA8C;AACnD,KAAK,wFAA2C;AAChD,KAAK,0EAA6B;AAClC,KAAK,gHAAmE;AACxE,KAAK,iFAAoC;AACzC,KAAK,0EAA6B;AAClC,KAAK,wEAA2B;AAChC,KAAK,4EAA+B;AACpC,KAAK,4EAA+B;AACpC,KAAK,6EAAgC;AACrC,KAAK,kFAAqC;AAC1C,KAAK,oEAAuB;AAC5B,KAAK,uEAA0B;AAC/B,KAAK,+EAAkC;AACvC,KAAK,qEAAwB;AAC7B,KAAK,qFAAwC;AAC7C,KAAK,oEAAuB;AAC5B,KAAK,wFAA2C;AAChD,KAAK,gFAAmC;AACxC,KAAK,qEAAwB;AAC7B,KAAK,qEAAwB;AAC7B,KAAK,6EAAgC;AACrC,KAAK,kFAAqC;AAC1C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iEAAsB;AAC9C,wBAAwB,iEAAsB;AAC9C;AACA;AACA;AACA,0CAA0C,oDAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5e+B;AACA;AACK;AACN;AACkB;;;;;;;;;;;;;;ACJK;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,cAAc,iDAAO;AACrB;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA,uBAAuB,4CAAM;AAC7B;AACA;AACA,uBAAuB,4CAAM;AAC7B;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA,eAAe,4CAAM;AACrB;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO,8BAA8B;AACrC;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO,mCAAmC;AAC1C;AACA;AACA;AACO;AACP;AACA;AACA;AACO;;;;;;;;;;;;;ACtFP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,2BAA2B,MAAM;AACjC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,igBAAigB,QAAQ;AACzgB;AACA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,mDAAmD,QAAQ;AAC3D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACa;;;;;;;;;;;;;;;;;;;;;;ACp2B+C;AACJ;AACxD;AACA;AACA;AACO;AACP,kCAAkC,+CAAG;AACrC,0BAA0B,+CAAG;AAC7B,2BAA2B,+CAAG;AAC9B;AACA,2BAA2B,+CAAG;AAC9B,2BAA2B,+CAAG;AAC9B;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4DAAY;AAC5B;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA,iGAAiG;AACjG,gDAAgD,mDAAO;AACvD;AACA;AACA;AACA;AACO;AACP,wBAAwB,+CAAG;AAC3B,sBAAsB,mDAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,qCAAqC,uDAAe;AACpD,6GAA6G,gDAAQ;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACO;AACP;AACA;AACA;AACA,cAAc,kBAAkB,EAAE,kBAAkB;AACpD;;;;;;;;;;;;;;AC9HA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD;AAC9C;AACP;AACA;AACA;AACA,CAAC,wCAAwC;;;;;;;;;;;;;;;;;;;;;;ACnB2D;AAC5C;AACH;AACrD;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP,oBAAoB,uEAAW,KAAK;AACpC;AACA,kBAAkB,+EAAmB;AACrC;AACA,mBAAmB,+EAAmB;AACtC;AACA,eAAe,uFAA2B;AAC1C,kBAAkB,uFAA2B;AAC7C,8BAA8B,mDAAO;AACrC,gCAAgC,mDAAO;AACvC,qCAAqC,mDAAO;AAC5C;AACA,kBAAkB,uEAAW,CAAC,gFAAoB;AAClD,gBAAgB,+EAAmB,aAAa,8CAAE;AAClD;AACA;AACA,qDAAqD;AACrD;AACA,mBAAmB,uDAAO,GAAG,qCAAqC,IAAI,wBAAwB;AAC9F,sCAAsC,mEAAuB,oBAAoB,oEAAwB;AACzG;AACO;AACP;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,cAAc,8DAAI;AAClB;AACA,mCAAmC,gEAAoB;AACvD,iBAAiB,uDAAW;AAC5B;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,eAAe,8DAAI;AACnB;AACA,mCAAmC,gEAAoB;AACvD,qBAAqB,uDAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,CAAC;AACM;AACP,gBAAgB,mDAAO;AACvB,gBAAgB,mDAAO;AACvB;AACA,CAAC;AACM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1FP;AACA;AACA;AACA,kDAAkD,wCAAwC;AAC1F;AACA;AACA;;;;ACNA;;;;ACAA;AACA;AACA;AACA,uDAAuD,iBAAiB;AACxE;AACA,gDAAgD,aAAa;AAC7D;;;;ACNA;;;;ACAA;;;;;;;;;;;;;;;;;;;;ACA6D;AACD;AACV;AACkC;AACzB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4EAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,aAAa,iFAAyB;AACtC;AACA;AACA,aAAa,6FAAqC;AAClD;AACA;AACA,aAAa,2FAAmC;AAChD;AACA;AACA,aAAa,4FAAoC;AACjD;AACA;AACA,aAAa,8FAAsC;AACnD;AACA;AACA;AACA;AACA;AACA,wBAAwB,6FAAqC,oBAAoB,2FAAmC;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0FAAkC;AACxD;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,wBAAwB,wEAAQ;AAChC,qBAAqB,8DAAI;AACzB,uDAAuD;AACvD;AACA;AACA,yDAAyD;AACzD;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4EAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA,+BAA+B,4EAAoB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0FAAkC;AACpD;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,wBAAwB,wEAAQ;AAChC,cAAc,8DAAI;AAClB;AACA,uDAAuD;AACvD,iBAAiB,uDAAW;AAC5B,iDAAiD,mDAAO;AACxD,iDAAiD,mDAAO;AACxD,iDAAiD,mDAAO;AACxD,iDAAiD,mDAAO;AACxD,wBAAwB,oEAAe;AACvC,4BAA4B,oEAAe;AAC3C,4BAA4B,oEAAe;AAC3C;AACA;AACA;AACA;AACA,eAAe,0DAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uDAAO,uBAAuB,+CAAG;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0DAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uDAAO,uBAAuB,+CAAG;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,wBAAwB,6DAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,2FAAmC;AACjD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,qCAAqC,6DAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"}